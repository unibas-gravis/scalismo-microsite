"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2181],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9781:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={id:"tutorial05",title:"Gaussian processes, sampling and marginalization"},l=void 0,c={unversionedId:"Tutorials/tutorial05",id:"Tutorials/tutorial05",title:"Gaussian processes, sampling and marginalization",description:"In this tutorial we will experiment with sampling and marginalization of",source:"@site/docs/Tutorials/tutorial05.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial05",permalink:"/docs/next/Tutorials/tutorial05",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial05.md",tags:[],version:"current",frontMatter:{id:"tutorial05",title:"Gaussian processes, sampling and marginalization"},sidebar:"docs",previous:{title:"Gaussian processes and Point Distribution Models",permalink:"/docs/next/Tutorials/tutorial04"},next:{title:"Building a shape model from data",permalink:"/docs/next/Tutorials/tutorial06"}},p=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Discrete and Continuous Gaussian processes",id:"discrete-and-continuous-gaussian-processes",children:[],level:4},{value:"From continuous to discrete: marginalization and discretization",id:"from-continuous-to-discrete-marginalization-and-discretization",children:[],level:2},{value:"Changing the reference of a point distribution model",id:"changing-the-reference-of-a-point-distribution-model",children:[],level:2},{value:"Probability of shapes and deformations:",id:"probability-of-shapes-and-deformations",children:[],level:2}],u={toc:p};function d(e){var t=e.components,s=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this tutorial we will experiment with sampling and marginalization of\nGaussian processes. Furthermore, we will learn how to compare the\nlikelihood of instances of our model."),(0,o.kt)("h5",{id:"related-resources"},"Related resources"),(0,o.kt)("p",null,"The following resources from our ",(0,o.kt)("a",{parentName:"p",href:"https://www.futurelearn.com/courses/statistical-shape-modelling"},"online course")," may provide\nsome helpful context for this tutorial:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The marginalization property ",(0,o.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250339"},"(Video)")),(0,o.kt)("li",{parentName:"ul"},"Sampling from a shape model ",(0,o.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250340"},"(Article)"))),(0,o.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{target:"_blank",href:n(8744).Z},"Tutorial05.scala"))),(0,o.kt)("h5",{id:"preparation"},"Preparation"),(0,o.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.ui.api._\nimport scalismo.geometry._\nimport scalismo.common._\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.mesh._\nimport scalismo.io.StatisticalModelIO\nimport scalismo.statisticalmodel._\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"scalismo.initialize()\nimplicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)\n\nval ui = ScalismoUI()\n")),(0,o.kt)("h4",{id:"discrete-and-continuous-gaussian-processes"},"Discrete and Continuous Gaussian processes"),(0,o.kt)("p",null,"We have seen in the last tutorial that a Point Distribution Model (PDM)\nis represented in Scalismo as a (discrete) Gaussian process over deformation fields,\ndefined on a reference mesh."),(0,o.kt)("p",null,"To continue our exploration of Gaussian processes, we therefore start\nby loading (and visualizing) an existing PDM and retrieve its underlying\nGaussian process"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File("datasets/bfm.h5")).get\nval gp = model.gp\n\nval modelGroup = ui.createGroup("modelGroup")\nval ssmView = ui.show(modelGroup, model, "model")\n')),(0,o.kt)("p",null,"We can retrieve random samples from the Gaussian process by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"sample"),"\non the ",(0,o.kt)("inlineCode",{parentName:"p"},"gp")," object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val sampleDF : DiscreteField[_3D, TriangleMesh, EuclideanVector[_3D]] = model.gp.sample()\n\nval sampleGroup = ui.createGroup("sample")\nui.show(sampleGroup, sampleDF, "discreteSample")\n')),(0,o.kt)("p",null,"Note that the sampled vector field is ",(0,o.kt)("strong",{parentName:"p"},"discrete"),"; I.e. is\ndefined over a ",(0,o.kt)("strong",{parentName:"p"},"discrete set of points"),".\nThis is due to the fact that our Gaussian Process is stored in a file\nand was therefore discretized over the points of the reference mesh."),(0,o.kt)("p",null,"As seen in the previous tutorial, we could interpolate the\nsample ",(0,o.kt)("inlineCode",{parentName:"p"},"sampleDf")," to obtain a continuous version of the deformation field.\nA more convenient approach is, however, to interpolate the\nGaussian process directly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\nval contGP = model.gp.interpolate(interpolator)\n")),(0,o.kt)("p",null,"When we sample now from the continuous GP, we obtain a vector-valued function,\nwhich is defined on the entire 3D Space:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val contSample: Field[_3D, EuclideanVector[_3D]] = contGP.sample()\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Attention: While the interpolated Gaussian process is now defined on the entire 3D Space, the interpolation really only makes sense close to the mesh points"),"."),(0,o.kt)("h2",{id:"from-continuous-to-discrete-marginalization-and-discretization"},"From continuous to discrete: marginalization and discretization"),(0,o.kt)("p",null,"In practice, we will never work with a continuous Gaussian process directly.\nWe are always interested in the distribution on a finite set of points.\nThe real advantage of having a continuous Gaussian process is, that we can\nget samples at ",(0,o.kt)("em",{parentName:"p"},"any")," finite set of points and thereby choosing the discretization\naccording to the needs of our application."),(0,o.kt)("p",null,"To illustrate this, we could, for example obtain a sample,\nwhich is defined on all the points of the original reference mesh."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val fullSample = contGP.sampleAtPoints(model.reference)\nval fullSampleView = ui.show(sampleGroup, fullSample, "fullSample")\n')),(0,o.kt)("p",null,"The marginalization property of a Gaussian process makes it possible not only\nto obtain samples at an arbitrary set of points, but also the\ndistribution at these points. We can\nobtain this distribution, by calling the method ",(0,o.kt)("inlineCode",{parentName:"p"},"marginal"),"\non the Gaussian process instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val referencePointSet = model.reference.pointSet\nval rightEyePt: Point[_3D] = referencePointSet.point(PointId(4281))\nval leftEyePt: Point[_3D] = referencePointSet.point(PointId(11937))\nval marginal : DiscreteGaussianProcess[_3D, UnstructuredPointsDomain, EuclideanVector[_3D]] = contGP.marginal(IndexedSeq(rightEyePt,leftEyePt))\n")),(0,o.kt)("p",null,"The result of marginalization is again a discrete Gaussian process. As we have specified individual points, on which\nto evaluate the Gaussian process, but not how these points are connected, the resulting\ndiscrete Gaussian process is defined over an ",(0,o.kt)("inlineCode",{parentName:"p"},"UnstructuredPointsDomain"),".\nTo obtain a discrete Gaussian Process with a richer structure, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"discretize")," method,\nwhich takes as an argument a domain and result in a discrete Gaussian Process defined on that domain."),(0,o.kt)("p",null,"To obtain the Gaussian Process that we started with again, we can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"discretize")," method\nwith the reference mesh:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val discreteGP : DiscreteGaussianProcess[_3D, TriangleMesh, EuclideanVector[_3D]] = contGP.discretize(model.reference)\n")),(0,o.kt)("p",null,"This mechanism of interpolation followed by discretization gives us the ability to freely change\nthe resolution of the domain on which the Gaussian process is defined."),(0,o.kt)("h2",{id:"changing-the-reference-of-a-point-distribution-model"},"Changing the reference of a point distribution model"),(0,o.kt)("p",null,"Given that a point distribution model is really just a wrapper around a Gaussian process, it\nis not surprising that we can apply the same ideas to these models. In particular, we often\nwould like to change the domain (I.e., the reference) of a point distribution model.\nThis can be done using the method ",(0,o.kt)("inlineCode",{parentName:"p"},"newReference")," of the point distribution model. Under the hood, the method ",(0,o.kt)("inlineCode",{parentName:"p"},"newReference"),"\ninterpolates the gaussian process and discretizes it with the new reference."),(0,o.kt)("p",null,"In the following example we use this method to obtain a model which is defined on a low-resolution mesh:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val lowresMesh = model.reference.operations.decimate(1000)\nval lowResModel = model.newReference(lowresMesh, TriangleMeshInterpolator3D())\n")),(0,o.kt)("p",null,"Other common applications of this method include restricting the model to only a part of the domain."),(0,o.kt)("h2",{id:"probability-of-shapes-and-deformations"},"Probability of shapes and deformations:"),(0,o.kt)("p",null,"It is often interesting to assess how probable a model instance is.\nThis can be done in Scalismo by means of the method ",(0,o.kt)("inlineCode",{parentName:"p"},"pdf "),"\n(which stands for probability density function) of the class ",(0,o.kt)("inlineCode",{parentName:"p"},"GaussianProcess"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"StatisticalMeshModel")," respectively."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val defSample = model.gp.sample()\nmodel.gp.pdf(defSample)\n")),(0,o.kt)("p",null,"The value of the ",(0,o.kt)("em",{parentName:"p"},"pdf")," is often not interesting as such. But it allows us to compare the likelihood of different instances, by comparing their density value.\nFor numerical reasons, we usually work with the log probability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val defSample1 = model.gp.sample()\nval defSample2 = model.gp.sample()\n\nval logPDF1 = model.gp.logpdf(defSample1)\nval logPDF2 = model.gp.logpdf(defSample2)\n\nval moreOrLess = if (logPDF1 > logPDF2) "more" else "less"\nprintln(s"defSample1 is $moreOrLess likely than defSample2")\n')))}d.isMDXComponent=!0},8744:function(e,t,n){t.Z=n.p+"assets/files/Tutorial05-3df63821fc6f896fe558b9ea451425c7.scala"}}]);