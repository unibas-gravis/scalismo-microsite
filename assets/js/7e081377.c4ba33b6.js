"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9211],{3905:function(e,a,n){n.d(a,{Zo:function(){return p},kt:function(){return d}});var t=n(7294);function s(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){s(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,s=function(e,a){if(null==e)return{};var n,t,s={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(s[n]=e[n]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=t.createContext({}),m=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},p=function(e){var a=m(e.components);return t.createElement(o.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=m(n),d=s,h=u["".concat(o,".").concat(d)]||u[d]||c[d]||r;return n?t.createElement(h,l(l({ref:a},p),{},{components:n})):t.createElement(h,l({ref:a},p))}));function d(e,a){var n=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=n.length,l=new Array(r);l[0]=u;var i={};for(var o in a)hasOwnProperty.call(a,o)&&(i[o]=a[o]);i.originalType=e,i.mdxType="string"==typeof e?e:s,l[1]=i;for(var m=2;m<r;m++)l[m]=n[m];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9151:function(e,a,n){n.r(a),n.d(a,{frontMatter:function(){return i},contentTitle:function(){return o},metadata:function(){return m},toc:function(){return p},default:function(){return u}});var t=n(7462),s=n(3366),r=(n(7294),n(3905)),l=["components"],i={id:"tutorial07",title:"Shape modelling with Gaussian processes and kernels"},o=void 0,m={unversionedId:"Tutorials/tutorial07",id:"version-0.92/Tutorials/tutorial07",title:"Shape modelling with Gaussian processes and kernels",description:"In this tutorial we learn how to define our own Gaussian processes using analytically",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial07.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial07",permalink:"/docs/Tutorials/tutorial07",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial07.md",tags:[],version:"0.92",frontMatter:{id:"tutorial07",title:"Shape modelling with Gaussian processes and kernels"},sidebar:"docs",previous:{title:"Building a shape model from data",permalink:"/docs/Tutorials/tutorial06"},next:{title:"Posterior shape models",permalink:"/docs/Tutorials/tutorial08"}},p=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Modelling deformations using Gaussian processes:",id:"modelling-deformations-using-gaussian-processes",children:[{value:"The mean:",id:"the-mean",children:[],level:5},{value:"The covariance function:",id:"the-covariance-function",children:[],level:5},{value:"Building the GP :",id:"building-the-gp-",children:[],level:5},{value:"Low-rank approximation",id:"low-rank-approximation",children:[],level:4},{value:"Building more interesting kernels",id:"building-more-interesting-kernels",children:[{value:"Kernels from Statistical Shape Models",id:"kernels-from-statistical-shape-models",children:[],level:4},{value:"Changepoint kernel:",id:"changepoint-kernel",children:[],level:4},{value:"Symmetrizing a kernel",id:"symmetrizing-a-kernel",children:[],level:4}],level:3}],level:2}],c={toc:p};function u(e){var a=e.components,i=(0,s.Z)(e,l);return(0,r.kt)("wrapper",(0,t.Z)({},c,i,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial we learn how to define our own Gaussian processes using analytically\ndefined kernels. Further, we experiment with different kernels that are useful in\nshape modelling."),(0,r.kt)("h5",{id:"related-resources"},"Related resources"),(0,r.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,r.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Covariance functions ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250350"},"(Video)")),(0,r.kt)("li",{parentName:"ul"},"Constructing kernels for shape modelling ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250351"},"(Article)")),(0,r.kt)("li",{parentName:"ul"},"Enlarging the flexibility of statistical shape models ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250357"},"(Article)"))),(0,r.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:n(8209).Z},"Tutorial07.scala"))),(0,r.kt)("h5",{id:"preparation"},"Preparation"),(0,r.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry.*\nimport scalismo.common.*\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.mesh.*\nimport scalismo.io.{StatisticalModelIO, MeshIO}\nimport scalismo.statisticalmodel.*\nimport scalismo.numerics.UniformMeshSampler3D\nimport scalismo.kernels.*\n\nimport scalismo.ui.api.*\n\nimport breeze.linalg.{DenseMatrix, DenseVector}\n\nimport java.io.File\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  scalismo.initialize()\n\n  val ui = ScalismoUI()\n")),(0,r.kt)("p",null,"In the following we will visualize the effect different Gaussian process models have,\non a given reference mesh. We start by loading this reference mesh and visualizing\nit in a separate group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val referenceMesh = MeshIO.readMesh(File("datasets/lowResPaola.ply")).get\n\n  val modelGroup = ui.createGroup("gp-model")\n  val referenceView = ui.show(modelGroup, referenceMesh, "reference")\n')),(0,r.kt)("h2",{id:"modelling-deformations-using-gaussian-processes"},"Modelling deformations using Gaussian processes:"),(0,r.kt)("p",null,"A Gaussian Process is defined by two components: the ",(0,r.kt)("strong",{parentName:"p"},"mean function")," and the ",(0,r.kt)("strong",{parentName:"p"},"covariance function"),"."),(0,r.kt)("h5",{id:"the-mean"},"The mean:"),(0,r.kt)("p",null,"As our goal is to model deformation fields, the mean of the Gaussian process will naturally be a deformation field. It is the deformation field that deforms our reference mesh into the mean shape."),(0,r.kt)("p",null,"In the case where the reference shape we select roughly corresponds to an average shape, and without any additional knowledge about our shape space, a zero mean is a reasonable choice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val zeroMean = Field(EuclideanSpace3D, (pt:Point[_3D]) => EuclideanVector3D(0,0,0))\n")),(0,r.kt)("h5",{id:"the-covariance-function"},"The covariance function:"),(0,r.kt)("p",null,"The covariance function, or ",(0,r.kt)("em",{parentName:"p"},"kernel")," function,\ndefines the properties that characterize likely deformations in our model.\nRecall, that a covariance function is a symmetric, positive semi-definite function,\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"k"),(0,r.kt)("mo",{parentName:"mrow"},":"),(0,r.kt)("mi",{parentName:"mrow"},"X"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"X"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"R"),(0,r.kt)("mrow",{parentName:"msup"},(0,r.kt)("mi",{parentName:"mrow"},"d"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"d")))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k: X \\times X \\to R^{ d \\times d}")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},":"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8491079999999999em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.00773em"}},"R"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8491079999999999em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"d"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"d"))))))))))))),", which defines the covariance between the\nvalues at any pair of points ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"x"),(0,r.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x, x'")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.946332em",verticalAlign:"-0.19444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.751892em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032")))))))))))))," of the domain. Since we are modelling deformation\nfields (I.e. vector-valued functions), the covariance function is matrix-valued."),(0,r.kt)("p",null,"To define a kernel in Scalismo, we need to implement the following methods of the abstract class ",(0,r.kt)("inlineCode",{parentName:"p"},"MatrixValuedPDKernel"),", which is defined in Scalismo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"abstract class MatrixValuedPDKernel[D]() {\n\n    def outputDim: Int;\n    def domain: Domain[D];\n    def k(x: Point[D], y: Point[D]): DenseMatrix[Double];\n  }\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: This class is already defined as part of Scalismo. Don't paste it into your code.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"outputDim")," field sets the dimensionality of the values we model.\nAs we model 3D vectors, ",(0,r.kt)("inlineCode",{parentName:"p"},"outputDim")," should be 3.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"domain")," indicates the points where our kernel is defined,\noften set to the entire Euclidean space RealSpace3D.\nLastly, ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," denotes the covariance function."),(0,r.kt)("p",null,"A frequently used kernel is the Gaussian kernel. Here's how it's defined in Scalismo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  case class MatrixValuedGaussianKernel3D(sigma2 : Double) extends MatrixValuedPDKernel[_3D]():\n\n    override def outputDim: Int = 3\n    override def domain: Domain[_3D] = EuclideanSpace3D;\n\n    override def k(x: Point[_3D], y: Point[_3D]): DenseMatrix[Double] = \n      DenseMatrix.eye[Double](outputDim) * Math.exp(- (x - y).norm2 / sigma2)\n    \n  \n")),(0,r.kt)("p",null,"The most commonly used covariance-functions are readily available in Scalismo.\nMost are defined not as matrix-valued kernels, but as scalar-valued kernels.\nThe scalar valued kernels can then be turned in Matrix-valued kernels, using the\nclass ",(0,r.kt)("inlineCode",{parentName:"p"},"DiagonalKernel"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val scalarValuedGaussianKernel : PDKernel[_3D]= GaussianKernel3D(sigma = 100.0)\n  val matrixValuedGaussianKernel = DiagonalKernel3D(scalarValuedGaussianKernel, scalarValuedGaussianKernel, scalarValuedGaussianKernel)\n")),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"DiagonalKernel")," assumes, that every space dimension is independent.\nIn above example, where we used the same kernel in every space dimension, there is an even\nshorter way of wrting the same:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  DiagonalKernel3D(scalarValuedGaussianKernel, 3)\n")),(0,r.kt)("h5",{id:"building-the-gp-"},"Building the GP :"),(0,r.kt)("p",null,"Now that we defined the mean and covariance functions, we can build a Gaussian process as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val gp = GaussianProcess3D[EuclideanVector[_3D]](zeroMean, matrixValuedGaussianKernel)\n")),(0,r.kt)("p",null,"We now have the capability to generate deformations from our Gaussian process at any set of points we choose. In the following instance, we select the points of the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val sampleGroup = ui.createGroup("samples")\n  val sample = gp.sampleAtPoints(referenceMesh)\n  ui.show(sampleGroup, sample, "gaussianKernelGP_sample")\n')),(0,r.kt)("p",null,"The result is an instance from the Gaussian Process evaluated at the points\nwe indicated;  in this case on the points of the reference mesh."),(0,r.kt)("p",null,"We can visualize the result of this process by interpolating the deformation field and then applying it to deform the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val interpolatedSample = sample.interpolate(TriangleMeshInterpolator3D())\n  val deformedMesh = referenceMesh.transform((p : Point[_3D]) => p + interpolatedSample(p))\n  ui.show(sampleGroup, deformedMesh, "deformed mesh")\n')),(0,r.kt)("h4",{id:"low-rank-approximation"},"Low-rank approximation"),(0,r.kt)("p",null,"Whenever we create a sample using the ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleAtPoints")," method of the Gaussian process,\ninternally a matrix of dimensionality ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"d"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"d")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"nd \\times nd")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.77777em",verticalAlign:"-0.08333em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"))))),",where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," denotes the number of points and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"d")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"d")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d")))))," the dimensionality of the output space, is created. For a large number of points, we will quickly run out of memory."),(0,r.kt)("p",null,"We can get around this problem by computing a low-rank approximation of the Gaussian process.\nTo obtain such a representation we use the method ",(0,r.kt)("inlineCode",{parentName:"p"},"approximateGPCholesky")," of the ",(0,r.kt)("em",{parentName:"p"},"LowRankGaussianProcess")," object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(\n    referenceMesh,\n    gp,\n    relativeTolerance = 0.01,\n    interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\n  )\n")),(0,r.kt)("p",null,"This call computes a finite-rank approximation of the Gaussian Process using a\nPivoted Cholesky approximation. The procedure automatically chooses the rank (I.e. the\nnumber of basis functions of the Gaussian process), such that the given relative error\nis achieved. (The error is measures in terms of the variance of the Gaussian\nprocess, approximated on the points of the reference Mesh)."),(0,r.kt)("p",null,"Once we've established this low-rank Gaussian process, we are now equipped to directly sample continuous deformation fields. We can use this deformation field to warp the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val  defField : Field[_3D, EuclideanVector[_3D]]= lowRankGP.sample()\n  referenceMesh.transform((p : Point[_3D]) => p + defField(p))\n")),(0,r.kt)("p",null,"A more convenient way to sample meshes is, to build a Point Distribution Model from the\nlowrank Gaussian process. This allows us to directly sample meshes that following the\ndistribution represented by the Gaussian process."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val pdm = PointDistributionModel3D(referenceMesh, lowRankGP)\n  val sampleFromPdm : TriangleMesh[_3D] = pdm.sample()\n")),(0,r.kt)("p",null,"This model can also be visualized directly in ScalismoUI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val pdmView = ui.show(modelGroup, pdm, "group")\n')),(0,r.kt)("h3",{id:"building-more-interesting-kernels"},"Building more interesting kernels"),(0,r.kt)("p",null,"In the following we show a few more examples of kernels that are of interest in the shape modelling context."),(0,r.kt)("h4",{id:"kernels-from-statistical-shape-models"},"Kernels from Statistical Shape Models"),(0,r.kt)("p",null,"As discussed previously, a Point Distribution Model in Scalismo is a discrete Gaussian process.\nWe have seen how to interpolate it to obtain a continuously defined Gaussian Process. As any\nGaussian process is completely defined by its mean and covariance function, it follows that this is\nalso true for the GP that representes the PDM."),(0,r.kt)("p",null,"This allows us to use this ",(0,r.kt)("em",{parentName:"p"},"sample covariance kernel")," in combination with other kernels.\nFor example, we often want to slightly enlarge the flexibility of our statistical models.\nIn the following, we show how this can be achieved."),(0,r.kt)("p",null,"In a first step, we get the Gaussian process from the model an interpolate it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val pcaModel = StatisticalModelIO.readStatisticalTriangleMeshModel3D(File("datasets/lowresModel.h5")).get\n  val gpSSM = pcaModel.gp.interpolate(TriangleMeshInterpolator3D())\n')),(0,r.kt)("p",null,"We can then access its covariance function and add to it additional variance using a Gaussian kernel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val covSSM : MatrixValuedPDKernel[_3D] = gpSSM.cov\n  val augmentedCov = covSSM + DiagonalKernel(GaussianKernel[_3D](100.0), 3)  \n")),(0,r.kt)("p",null,"Finally, we build the Gaussian process with the new kernel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val augmentedGP = GaussianProcess(gpSSM.mean, augmentedCov)\n")),(0,r.kt)("p",null,"From here on, we follow the steps outlined above to obtain the ",(0,r.kt)("em",{parentName:"p"},"augmented")," SSM."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val lowRankAugmentedGP = LowRankGaussianProcess.approximateGPCholesky(\n    referenceMesh,\n    augmentedGP,\n    relativeTolerance = 0.01,\n    interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\n  )\n  val augmentedSSM = PointDistributionModel3D(pcaModel.reference, lowRankAugmentedGP)\n")),(0,r.kt)("h4",{id:"changepoint-kernel"},"Changepoint kernel:"),(0,r.kt)("p",null,"Another very useful kernel is the ",(0,r.kt)("em",{parentName:"p"},"changepoint kernel"),".\nA changepoint kernel is a combination of different kernels, where each kernel is active only in\na certain region of the space."),(0,r.kt)("p",null,"Here we show how we can define a kernel, which has different behavior in two different regions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  case class ChangePointKernel(kernel1 : MatrixValuedPDKernel[_3D], kernel2 : MatrixValuedPDKernel[_3D])\n    extends MatrixValuedPDKernel[_3D]():\n\n    override def domain = EuclideanSpace[_3D]\n    val outputDim = 3\n\n    def s(p: Point[_3D]) =  1.0 / (1.0 + math.exp(-p(0)))\n    def k(x: Point[_3D], y: Point[_3D]) = \n      val sx = s(x)\n      val sy = s(y)\n      kernel1(x,y) * sx * sy + kernel2(x,y) * (1-sx) * (1-sy)\n    \n  \n")),(0,r.kt)("p",null,"Let's visualize its effect with two different Gaussian Kernels"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val gk1 = DiagonalKernel3D(GaussianKernel3D(100.0), 3)\n  val gk2 = DiagonalKernel3D(GaussianKernel3D(10.0), 3)\n  val changePointKernel = ChangePointKernel(gk1, gk2)\n  val gpCP = GaussianProcess3D(zeroMean, changePointKernel)\n  val sampleCP =  gpCP.sampleAtPoints(referenceMesh)\n  ui.show(sampleGroup, sampleCP, "ChangePointKernelGP_sample")\n')),(0,r.kt)("p",null,"As you can see each kernel is now active only on one half of the face."),(0,r.kt)("h4",{id:"symmetrizing-a-kernel"},"Symmetrizing a kernel"),(0,r.kt)("p",null,"Quite often, the shapes that we aim to model exhibit a symmetry. This is particularly valid in the case of faces. It turns out that we can symmetrize deformations for any given covariance function using the following formula below:"),(0,r.kt)("img",{src:" data:image/png;base64,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"}),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"x",(0,r.kt)("sub",null,"m"))," is the symmetric point to ",(0,r.kt)("em",{parentName:"p"},"x")," around the YZ plane."),(0,r.kt)("p",null,"The resulting kernel will preserve the same smoothness properties of the deformation fields while adding the symmetry around the YZ plane."),(0,r.kt)("p",null,"Let's turn it into code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  case class xMirroredKernel(kernel : PDKernel[_3D]) extends PDKernel[_3D]:\n    override def domain = kernel.domain\n    override def k(x: Point[_3D], y: Point[_3D]) = kernel(Point(x(0) * -1.0 ,x(1), x(2)), y)\n\n\n  def symmetrizeKernel(kernel : PDKernel[_3D]) : MatrixValuedPDKernel[_3D] = \n    val xmirrored = xMirroredKernel(kernel)\n    val k1 = DiagonalKernel(kernel, 3)\n    val k2 = DiagonalKernel(xmirrored * -1f, xmirrored, xmirrored)\n    k1 + k2\n  \n\n  val symmetrizedGaussian = symmetrizeKernel(GaussianKernel[_3D](100))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val gpSym = GaussianProcess3D(zeroMean, symmetrizedGaussian)\n  val sampleGpSym =  gpSym.sampleAtPoints(referenceMesh)\n\n  ui.show(sampleGroup, sampleGpSym, "ChangePointKernelGP_sample")\n')))}u.isMDXComponent=!0},8209:function(e,a,n){a.Z=n.p+"assets/files/Tutorial07-5b81c5a703d4ceaf424e80804d323ce4.scala"}}]);