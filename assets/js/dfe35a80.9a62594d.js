"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9865],{3905:function(e,a,t){t.d(a,{Zo:function(){return p},kt:function(){return h}});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function m(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=n.createContext({}),l=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},p=function(e){var a=l(e.components);return n.createElement(i.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),d=l(t),h=s,u=d["".concat(i,".").concat(h)]||d[h]||c[h]||r;return t?n.createElement(u,o(o({ref:a},p),{},{components:t})):n.createElement(u,o({ref:a},p))}));function h(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=d;var m={};for(var i in a)hasOwnProperty.call(a,i)&&(m[i]=a[i]);m.originalType=e,m.mdxType="string"==typeof e?e:s,o[1]=m;for(var l=2;l<r;l++)o[l]=t[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},815:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return m},contentTitle:function(){return i},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var n=t(7462),s=t(3366),r=(t(7294),t(3905)),o=["components"],m={id:"tutorial15",title:"Model fitting using MCMC - Fitting a shape model"},i=void 0,l={unversionedId:"Tutorials/tutorial15",id:"Tutorials/tutorial15",title:"Model fitting using MCMC - Fitting a shape model",description:"In this tutorial we show how the MCMC framework, which was introduced in the previous",source:"@site/docs/Tutorials/tutorial15.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial15",permalink:"/docs/Tutorials/tutorial15",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial15.md",tags:[],version:"current",frontMatter:{id:"tutorial15",title:"Model fitting using MCMC - Fitting a shape model"},sidebar:"docs",previous:{title:"Model fitting using MCMC - The basic framework",permalink:"/docs/Tutorials/tutorial14"},next:{title:"Introduction to Scalismo-ui",permalink:"/docs/scalismo-ui-introduction"}},p=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Loading and visualizing the data",id:"loading-and-visualizing-the-data",children:[],level:3},{value:"The parameter class",id:"the-parameter-class",children:[],level:3},{value:"Evaluators: Modelling the target density",id:"evaluators-modelling-the-target-density",children:[{value:"Performance improvements",id:"performance-improvements",children:[],level:5},{value:"The posterior evaluator",id:"the-posterior-evaluator",children:[],level:4}],level:3},{value:"The proposal generator",id:"the-proposal-generator",children:[{value:"Building the Markov Chain",id:"building-the-markov-chain",children:[],level:4}],level:3},{value:"Analyzing the results",id:"analyzing-the-results",children:[],level:3},{value:"Beyond landmark fitting",id:"beyond-landmark-fitting",children:[],level:3}],c={toc:p};function d(e){var a=e.components,m=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},c,m,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial we show how the MCMC framework, which was introduced in the previous\ntutorial, can be used for shape model fitting."),(0,r.kt)("p",null,"We will illustrate it by computing a posterior of a shape model,\ngiven a set of corresponding landmark pairs. This is the same setup that we have\ndiscussed in the tutorial about Gaussian process regression. The difference is,\nthat here we will also allow for rotation and translation of the model. In this setting,\nit is not possible anymore to compute the posterior analytically. Rather, our only hope are approximation methods, such as\nusing Markov-chain monte carlo methods."),(0,r.kt)("p",null,"In this tutorial we show not only a working example, but also how to make it\ncomputationally efficient. Making the individual parts as efficient as possible is\nimportant in sampling approaches, as we need to produce many samples to get accurate\nestimates."),(0,r.kt)("h5",{id:"related-resources"},"Related resources"),(0,r.kt)("p",null,"Week 3 of our ",(0,r.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/probabilistic-fitting-course/"},"online course")," on shape model fitting may provide some helpful context for this tutorial."),(0,r.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:t(3859).Z},"Tutorial15.scala"))),(0,r.kt)("h5",{id:"preparation"},"Preparation"),(0,r.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and\ninitializing the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.common.{PointId, UnstructuredPointsDomain}\nimport scalismo.geometry._\nimport scalismo.io.{LandmarkIO, MeshIO, StatisticalModelIO}\nimport scalismo.mesh.TriangleMesh\nimport scalismo.sampling.algorithms.MetropolisHastings\nimport scalismo.sampling.evaluators.ProductEvaluator\nimport scalismo.sampling.proposals.MixtureProposal\nimport scalismo.sampling.loggers.AcceptRejectLogger\nimport scalismo.sampling.{DistributionEvaluator, ProposalGenerator, TransitionProbability}\nimport scalismo.statisticalmodel.{MultivariateNormalDistribution, PointDistributionModel, PointDistributionModel3D}\nimport scalismo.transformations.{\n  RigidTransformation,\n  Rotation3D,\n  Translation3D,\n  TranslationAfterRotation,\n  TranslationAfterRotation3D\n}\n\nimport scalismo.utils.Memoize\n\nimport scalismo.ui.api.ScalismoUI\nimport breeze.linalg.{DenseMatrix, DenseVector}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"implicit val rng = scalismo.utils.Random(42)\nscalismo.initialize()\n\nval ui = ScalismoUI()\n")),(0,r.kt)("h3",{id:"loading-and-visualizing-the-data"},"Loading and visualizing the data"),(0,r.kt)("p",null,"In a first step, we load and visualize all the data that we need.\nFirst, we load the statistical model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File("datasets/bfm.h5")).get\n\nval modelGroup = ui.createGroup("model")\nval modelView = ui.show(modelGroup, model, "model")\nmodelView.referenceView.opacity = 0.5\n')),(0,r.kt)("p",null,"In this example, we will fit the model such that a set of model landmarks, coincide\nwith a set of landmark points defined on a target face. We load and visualize the corresponding landmark data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val modelLms = LandmarkIO.readLandmarksJson[_3D](new java.io.File("datasets/modelLM_mcmc.json")).get\nval modelLmViews = ui.show(modelGroup, modelLms, "modelLandmarks")\nmodelLmViews.foreach(lmView => lmView.color = java.awt.Color.BLUE)\n\nval targetGroup = ui.createGroup("target")\n\nval targetLms = LandmarkIO.readLandmarksJson3D(new java.io.File("datasets/targetLM_mcmc.json")).get\nval targetLmViews = ui.show(targetGroup, targetLms, "targetLandmarks")\nmodelLmViews.foreach(lmView => lmView.color = java.awt.Color.RED)\n')),(0,r.kt)("p",null,"In the following, we will refer to the points on the model using their point id, while the target\nposition is represented as physical points. The reason why we use the point id for the model is that the model instances,\nand therefore the points, which are represented by the point id, are changing as we fit the model."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val modelLmIds = modelLms.map(l => model.mean.pointSet.pointId(l.point).get)\nval targetPoints = targetLms.map(l => l.point)\n")),(0,r.kt)("p",null,"We summarize the correspondences as a tuple, consisting of model id and target position."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val correspondences = modelLmIds\n    .zip(targetPoints)\n    .map(modelIdWithTargetPoint => {\n      val (modelId, targetPoint) = modelIdWithTargetPoint\n      (modelId, targetPoint)\n    })\n")),(0,r.kt)("h3",{id:"the-parameter-class"},"The parameter class"),(0,r.kt)("p",null,"In this example, we want to model the posterior ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where\nthe parameters ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"t"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"r"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03b1"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\theta =( t, r, \\alpha)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," consist of the translation parameters\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"t"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"x")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"y")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"z")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t=(t_x, t_y, t_z)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.61508em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.036108em",verticalAlign:"-0.286108em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"x")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15139200000000003em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03588em"}},"y")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.286108em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.04398em"}},"z")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", the rotation parameters ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"r"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03d5"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03c8"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03c9"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"r = (\\phi, \\psi, \\omega)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03d5"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c8"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c9"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),",\nrepresented as Euler angles as well a shape model coefficients ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b1"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"\u03b1"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mo",{parentName:"mrow"},"\u2026"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"\u03b1"),(0,r.kt)("mi",{parentName:"msub"},"n")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\alpha = (\\alpha_1, \\ldots, \\alpha_n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.30110799999999993em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"-0.0037em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"minner"},"\u2026"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"-0.0037em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"n")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),".\nFurthermore, we also model the noise as a parameter. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Parameters(translationParameters: EuclideanVector[_3D],\n                      rotationParameters: (Double, Double, Double),\n                      modelCoefficients: DenseVector[Double],\n                      noiseStddev : Double\n                     )\n")),(0,r.kt)("p",null,"As in the previous tutorial, we wrap this into a class representing the sample, which can keep track by whom it was generated. Furthermore, we will add convenience method,\nwhich builds a ",(0,r.kt)("inlineCode",{parentName:"p"},"RigidTransformation")," from the parameters. As a rigid transformation\nis not completely determined by the translation and rotation parameters, we need to\nstore also the center of rotation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Sample(generatedBy: String, parameters: Parameters, rotationCenter: Point[_3D]) {\n  def poseTransformation: TranslationAfterRotation[_3D] = {\n    val translation = Translation3D(parameters.translationParameters)\n    val rotation = Rotation3D(\n      parameters.rotationParameters._1,\n      parameters.rotationParameters._2,\n      parameters.rotationParameters._3,\n      rotationCenter\n    )\n    TranslationAfterRotation3D(translation, rotation)\n  }\n}\n")),(0,r.kt)("h3",{id:"evaluators-modelling-the-target-density"},"Evaluators: Modelling the target density"),(0,r.kt)("p",null,"As in the previous tutorial, we represent the unnormalized posterior distribution\nas the product of prior and likelihood:\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"\u221d"),(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D) \\propto p(\\theta) p(D | \\theta)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u221d"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),",\nwhere ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"D")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"D")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D")))))," denotes the data (i.e. the corresponding landmark points) and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b8")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\theta")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"))))),"\nare our parameters."),(0,r.kt)("p",null,"As a prior over the shape parameters is given by the shape model. For the\ntranslation and rotation, we assume a zero-mean normal distribution. As the standard deviation\ncharacterizing the noise needs to be positive, we use a lognormal distribution.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class PriorEvaluator(model: PointDistributionModel[_3D, TriangleMesh]) extends DistributionEvaluator[Sample] {\n\n  val translationPrior = breeze.stats.distributions.Gaussian(0.0, 5.0)\n  val rotationPrior = breeze.stats.distributions.Gaussian(0, 0.1)\n  val noisePrior = breeze.stats.distributions.LogNormal(0, 0.25)\n\n  override def logValue(sample: Sample): Double = {\n    model.gp.logpdf(sample.parameters.modelCoefficients) +\n      translationPrior.logPdf(sample.parameters.translationParameters.x) +\n      translationPrior.logPdf(sample.parameters.translationParameters.y) +\n      translationPrior.logPdf(sample.parameters.translationParameters.z) +\n      rotationPrior.logPdf(sample.parameters.rotationParameters._1) +\n      rotationPrior.logPdf(sample.parameters.rotationParameters._2) +\n      rotationPrior.logPdf(sample.parameters.rotationParameters._3) +\n      noisePrior.logPdf(sample.parameters.noiseStddev)\n  }\n}\n")),(0,r.kt)("p",null,"To compute the likelihood ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(D | \\theta)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," we first compute\nthe current model instance as determined by the shape and pose parameters.\nFrom this model instance, the points at the given points id are extracted and\nthe distance to their target position is computed. This distance is what was\nmodelled by the uncertainty of the observations. We can therefore directly use\nthe modelled uncertainty to compute the likelihood of our model given the data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:silent emptyLines:2","mdoc:silent":!0,"emptyLines:2":!0},"case class SimpleCorrespondenceEvaluator(model: PointDistributionModel[_3D, TriangleMesh],\n                                         correspondences: Seq[(PointId, Point[_3D])])\n    extends DistributionEvaluator[Sample] {\n\n  override def logValue(sample: Sample): Double = {\n\n    val currModelInstance = model.instance(sample.parameters.modelCoefficients).transform(sample.poseTransformation)\n    \n    val lmUncertainty = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev)\n\n\n    val likelihoods = correspondences.map(correspondence => {\n      val (id, targetPoint) = correspondence\n      val modelInstancePoint = currModelInstance.pointSet.point(id)\n      val observedDeformation = targetPoint - modelInstancePoint\n\n      lmUncertainty.logpdf(observedDeformation.toBreezeVector)\n    })\n\n    val loglikelihood = likelihoods.sum\n    loglikelihood\n  }\n}\n")),(0,r.kt)("p",null,"Conceptually, this is all that needed to be done to specify the target distribution.\nIn practice, we are interested to make these evaluators as efficient as possible,\nas they are usually called thousands of times."),(0,r.kt)("h5",{id:"performance-improvements"},"Performance improvements"),(0,r.kt)("p",null,"In the above implementation, we compute a full model instance (the new position of all the mesh points\nrepresented by the shape model), although we are only interested in the position of the landmark points.\nThis is rather inefficient. A more efficient version would first marginalize the model to the\npoints of interest. Since marginalization changes the point ids, we need to map the\nids given as",(0,r.kt)("inlineCode",{parentName:"p"},"correspondences")," to their new ids. This is achieved by the following helper function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def marginalizeModelForCorrespondences(model: PointDistributionModel[_3D, TriangleMesh],\n                                        correspondences: Seq[(PointId, Point[_3D])])\n: (PointDistributionModel[_3D, UnstructuredPointsDomain],\n  Seq[(PointId, Point[_3D])]) = {\n\n  val (modelIds, _) = correspondences.unzip\n  val marginalizedModel = model.marginal(modelIds.toIndexedSeq)\n  val newCorrespondences = correspondences.map(idWithTargetPoint => {\n    val (id, targetPoint) = idWithTargetPoint\n    val modelPoint = model.reference.pointSet.point(id)\n    val newId = marginalizedModel.reference.pointSet.findClosestPoint(modelPoint).id\n    (newId, targetPoint)\n  })\n  (marginalizedModel, newCorrespondences)\n}\n")),(0,r.kt)("p",null,"The more efficient version of the evaluator uses now the marginalized model to evaluate the likelihood:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class CorrespondenceEvaluator(model: PointDistributionModel[_3D, TriangleMesh],\n                                   correspondences: Seq[(PointId, Point[_3D])])\n  extends DistributionEvaluator[Sample] {\n\n  val (marginalizedModel, newCorrespondences) = marginalizeModelForCorrespondences(model, correspondences)\n\n  override def logValue(sample: Sample): Double = {\n\n    val lmUncertainty = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev)\n\n    val currModelInstance = marginalizedModel\n      .instance(sample.parameters.modelCoefficients)\n      .transform(sample.poseTransformation)\n\n    val likelihoods = newCorrespondences.map(correspondence => {\n      val (id, targetPoint) = correspondence\n      val modelInstancePoint = currModelInstance.pointSet.point(id)\n      val observedDeformation = targetPoint - modelInstancePoint\n\n      lmUncertainty.logpdf(observedDeformation.toBreezeVector)\n    })\n\n    val loglikelihood = likelihoods.sum\n    loglikelihood\n  }\n}\n")),(0,r.kt)("p",null,"In order for the Metropolis-Hastings algorithm to decide if a new sample is accepted,\nthe likelihood needs to be computed several times for each set of parameters. To further\nincrease the efficiency, we should therefore cache the computations, such that when\nan evaluator is used the second time with the same parameters, the ",(0,r.kt)("inlineCode",{parentName:"p"},"logValue")," is\nnot recomputed, but simply taken from cache. Using the following utility class,\nwe can obtain for any evaluator a new evaluator, which performs such caching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class CachedEvaluator[A](evaluator: DistributionEvaluator[A]) extends DistributionEvaluator[A] {\n  val memoizedLogValue = Memoize(evaluator.logValue, 10)\n\n  override def logValue(sample: A): Double = {\n    memoizedLogValue(sample)\n  }\n}\n")),(0,r.kt)("h4",{id:"the-posterior-evaluator"},"The posterior evaluator"),(0,r.kt)("p",null,"Given these evaluators, we can now build the computationally efficient version of\nour target density ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val likelihoodEvaluator = CachedEvaluator(CorrespondenceEvaluator(model, correspondences))\nval priorEvaluator = CachedEvaluator(PriorEvaluator(model))\n\nval posteriorEvaluator = ProductEvaluator(priorEvaluator, likelihoodEvaluator)\n")),(0,r.kt)("h3",{id:"the-proposal-generator"},"The proposal generator"),(0,r.kt)("p",null,"As in the previous tutorials, we will use simple random walk proposals.\nWe will define separate proposals for shape, translation and rotation.\nOn one hand, this lets us set the step length (i.e. stddev of the distribution from which we\nsample the next step) individually for each group, and thus to incorporate our knowledge\nthat changes in rotation will be much smaller than the shape changes. On the other hand,\nsplitting the parameter updates in blocks will increase our chance for the random updates\nto be accepted. The reason for this is that when many parameters are updated at one,\nchances are high that some of the proposed changes make the new state more unlikely,\nand hence increase the chance of the new state being rejected."),(0,r.kt)("p",null,"The definition of the proposals are straight-forward."),(0,r.kt)("p",null,"We start with the shape update proposal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class ShapeUpdateProposal(paramVectorSize: Int, stddev: Double)\n    extends ProposalGenerator[Sample]\n    with TransitionProbability[Sample] {\n\n  val perturbationDistr = new MultivariateNormalDistribution(\n    DenseVector.zeros(paramVectorSize),\n    DenseMatrix.eye[Double](paramVectorSize) * stddev * stddev\n  )\n\n  override def propose(sample: Sample): Sample = {\n    val perturbation = perturbationDistr.sample()\n    val newParameters =\n      sample.parameters.copy(modelCoefficients = sample.parameters.modelCoefficients + perturbationDistr.sample)\n    sample.copy(generatedBy = s"ShapeUpdateProposal ($stddev)", parameters = newParameters)\n  }\n\n  override def logTransitionProbability(from: Sample, to: Sample) = {\n    val residual = to.parameters.modelCoefficients - from.parameters.modelCoefficients\n    perturbationDistr.logpdf(residual)\n  }\n}\n')),(0,r.kt)("p",null,"The update of the roation parameters is very similar. Note that we only update the\nrotation parameters, but keep the center of rotation unchanged."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class RotationUpdateProposal(stddev: Double)\n    extends ProposalGenerator[Sample]\n    with TransitionProbability[Sample] {\n  val perturbationDistr =\n    new MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * stddev * stddev)\n  def propose(sample: Sample): Sample = {\n    val perturbation = perturbationDistr.sample\n    val newRotationParameters = (\n      sample.parameters.rotationParameters._1 + perturbation(0),\n      sample.parameters.rotationParameters._2 + perturbation(1),\n      sample.parameters.rotationParameters._3 + perturbation(2)\n    )\n    val newParameters = sample.parameters.copy(rotationParameters = newRotationParameters)\n    sample.copy(generatedBy = s"RotationUpdateProposal ($stddev)", parameters = newParameters)\n  }\n  override def logTransitionProbability(from: Sample, to: Sample) = {\n    val residual = DenseVector(\n      to.parameters.rotationParameters._1 - from.parameters.rotationParameters._1,\n      to.parameters.rotationParameters._2 - from.parameters.rotationParameters._2,\n      to.parameters.rotationParameters._3 - from.parameters.rotationParameters._3\n    )\n    perturbationDistr.logpdf(residual)\n  }\n}\n')),(0,r.kt)("p",null,"We define a similar proposal for the translation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class TranslationUpdateProposal(stddev: Double)\n    extends ProposalGenerator[Sample]\n    with TransitionProbability[Sample] {\n\n  val perturbationDistr =\n    new MultivariateNormalDistribution(DenseVector.zeros(3), DenseMatrix.eye[Double](3) * stddev * stddev)\n\n  def propose(sample: Sample): Sample = {\n    val newTranslationParameters = sample.parameters.translationParameters + EuclideanVector.fromBreezeVector(\n      perturbationDistr.sample()\n    )\n    val newParameters = sample.parameters.copy(translationParameters = newTranslationParameters)\n    sample.copy(generatedBy = s"TranlationUpdateProposal ($stddev)", parameters = newParameters)\n  }\n\n  override def logTransitionProbability(from: Sample, to: Sample) = {\n    val residual = to.parameters.translationParameters - from.parameters.translationParameters\n    perturbationDistr.logpdf(residual.toBreezeVector)\n  }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class NoiseStddevUpdateProposal(stddev: Double)(implicit rng : scalismo.utils.Random)\n  extends ProposalGenerator[Sample]\n    with TransitionProbability[Sample] {\n\n  val perturbationDistr = breeze.stats.distributions.Gaussian(0, stddev)(rng.breezeRandBasis)\n\n  def propose(sample: Sample): Sample = {\n    val newSigma = sample.parameters.noiseStddev +  perturbationDistr.sample()\n    val newParameters = sample.parameters.copy(noiseStddev = newSigma)\n    sample.copy(generatedBy = s"NoiseStddevUpdateProposal ($stddev)", parameters = newParameters)\n  }\n\n  override def logTransitionProbability(from: Sample, to: Sample) = {\n    val residual = to.parameters.noiseStddev - from.parameters.noiseStddev\n    perturbationDistr.logPdf(residual)\n  }\n}\n')),(0,r.kt)("p",null,"The final proposal is a mixture of the  proposals we defined above.\nWe choose to update the shape more often than the translation and rotation parameters,\nas we expect most changes to be shape changes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val shapeUpdateProposal = ShapeUpdateProposal(model.rank, 0.1)\nval rotationUpdateProposal = RotationUpdateProposal(0.01)\nval translationUpdateProposal = TranslationUpdateProposal(1.0)\nval noiseStddevUpdateProposal = NoiseStddevUpdateProposal(0.1)\n\nval generator = MixtureProposal.fromProposalsWithTransition(\n  (0.5, shapeUpdateProposal),\n  (0.2, rotationUpdateProposal),\n  (0.2, translationUpdateProposal),\n  (0.1, noiseStddevUpdateProposal)\n)\n")),(0,r.kt)("h4",{id:"building-the-markov-chain"},"Building the Markov Chain"),(0,r.kt)("p",null,"For running the Markov Chain, we proceed exactly as in the previous tutorial. We start by defining the logger,\nto compute the accept/reject ratios of the individual generators"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class Logger extends AcceptRejectLogger[Sample] {\n  private val numAccepted = collection.mutable.Map[String, Int]()\n  private val numRejected = collection.mutable.Map[String, Int]()\n\n  override def accept(current: Sample,\n                      sample: Sample,\n                      generator: ProposalGenerator[Sample],\n                      evaluator: DistributionEvaluator[Sample]): Unit = {\n    val numAcceptedSoFar = numAccepted.getOrElseUpdate(sample.generatedBy, 0)\n    numAccepted.update(sample.generatedBy, numAcceptedSoFar + 1)\n  }\n\n  override def reject(current: Sample,\n                      sample: Sample,\n                      generator: ProposalGenerator[Sample],\n                      evaluator: DistributionEvaluator[Sample]): Unit = {\n    val numRejectedSoFar = numRejected.getOrElseUpdate(sample.generatedBy, 0)\n    numRejected.update(sample.generatedBy, numRejectedSoFar + 1)\n  }\n\n  def acceptanceRatios(): Map[String, Double] = {\n    val generatorNames = numRejected.keys.toSet.union(numAccepted.keys.toSet)\n    val acceptanceRatios = for (generatorName <- generatorNames) yield {\n      val total = (numAccepted.getOrElse(generatorName, 0)\n        + numRejected.getOrElse(generatorName, 0)).toDouble\n      (generatorName, numAccepted.getOrElse(generatorName, 0) / total)\n    }\n    acceptanceRatios.toMap\n  }\n}\n")),(0,r.kt)("p",null,"We then create the initial sample, where we choose here the center of mass of the model mean as the\nrotation center."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def computeCenterOfMass(mesh: TriangleMesh[_3D]): Point[_3D] = {\n  val normFactor = 1.0 / mesh.pointSet.numberOfPoints\n  mesh.pointSet.points.foldLeft(Point(0, 0, 0))((sum, point) => sum + point.toVector * normFactor)\n}\n\nval initialParameters = Parameters(\n  translationParameters = EuclideanVector(0, 0, 0),\n  rotationParameters = (0.0, 0.0, 0.0),\n  modelCoefficients = DenseVector.zeros[Double](model.rank),\n  noiseStddev = 1.0\n)\n\nval initialSample = Sample("initial", initialParameters, computeCenterOfMass(model.mean))\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Remark: Setting the rotation center correctly is very important for the rotation proposal to work as expected.\nFortunately, most of the time this error is easy to diagnose, as the acceptance ratio of the rotation proposal will be unexpectedly low.")),(0,r.kt)("p",null,"Next we set up the chain and obtain an iterator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val chain = MetropolisHastings(generator, posteriorEvaluator)\nval logger = new Logger()\nval mhIterator = chain.iterator(initialSample, logger)\n")),(0,r.kt)("p",null,"In this example we are interested to visualize some samples from the posterior as we run the chain. This can be done\nby augmenting the iterator with visualization code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val samplingIterator = for ((sample, iteration) <- mhIterator.zipWithIndex) yield {\n    println("iteration " + iteration)\n    if (iteration % 500 == 0) {\n      modelView.shapeModelTransformationView.shapeTransformationView.coefficients = sample.parameters.modelCoefficients\n      modelView.shapeModelTransformationView.poseTransformationView.transformation = sample.poseTransformation\n    }\n    sample\n}\n')),(0,r.kt)("p",null,"Finally, we draw the samples using the chain by consuming the iterator. We drop the first 1000 iterations, as the\nchain needs some burn-in time to converge to a equilibrium solution:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val samples = samplingIterator.drop(1000).take(10000).toIndexedSeq\n")),(0,r.kt)("p",null,"Before working with the results, we check the acceptance ratios to verify that all the proposals work as expected:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"println(logger.acceptanceRatios())\n")),(0,r.kt)("h3",{id:"analyzing-the-results"},"Analyzing the results"),(0,r.kt)("p",null,"Once we have the samples, we can now use them to analyze our fit.\nFor example, we can select the best fit from these samples and visualize it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val bestSample = samples.maxBy(posteriorEvaluator.logValue)\nval bestFit = model.instance(bestSample.parameters.modelCoefficients).transform(bestSample.poseTransformation)\nval resultGroup = ui.createGroup("result")\nui.show(resultGroup, bestFit, "best fit")\n')),(0,r.kt)("p",null,"The samples allow us to infer much more about the distribution. For example, we can estimate the expected position of\nany point in the model and the variance from the samples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\ndef computeMean(model: PointDistributionModel[_3D, UnstructuredPointsDomain], id: PointId): Point[_3D] = {\n  var mean = EuclideanVector(0, 0, 0)\n  for (sample <- samples) yield {\n    val modelInstance = model.instance(sample.parameters.modelCoefficients)\n    val pointForInstance = modelInstance.transform(sample.poseTransformation).pointSet.point(id)\n    mean += pointForInstance.toVector\n  }\n  (mean * 1.0 / samples.size).toPoint\n}\n\ndef computeCovarianceFromSamples(model: PointDistributionModel[_3D, UnstructuredPointsDomain],\n                                 id: PointId,\n                                 mean: Point[_3D]): SquareMatrix[_3D] = {\n  var cov = SquareMatrix.zeros[_3D]\n  for (sample <- samples) yield {\n    val modelInstance = model.instance(sample.parameters.modelCoefficients)\n    val pointForInstance = modelInstance.transform(sample.poseTransformation).pointSet.point(id)\n    val v = pointForInstance - mean\n    cov += v.outer(v)\n  }\n  cov * (1.0 / samples.size)\n}\n")),(0,r.kt)("p",null,"For efficiency reasons, we do the computations here only for the landmark points, using again the marginalized model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val (marginalizedModel, newCorrespondences) = marginalizeModelForCorrespondences(model, correspondences)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'for ((id, _) <- newCorrespondences) {\n  val meanPointPosition = computeMean(marginalizedModel, id)\n  println(s"expected position for point at id $id  = $meanPointPosition")\n  val cov = computeCovarianceFromSamples(marginalizedModel, id, meanPointPosition)\n  println(\n    s"posterior variance computed  for point at id (shape and pose) $id  = ${cov(0, 0)}, ${cov(1, 1)}, ${cov(2, 2)}"\n  )\n}\n')),(0,r.kt)("h3",{id:"beyond-landmark-fitting"},"Beyond landmark fitting"),(0,r.kt)("p",null,"We have shown above how Scalismo can be used to perform Bayesian model fitting on the example of fitting 3D landmarks. This example\ncan easily be extended to other fitting tasks, such as fitting the model to points with unkown correspondences, fitting shapes in surfaces\nof fitting a model to an image using an Active Shape Model as a likelihood function. In principle, all that is required is to\nchange the likelihood function and rerun the fit.\nIn practice, however, as a change in the likelihood function can dramatically change the posterior density, it is often required\nto tune the proposals, such that good convergence can be achieved. Indeed, finding good proposal distributions is the key to\napplying this method successfully. The more prior knowledge about the target distribution we can incorporate into the proposals,\nthe faster will the chain converge to the equilibrium distribution."),(0,r.kt)("p",null,"For more complicated use-cases of this method in image analysis , we refer the interested reader is referred to the paper by S. Sch\xf6nborn et al.\nand references therein:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Sch\xf6nborn, Sandro, et al. "Markov chain monte carlo for automated face image analysis." International Journal of Computer Vision 123.2 (2017): 160-183.')))}d.isMDXComponent=!0},3859:function(e,a,t){a.Z=t.p+"assets/files/Tutorial15-69639aa91b665aea3d1476a990096960.scala"}}]);