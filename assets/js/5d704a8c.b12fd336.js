"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2210],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9620:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={id:"tutorial05",title:"Gaussian processes, sampling and marginalization"},l=void 0,c={unversionedId:"Tutorials/tutorial05",id:"version-0.92/Tutorials/tutorial05",title:"Gaussian processes, sampling and marginalization",description:"In this tutorial, we will delve deeper into how Gaussian processes are represented in Scalismo,",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial05.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial05",permalink:"/docs/Tutorials/tutorial05",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial05.md",tags:[],version:"0.92",frontMatter:{id:"tutorial05",title:"Gaussian processes, sampling and marginalization"},sidebar:"docs",previous:{title:"Gaussian processes and Point Distribution Models",permalink:"/docs/Tutorials/tutorial04"},next:{title:"Building a shape model from data",permalink:"/docs/Tutorials/tutorial06"}},u=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Discrete and Continuous Gaussian processes",id:"discrete-and-continuous-gaussian-processes",children:[],level:4},{value:"From continuous to discrete: marginalization and discretization",id:"from-continuous-to-discrete-marginalization-and-discretization",children:[],level:2},{value:"Changing the reference of a point distribution model",id:"changing-the-reference-of-a-point-distribution-model",children:[],level:2},{value:"Probability of shapes and deformations:",id:"probability-of-shapes-and-deformations",children:[],level:2}],p={toc:u};function d(e){var t=e.components,s=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this tutorial, we will delve deeper into how Gaussian processes are represented in Scalismo,\nfocusing on the conversion between continuous and discrete representations of the deformation fields."),(0,o.kt)("h5",{id:"related-resources"},"Related resources"),(0,o.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,o.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The marginalization property ",(0,o.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250339"},"(Video)")),(0,o.kt)("li",{parentName:"ul"},"Sampling from a shape model ",(0,o.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250340"},"(Article)"))),(0,o.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{target:"_blank",href:n(3335).Z},"Tutorial05.scala"))),(0,o.kt)("h5",{id:"preparation"},"Preparation"),(0,o.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.ui.api.*\nimport scalismo.geometry.*\nimport scalismo.common.*\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.mesh.*\nimport scalismo.io.StatisticalModelIO\nimport scalismo.statisticalmodel.*\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    scalismo.initialize()\n\n    val ui = ScalismoUI()\n")),(0,o.kt)("h4",{id:"discrete-and-continuous-gaussian-processes"},"Discrete and Continuous Gaussian processes"),(0,o.kt)("p",null,"In the previous tutorial, we saw that a Point Distribution Model (PDM) in Scalismo is\nrepresented as a discrete Gaussian process defined over deformation fields on a reference mesh."),(0,o.kt)("p",null,"To delve further into our exploration of Gaussian processes, let's start by loading and visualizing an existing PDM, and then extracting its underlying Gaussian process:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'    val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File("datasets/bfm.h5")).get\n    val modelGroup = ui.createGroup("modelGroup")\n    val ssmView = ui.show(modelGroup, model, "model")\n\n    val gp = model.gp\n')),(0,o.kt)("p",null,"We can generate random samples from the Gaussian process by invoking the sample method on the gp object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'    val sampleDF : DiscreteField[_3D, TriangleMesh, EuclideanVector[_3D]] = model.gp.sample()\n\n    val sampleGroup = ui.createGroup("sample")\n    ui.show(sampleGroup, sampleDF, "discreteSample")\n')),(0,o.kt)("p",null,"Observe that the sampled vector field is discrete, meaning it is defined over a finite set of points.\nThis is always the case when we load a shape model, as we cannot store infinitely many points. "),(0,o.kt)("p",null,"As shown in the previous tutorial, we could interpolate the sample sampleDF to obtain a continuous version of the deformation field.\nHowever, a more straightforward approach is to interpolate the Gaussian process directly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val contGP = model.gp.interpolate(TriangleMeshInterpolator3D())\n")),(0,o.kt)("p",null,"Now, when we sample from the continuous GP, we receive a vector-valued function, which is defined over the entire 3D space:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val contSample: Field[_3D, EuclideanVector[_3D]] = contGP.sample()\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Attention: While the interpolated Gaussian process is now defined on the entire 3D Space, the interpolation really only makes sense close to the mesh surface"),"."),(0,o.kt)("h2",{id:"from-continuous-to-discrete-marginalization-and-discretization"},"From continuous to discrete: marginalization and discretization"),(0,o.kt)("p",null,"In real-world applications, we seldom work directly with a continuous Gaussian process. Our interest usually lies in the distribution on a finite set of points.\nThe key advantage of having a continuous Gaussian process is our ability to extract samples at ",(0,o.kt)("em",{parentName:"p"},"any")," finite set of points,\nthereby tailoring the discretization according to our application requirements."),(0,o.kt)("p",null,"This is where the marginalization property of a Gaussian process comes in. It enables us to obtain the distribution for a set of arbitrary points from the\nfull Gaussian process. In the following, we obtain the distribution over two points on the eye:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val referencePointSet = model.reference.pointSet\n    val rightEyePt: Point[_3D] = referencePointSet.point(PointId(4281))\n    val leftEyePt: Point[_3D] = referencePointSet.point(PointId(11937))\n    val marginal : DiscreteGaussianProcess[_3D, UnstructuredPointsDomain, EuclideanVector[_3D]] = contGP.marginal(IndexedSeq(rightEyePt,leftEyePt))\n")),(0,o.kt)("p",null,"The result of marginalization is a discrete Gaussian process. Note that since we have specified individual points, on which\nto evaluate the Gaussian process, but not how these points are connected, the resulting\ndiscrete Gaussian process is defined over an ",(0,o.kt)("inlineCode",{parentName:"p"},"UnstructuredPointsDomain"),".\nTo obtain a discrete Gaussian Process with a richer structure, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"discretize")," method,\nwhich takes as an argument a domain and result in a discrete Gaussian Process defined on that domain."),(0,o.kt)("p",null,"To obtain the Gaussian Process that we started with again, we can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"discretize")," method\nwith the reference mesh:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val discreteGP : DiscreteGaussianProcess[_3D, TriangleMesh, EuclideanVector[_3D]] = contGP.discretize(model.reference)\n")),(0,o.kt)("p",null,"This mechanism of interpolation followed by discretization gives us the ability to freely change\nthe resolution of the domain on which the Gaussian process is defined."),(0,o.kt)("h2",{id:"changing-the-reference-of-a-point-distribution-model"},"Changing the reference of a point distribution model"),(0,o.kt)("p",null,"Given that a point distribution model is really just a wrapper around a Gaussian process, it\nis not surprising that we can apply the same ideas to these models. In particular, we often\nwish to change the domain (I.e., the reference) of a point distribution model.\nThis can be done using the method ",(0,o.kt)("inlineCode",{parentName:"p"},"newReference")," of the point distribution model. Under the hood, the method ",(0,o.kt)("inlineCode",{parentName:"p"},"newReference"),"\ninterpolates the gaussian process and discretizes it with the new reference."),(0,o.kt)("p",null,"In the following example we use this method to obtain a model which is defined on a low-resolution mesh:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val lowresMesh = model.reference.operations.decimate(1000)\n    val lowResModel = model.newReference(lowresMesh, TriangleMeshInterpolator3D())\n")),(0,o.kt)("p",null,"Other common applications of this method include restricting the model to only a part of the domain or changing between different representations of the object.",(0,o.kt)("br",{parentName:"p"}),"\n","For instance, if we have a representation of a shape in terms of a tetrahedral mesh, we could use ",(0,o.kt)("inlineCode",{parentName:"p"},"newReference")," to obtain a model of only the outer surface of the\nmesh. "),(0,o.kt)("h2",{id:"probability-of-shapes-and-deformations"},"Probability of shapes and deformations:"),(0,o.kt)("p",null,"In data analysis applications, it is often interesting to assess how likely individual model instances are. This information is, for example,\nneeded for finding the most likely shape in a model matching a given observation. "),(0,o.kt)("p",null,"Gaussian processes represent probability distributions. Thus this information is contained in the corresponding density function.\nWe can evaluate the (log-) of the density for a given deformation field or shape using the ",(0,o.kt)("inlineCode",{parentName:"p"},"logpdf")," method of the gaussian process.\nHere, this is illustrated for a random sample from a GP:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"    val defSample = model.gp.sample()\n    model.gp.logpdf(defSample)\n")))}d.isMDXComponent=!0},3335:function(e,t,n){t.Z=n.p+"assets/files/Tutorial05-6e23d33ec94e802ec85ca8448651e658.scala"}}]);