"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3741],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(f,a(a({ref:t},c),{},{components:n})):r.createElement(f,a({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var u=2;u<i;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2741:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],s={id:"tutorial11",title:"Model fitting with Iterative Closest Points"},l=void 0,u={unversionedId:"Tutorials/tutorial11",id:"version-0.92/Tutorials/tutorial11",title:"Model fitting with Iterative Closest Points",description:"To enhance your understanding of this tutorial, we recommend the following resources from our online course:",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial11.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial11",permalink:"/docs/Tutorials/tutorial11",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial11.md",tags:[],version:"0.92",frontMatter:{id:"tutorial11",title:"Model fitting with Iterative Closest Points"},sidebar:"docs",previous:{title:"Iterative Closest Points for rigid alignment",permalink:"/docs/Tutorials/tutorial10"},next:{title:"Parametric, non-rigid registration",permalink:"/docs/Tutorials/tutorial12"}},c=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Problem setup",id:"problem-setup",children:[],level:3}],p={toc:c};function d(e){var t=e.components,s=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,i.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,i.kt)("h5",{id:"related-resources"},"Related resources"),(0,i.kt)("p",null,"The following resources from our ",(0,i.kt)("a",{parentName:"p",href:"https://www.futurelearn.com/courses/statistical-shape-modelling"},"online course")," may provide\nsome helpful context for this tutorial:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Model-fitting and correspondence ",(0,i.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371"},"(Video)")),(0,i.kt)("li",{parentName:"ul"},"Model-fitting and the registration problem ",(0,i.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250372"},"(Article)"))),(0,i.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(6939).Z},"Tutorial11.scala"))),(0,i.kt)("h5",{id:"preparation"},"Preparation"),(0,i.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry.*\nimport scalismo.common.*\nimport scalismo.mesh.*\nimport scalismo.statisticalmodel.MultivariateNormalDistribution\nimport scalismo.numerics.UniformMeshSampler3D\nimport scalismo.io.{MeshIO, StatisticalModelIO, LandmarkIO}\n\nimport scalismo.ui.api.*\n\nimport breeze.linalg.{DenseMatrix, DenseVector}\n\nimport java.io.File\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  scalismo.initialize()\n\n  val ui = ScalismoUI()\n")),(0,i.kt)("h3",{id:"problem-setup"},"Problem setup"),(0,i.kt)("p",null,"Let's start by loading and visualizing a target mesh and a statistical shape model."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'  val targetMesh = MeshIO.readMesh(File("datasets/target.ply")).get\n  val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(File("datasets/bfm.h5")).get\n\n  val targetGroup = ui.createGroup("targetGroup")\n  val targetMeshView = ui.show(targetGroup, targetMesh, "targetMesh")\n\n  val modelGroup = ui.createGroup("modelGroup")\n  val modelView = ui.show(modelGroup, model, "model")\n')),(0,i.kt)("p",null,"As you can observe, the current model instance does not resemble the target face. The goal of shape model fitting is to find an instance of our model that closely matches the target face, thus establishing correspondences between model and target points."),(0,i.kt)("p",null,"The Iterative Closest Points (ICP) algorithm can assist us here. Its main steps include finding candidate correspondences, determining the optimal transform through Procrustes analysis, transforming the moving mesh, and iterating these steps until alignment or reaching the iteration limit."),(0,i.kt)("p",null,"For model fitting, we'll use non-rigid ICP, which performs the exact same steps but instead of using Procrustes Analysis, it finds a non-rigid transformation using Gaussian process regression."),(0,i.kt)("p",null,"Let's begin by selecting uniformly distributed points on the surface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val sampler = UniformMeshSampler3D(model.reference, numberOfPoints = 5000)\n  val points : Seq[Point[_3D]] = sampler.samplePoints()\n")),(0,i.kt)("p",null,"We can now identify the closest point on the target for each point of interest:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val ptIds = points.map(point => model.reference.pointSet.findClosestPoint(point).id)\n")),(0,i.kt)("p",null,"As in the previous tutorial, we write the method ",(0,i.kt)("inlineCode",{parentName:"p"},"attributeCorrespondences"),", which finds for each\npoint of interest the closest point on the target."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def attributeCorrespondences(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId]) : Seq[(PointId, Point[_3D])] = \n    ptIds.map( (id : PointId) =>\n      val pt = movingMesh.pointSet.point(id)\n      val closestPointOnMesh2 = targetMesh.pointSet.findClosestPoint(pt).point\n      (id, closestPointOnMesh2)\n    )  \n")),(0,i.kt)("p",null,"Next, we use these correspondences to compute Gaussian process regression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'\n  val correspondences = attributeCorrespondences(model.mean, ptIds)\n\n  val littleNoise = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3))\n\n  def fitModel(correspondences: Seq[(PointId, Point[_3D])]) : TriangleMesh[_3D] = \n    val regressionData = correspondences.map(correspondence =>\n      (correspondence._1, correspondence._2, littleNoise)\n    )\n    val posterior = model.posterior(regressionData.toIndexedSeq)\n    posterior.mean\n  \n\n  val fit = fitModel(correspondences)\n  val resultGroup = ui.createGroup("results")\n  val fitResultView = ui.show(resultGroup, fit, "fit")\n')),(0,i.kt)("p",null,"While this one fitting iteration does not bring the points where we would like them to have, we are already\na step closer. As in the Rigid ICP case, we now iterate the procedure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def nonrigidICP(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId], numberOfIterations : Int) : TriangleMesh[_3D] = \n    if (numberOfIterations == 0) then\n      movingMesh \n    else \n      val correspondences = attributeCorrespondences(movingMesh, ptIds)\n      val transformed = fitModel(correspondences)\n\n      nonrigidICP(transformed, ptIds, numberOfIterations - 1)    \n")),(0,i.kt)("p",null,"Repeating the fitting steps iteratively for 20 times results in a good fit of our model"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'  val finalFit = nonrigidICP( model.mean, ptIds, 20)\n\n  ui.show(resultGroup, finalFit, "final fit")\n')))}d.isMDXComponent=!0},6939:function(e,t,n){t.Z=n.p+"assets/files/Tutorial11-24b262da6a24cc8f4ea9c2025adaa0b0.scala"}}]);