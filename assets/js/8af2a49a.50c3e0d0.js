"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3286],{3905:function(a,e,t){t.d(e,{Zo:function(){return i},kt:function(){return d}});var n=t(7294);function s(a,e,t){return e in a?Object.defineProperty(a,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):a[e]=t,a}function r(a,e){var t=Object.keys(a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(a);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),t.push.apply(t,n)}return t}function m(a){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){s(a,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(t,e))}))}return a}function o(a,e){if(null==a)return{};var t,n,s=function(a,e){if(null==a)return{};var t,n,s={},r=Object.keys(a);for(n=0;n<r.length;n++)t=r[n],e.indexOf(t)>=0||(s[t]=a[t]);return s}(a,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(a);for(n=0;n<r.length;n++)t=r[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(a,t)&&(s[t]=a[t])}return s}var p=n.createContext({}),l=function(a){var e=n.useContext(p),t=e;return a&&(t="function"==typeof a?a(e):m(m({},e),a)),t},i=function(a){var e=l(a.components);return n.createElement(p.Provider,{value:e},a.children)},c={inlineCode:"code",wrapper:function(a){var e=a.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(a,e){var t=a.components,s=a.mdxType,r=a.originalType,p=a.parentName,i=o(a,["components","mdxType","originalType","parentName"]),h=l(t),d=s,N=h["".concat(p,".").concat(d)]||h[d]||c[d]||r;return t?n.createElement(N,m(m({ref:e},i),{},{components:t})):n.createElement(N,m({ref:e},i))}));function d(a,e){var t=arguments,s=e&&e.mdxType;if("string"==typeof a||s){var r=t.length,m=new Array(r);m[0]=h;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=a,o.mdxType="string"==typeof a?a:s,m[1]=o;for(var l=2;l<r;l++)m[l]=t[l];return n.createElement.apply(null,m)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4660:function(a,e,t){t.r(e),t.d(e,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return i},default:function(){return h}});var n=t(7462),s=t(3366),r=(t(7294),t(3905)),m=["components"],o={id:"tutorial15",title:"Model fitting using MCMC - Fitting a shape model"},p=void 0,l={unversionedId:"Tutorials/tutorial15",id:"version-0.92/Tutorials/tutorial15",title:"Model fitting using MCMC - Fitting a shape model",description:"In this tutorial we show how the MCMC framework, which was introduced in the previous",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial15.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial15",permalink:"/docs/Tutorials/tutorial15",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial15.md",tags:[],version:"0.92",frontMatter:{id:"tutorial15",title:"Model fitting using MCMC - Fitting a shape model"},sidebar:"docs",previous:{title:"Model fitting using MCMC - The basic framework",permalink:"/docs/Tutorials/tutorial14"},next:{title:"Introduction to Scalismo-ui",permalink:"/docs/scalismo-ui-introduction"}},i=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Loading and visualizing the data",id:"loading-and-visualizing-the-data",children:[],level:3},{value:"The parameter class",id:"the-parameter-class",children:[],level:3},{value:"Evaluators: Modelling the target density",id:"evaluators-modelling-the-target-density",children:[{value:"The posterior evaluator",id:"the-posterior-evaluator",children:[],level:4}],level:3},{value:"The proposal generator",id:"the-proposal-generator",children:[{value:"Building the Markov Chain",id:"building-the-markov-chain",children:[],level:4}],level:3},{value:"Analyzing the results",id:"analyzing-the-results",children:[],level:3},{value:"Beyond landmark fitting",id:"beyond-landmark-fitting",children:[],level:3}],c={toc:i};function h(a){var e=a.components,o=(0,s.Z)(a,m);return(0,r.kt)("wrapper",(0,n.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial we show how the MCMC framework, which was introduced in the previous\ntutorial, can be used for shape model fitting."),(0,r.kt)("p",null,"We will illustrate it by computing a posterior of a shape model,\ngiven a set of corresponding landmark pairs. This is the same setup that we have\ndiscussed in the tutorial about Gaussian process regression. The difference is,\nthat here we will also allow for rotation and translation of the model. In this setting,\nit is not possible anymore to compute the posterior analytically. Rather, our only hope are approximation methods, such as\nusing Markov-chain monte carlo methods."),(0,r.kt)("p",null,"In this tutorial we show not only a working example, but also how to make it\ncomputationally efficient. Making the individual parts as efficient as possible is\nimportant in sampling approaches, as we need to produce many samples to get accurate\nestimates."),(0,r.kt)("h5",{id:"related-resources"},"Related resources"),(0,r.kt)("p",null,"Week 3 of our ",(0,r.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/probabilistic-fitting-course/"},"online course")," on shape model fitting may provide helpful context for this tutorial."),(0,r.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:t(5836).Z},"Tutorial15.scala"))),(0,r.kt)("h5",{id:"preparation"},"Preparation"),(0,r.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and\ninitializing the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.io.StatisticalModelIO\nimport scalismo.io.LandmarkIO\nimport scalismo.ui.api.ScalismoUI\nimport scalismo.geometry.*\nimport scalismo.common.PointId\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.common.UnstructuredPointsDomain\nimport scalismo.common.interpolation.NearestNeighborInterpolator3D\nimport scalismo.common.UnstructuredPointsDomain1D\nimport scalismo.common.UnstructuredPointsDomain3D\nimport scalismo.statisticalmodel.PointDistributionModel\nimport scalismo.statisticalmodel.MultivariateNormalDistribution\n\nimport scalismo.mesh.TriangleMesh\nimport scalismo.transformations.*\n\n\nimport scalismo.sampling.*\nimport scalismo.sampling.proposals.*\nimport scalismo.sampling.parameters.*\nimport scalismo.sampling.evaluators.*\nimport scalismo.sampling.loggers.MHSampleLogger\nimport scalismo.sampling.algorithms.MetropolisHastings\n\nimport breeze.linalg.DenseVector\nimport breeze.linalg.DenseMatrix\n\nimport java.io.File\n\nimport breeze.stats.distributions.Rand.FixedSeed.randBasis\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  scalismo.initialize()\n\n  val ui = ScalismoUI()\n")),(0,r.kt)("h3",{id:"loading-and-visualizing-the-data"},"Loading and visualizing the data"),(0,r.kt)("p",null,"In a first step, we load and visualize all the data that we need.\nFirst, we load the statistical model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(File("datasets/bfm.h5")).get\n\n  val modelGroup = ui.createGroup("model")\n  val modelView = ui.show(modelGroup, model, "model")\n  modelView.referenceView.opacity = 0.5\n')),(0,r.kt)("p",null,"In this example, we will fit the model such that a set of model landmarks, coincide\nwith a set of landmark points defined on a target face. We load and visualize the corresponding landmark data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val modelLms = LandmarkIO.readLandmarksJson[_3D](new java.io.File("datasets/modelLM_mcmc.json")).get\n  val modelLmViews = ui.show(modelGroup, modelLms, "modelLandmarks")\n  modelLmViews.foreach(lmView => lmView.color = java.awt.Color.BLUE)\n\n  val targetGroup = ui.createGroup("target")\n\n  val targetLms = LandmarkIO.readLandmarksJson3D(new java.io.File("datasets/targetLM_mcmc.json")).get\n  val targetLmViews = ui.show(targetGroup, targetLms, "targetLandmarks")\n  modelLmViews.foreach(lmView => lmView.color = java.awt.Color.RED)\n')),(0,r.kt)("p",null,"The modelPoints (which are actually points on the reference mesh defining the model) and the\ntarget points are assumed to be in correspondence. To highlight this, we zip them together,\nsuch that the corresponding points are stored as a tuple. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val modelPoints = modelLms.map(l => l.point)\n  val targetPoints = targetLms.map(l => l.point)\n  val correspondences = modelPoints.zip(targetPoints)\n")),(0,r.kt)("p",null,"In any shape modelling application, it is important to correctly set up the center of rotation.\nUsually we take this to be the center of mass of the model mean. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  def computeCenterOfMass(mesh: TriangleMesh[_3D]): Point[_3D] = \n      val normFactor = 1.0 / mesh.pointSet.numberOfPoints\n      mesh.pointSet.points.foldLeft(Point(0, 0, 0))((sum, point) => sum + point.toVector * normFactor)\n\n  val rotationCenter = computeCenterOfMass(model.mean)\n")),(0,r.kt)("h3",{id:"the-parameter-class"},"The parameter class"),(0,r.kt)("p",null,"In this example, we want to model the posterior ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where\nthe parameters ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"t"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"r"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03b1"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\theta =( t, r, \\alpha)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," consist of the translation parameters\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"t"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"x")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"y")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mi",{parentName:"msub"},"z")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t=(t_x, t_y, t_z)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.61508em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.036108em",verticalAlign:"-0.286108em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"x")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15139200000000003em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03588em"}},"y")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.286108em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.04398em"}},"z")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", the rotation parameters ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"r"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03d5"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03c8"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow"},"\u03c9"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"r = (\\phi, \\psi, \\omega)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03d5"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c8"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c9"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),",\nrepresented as Euler angles as well a shape model coefficients ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b1"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"\u03b1"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mo",{parentName:"mrow"},"\u2026"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"\u03b1"),(0,r.kt)("mi",{parentName:"msub"},"n")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\alpha = (\\alpha_1, \\ldots, \\alpha_n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.30110799999999993em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"-0.0037em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"minner"},"\u2026"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"-0.0037em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"n")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),".\nAs this combination of parameters is very common in shape modelling, Scalismo already provides\na corresponding parameter class, called ",(0,r.kt)("inlineCode",{parentName:"p"},"PoseAndShapeParameters"),".\nWe need, however, to define any additional parameters that we want to model by ourselves. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  case class Parameters(poseAndShapeParameters : PoseAndShapeParameters, \n                        noiseStddev : Double\n                      )\n")),(0,r.kt)("p",null,"The class ",(0,r.kt)("inlineCode",{parentName:"p"},"PoseAndShapeParameters")," class is defined as part of Scalismo. In this tutorial,\nwe add an other parameter, namely the ",(0,r.kt)("inlineCode",{parentName:"p"},"noiseStddev"),", which regulates the noise that we expect\non the observations. To be able to derive proposals for such a user defined parameter class, we\nneed to provide conversion methods that tell scalismo how to convert the parameters to and from\na tuple. We will also add a convenience method to extract the pose transformation from the\nparameters. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  object Parameters:\n\n      implicit object parameterConversion\n          extends ParameterConversion[\n            Tuple2[PoseAndShapeParameters, Double],\n            Parameters\n          ]:\n        def from(p: Parameters): Tuple2[PoseAndShapeParameters, Double] =\n          (p.poseAndShapeParameters, p.noiseStddev)\n        def to(t: Tuple2[PoseAndShapeParameters, Double]): Parameters =\n          Parameters(t._1, t._2)      \n\n      def poseTransformationForParameters(\n          translationParameters: TranslationParameters,\n          rotationParameters: RotationParameters,\n          centerOfRotation: Point[_3D]\n      ): TranslationAfterRotation[_3D] = \n        TranslationAfterRotation3D(\n          Translation3D(translationParameters.translationVector),\n          Rotation3D(rotationParameters.angles, centerOfRotation)\n        )\n")),(0,r.kt)("h3",{id:"evaluators-modelling-the-target-density"},"Evaluators: Modelling the target density"),(0,r.kt)("p",null,"As in the previous tutorial, we represent the unnormalized posterior distribution\nas the product of prior and likelihood:\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"\u221d"),(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D) \\propto p(\\theta) p(D | \\theta)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u221d"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),",\nwhere ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"D")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"D")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D")))))," denotes the data (i.e. the corresponding landmark points) and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b8")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\theta")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"))))),"\nare our parameters."),(0,r.kt)("p",null,"As a prior over the shape parameters is given by the shape model. For the\ntranslation and rotation, we assume a zero-mean normal distribution. As the standard deviation\ncharacterizing the noise needs to be positive, we use a lognormal distribution.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  case class PriorEvaluator(model: PointDistributionModel[_3D, TriangleMesh])\n      extends MHDistributionEvaluator[Parameters]:\n\n    val translationPrior = breeze.stats.distributions.Gaussian(0.0, 5.0)\n    val rotationPrior = breeze.stats.distributions.Gaussian(0, 0.1)\n    val noisePrior = breeze.stats.distributions.LogNormal(0, 0.25)\n\n    override def logValue(sample: MHSample[Parameters]): Double = \n      val poseAndShapeParameters = sample.parameters.poseAndShapeParameters\n      val translationParameters = poseAndShapeParameters.translationParameters\n      val rotationParameters = poseAndShapeParameters.rotationParameters\n\n      model.gp.logpdf(poseAndShapeParameters.shapeParameters.coefficients) +\n        translationPrior.logPdf(translationParameters.translationVector.x) +\n        translationPrior.logPdf(translationParameters.translationVector.y) +\n        translationPrior.logPdf(translationParameters.translationVector.z) +\n        rotationPrior.logPdf(rotationParameters.angles._1) +\n        rotationPrior.logPdf(rotationParameters.angles._2) +\n        rotationPrior.logPdf(rotationParameters.angles._3) +\n        noisePrior.logPdf(sample.parameters.noiseStddev)\n")),(0,r.kt)("p",null,"To compute the likelihood ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(D | \\theta)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," we need to determine where\nthe landmark points on the model are mapped under the transformation\ngiven by the parameters ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03b8")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\theta")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"))))),". The distance between these mapped\nmodel points and the target points determine the likelihood.\nAs we only need to map the landmark points, it is computationally more\nefficient to restrict the model to these points first, and then only\nto deform these points rather than all the points of the model. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"}," \n  case class CorrespondenceEvaluator(\n      model: PointDistributionModel[_3D, TriangleMesh],\n      rotationCenter: Point[_3D],\n      correspondences: Seq[(Point[_3D], Point[_3D])]\n  ) extends MHDistributionEvaluator[Parameters]:\n\n    // we extract the points and build a model from only the points\n    val (refPoints, targetPoints) = correspondences.unzip\n\n    val newDomain = UnstructuredPointsDomain3D(refPoints.toIndexedSeq)\n    val modelOnLandmarkPoints = model.newReference(newDomain, NearestNeighborInterpolator3D())\n    \n    override def logValue(sample: MHSample[Parameters]): Double = \n\n      val poseTransformation = Parameters.poseTransformationForParameters(\n        sample.parameters.poseAndShapeParameters.translationParameters,\n        sample.parameters.poseAndShapeParameters.rotationParameters,\n        rotationCenter\n      )\n      \n      val modelCoefficients = sample.parameters.poseAndShapeParameters.shapeParameters.coefficients\n      val currentModelInstance =\n        modelOnLandmarkPoints.instance(modelCoefficients).transform(poseTransformation)\n\n      \n      val lmUncertainty = MultivariateNormalDistribution(\n        DenseVector.zeros[Double](3),\n        DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev\n      )\n\n      val likelihoods = for ((pointOnInstance, targetPoint) <- currentModelInstance.pointSet.points.zip(targetPoints)) yield \n        val observedDeformation = targetPoint - pointOnInstance\n        lmUncertainty.logpdf(observedDeformation.toBreezeVector)\n      \n\n      val loglikelihood = likelihoods.sum\n      loglikelihood\n")),(0,r.kt)("h4",{id:"the-posterior-evaluator"},"The posterior evaluator"),(0,r.kt)("p",null,"Given these evaluators, we can now build the computationally efficient version of\nour target density ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"p"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"\u03b8"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"D"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(\\theta | D)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"\u03b8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"D"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val likelihoodEvaluator = CorrespondenceEvaluator(model, rotationCenter, correspondences)\n  val priorEvaluator = PriorEvaluator(model).cached\n\n  val posteriorEvaluator = ProductEvaluator(priorEvaluator, likelihoodEvaluator)\n")),(0,r.kt)("h3",{id:"the-proposal-generator"},"The proposal generator"),(0,r.kt)("p",null,"As in the previous tutorials, we will use simple random walk proposals.\nWe will define separate proposals for shape, translation and rotation.\nOn one hand, this lets us set the step length (i.e. stddev of the distribution from which we\nsample the next step) individually for each group, and thus to incorporate our knowledge\nthat changes in rotation will be much smaller than the shape changes. On the other hand,\nsplitting the parameter updates in blocks will increase our chance for the random updates\nto be accepted. The reason for this is that when many parameters are updated at one,\nchances are high that some of the proposed changes make the new state more unlikely,\nand hence increase the chance of the new state being rejected."),(0,r.kt)("p",null,"We start by defining the basic pose proposals"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val rotationProposal = MHProductProposal(\n    GaussianRandomWalkProposal(0.01, "rx").forType[Double],\n    GaussianRandomWalkProposal(0.01, "ry").forType[Double],\n    GaussianRandomWalkProposal(0.01, "rz").forType[Double]\n  ).forType[RotationParameters]\n\n  val translationProposal = MHProductProposal(\n    GaussianRandomWalkProposal(1.0, "tx").forType[Double],\n    GaussianRandomWalkProposal(1.0, "ty").forType[Double],\n    GaussianRandomWalkProposal(1.0, "tz").forType[Double]\n  ).forType[TranslationParameters]\n\n')),(0,r.kt)("p",null,"The next proposal is for updating the shape parameters. We define two\nshape proposals, one for the leading parameters, which adjusts the overall\nshape, and one for the remaining parameters. We can achieve this using\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},".partial")," method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"GaussianRandomWalkProposal"),", which will only\nupdate the components in a given range."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val shapeProposalLeading =\n      GaussianRandomWalkProposal(0.01, "shape-0-5").partial(0 until 5)\n        .forType[ShapeParameters]\n  val shapeProposalRemaining =\n    GaussianRandomWalkProposal(0.01, "shape-6-").partial(6 until model.rank)\n      .forType[ShapeParameters]\n')),(0,r.kt)("p",null,"From these building blocks, we can define different proposal for shape and pose, which always\nonly update a part of the parameters. For better readability, we also give them simpler name, under\nwhich they later appear in the logs. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val identTranslationProposal =\n    MHIdentityProposal.forType[TranslationParameters]\n  val identRotationProposal = MHIdentityProposal.forType[RotationParameters]\n  val identShapeProposal = MHIdentityProposal.forType[ShapeParameters]\n\n  val poseAndShapeTranslationOnlyProposal =\n    MHProductProposal(\n      translationProposal,\n      identRotationProposal,\n      identShapeProposal\n    )\n    .forType[PoseAndShapeParameters]\n    .relabel("translation-only")\n  val poseAndShapeRotationOnlyProposal =\n    MHProductProposal(\n      identTranslationProposal,\n      rotationProposal,\n      identShapeProposal\n    )\n    .forType[PoseAndShapeParameters]\n    .relabel("rotation-only")\n  val poseAndShapeLeadingShapeOnlyProposal =\n    MHProductProposal(\n      identTranslationProposal,\n      identRotationProposal,\n      shapeProposalLeading\n    )\n    .forType[PoseAndShapeParameters]\n    .relabel("shape-leading-only")\n\n  val poseAndShapeRemainingShapeOnlyProposal =\n    MHProductProposal(\n      identTranslationProposal,\n      identRotationProposal,\n      shapeProposalRemaining\n    )\n    .forType[PoseAndShapeParameters]\n    .relabel("shape-trailing-only")\n')),(0,r.kt)("p",null,"Using a mixture proposal, we can combine them to one proposal for pose and shape"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val mixturePoseAndShapeProposal = MHMixtureProposal(\n    (0.2, poseAndShapeTranslationOnlyProposal),\n    (0.2, poseAndShapeRotationOnlyProposal),\n    (0.3, poseAndShapeLeadingShapeOnlyProposal),\n    (0.3, poseAndShapeRemainingShapeOnlyProposal)\n  )\n")),(0,r.kt)("p",null,"Finally, we do the same for the noise proposal to obtain a proposal\nthat updates the full parameter vector"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val noiseProposal = GaussianRandomWalkProposal(0.1, "noise").forType[Double]\n  val identNoiseProposal = MHIdentityProposal.forType[Double]\n  val identPoseAndShapeProposal =\n    MHIdentityProposal.forType[PoseAndShapeParameters]\n\n  val noiseOnlyProposal =\n    MHProductProposal(identPoseAndShapeProposal, noiseProposal)\n      .forType[Parameters]\n  val poseAndShapeOnlyProposal =\n    MHProductProposal(mixturePoseAndShapeProposal, identNoiseProposal)\n      .forType[Parameters]\n  val fullproposal = MHMixtureProposal(\n    (0.9, poseAndShapeOnlyProposal),\n    (0.1, noiseOnlyProposal)\n  )\n')),(0,r.kt)("h4",{id:"building-the-markov-chain"},"Building the Markov Chain"),(0,r.kt)("p",null,"For running the Markov Chain, we proceed exactly as in the previous tutorial."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val logger = MHSampleLogger[Parameters]()\n  val chain = MetropolisHastings(fullproposal, posteriorEvaluator)\n\n  val initialParameters = Parameters(\n    PoseAndShapeParameters(TranslationParameters(EuclideanVector3D(0, 0, 0)),\n                            RotationParameters((0.0, 0.0, 0.0)),\n                            ShapeParameters(DenseVector.zeros[Double](model.rank))),\n    noiseStddev = 1.0)\n\n  val mhIterator = chain.iterator(MHSample(initialParameters, "inital"), logger)\n')),(0,r.kt)("p",null,"In this example we are interested to visualize some samples from the posterior as we run the chain. This can be done\nby augmenting the iterator with visualization code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val samplingIterator = for ((sample, iteration) <- mhIterator.zipWithIndex) yield \n    println("iteration " + iteration)\n    if (iteration % 500 == 0) then\n      val poseAndShapeParameters = sample.parameters.poseAndShapeParameters\n      val poseTransformation = Parameters.poseTransformationForParameters(poseAndShapeParameters.translationParameters, poseAndShapeParameters.rotationParameters, rotationCenter)\n      modelView.shapeModelTransformationView.shapeTransformationView.coefficients =\n        poseAndShapeParameters.shapeParameters.coefficients\n      modelView.shapeModelTransformationView.poseTransformationView.transformation = poseTransformation\n    \n    sample\n')),(0,r.kt)("p",null,"Finally, we draw the samples using the chain by consuming the iterator. We drop the first 1000 iterations, as the\nchain needs some burn-in time to converge to a equilibrium solution:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val samples = samplingIterator.drop(1000).take(10000).toIndexedSeq\n")),(0,r.kt)("p",null,"Before working with the results, we check the acceptance ratios to verify that all the proposals work as expected:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  println(logger.samples.acceptanceRatios)\n")),(0,r.kt)("h3",{id:"analyzing-the-results"},"Analyzing the results"),(0,r.kt)("p",null,"Once we have the samples, we can now use them to analyze our fit.\nFor example, we can select the best fit from these samples and visualize it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val bestSample = samples.maxBy(posteriorEvaluator.logValue)\n    \n  val bestPoseAndShapeParameters = bestSample.parameters.poseAndShapeParameters\n  val bestPoseTransformation = Parameters.poseTransformationForParameters(\n      bestPoseAndShapeParameters.translationParameters,\n      bestPoseAndShapeParameters.rotationParameters,\n      rotationCenter)    \n    \n\n  val bestFit = model.instance(bestPoseAndShapeParameters.shapeParameters.coefficients).transform(bestPoseTransformation)\n  val resultGroup = ui.createGroup("result")\n\n  ui.show(resultGroup, bestFit, "best fit")\n')),(0,r.kt)("p",null,"The samples allow us to infer much more about the distribution. For example, we could use them to estimate the distribution\nof the length of the femur or any other measuremnt of the shape that we are interested. "),(0,r.kt)("h3",{id:"beyond-landmark-fitting"},"Beyond landmark fitting"),(0,r.kt)("p",null,"We have shown above how Scalismo can be used to perform Bayesian model fitting on the example of fitting 3D landmarks. This example\ncan easily be extended to other fitting tasks, such as fitting the model to points with unkown correspondences, fitting shapes in surfaces\nof fitting a model to an image using an Active Shape Model as a likelihood function. In principle, all that is required is to\nchange the likelihood function and rerun the fit.\nIn practice, however, as a change in the likelihood function can dramatically change the posterior density, it is often required\nto tune the proposals, such that good convergence can be achieved. Indeed, finding good proposal distributions is the key to\napplying this method successfully. The more prior knowledge about the target distribution we can incorporate into the proposals,\nthe faster will the chain converge to the equilibrium distribution."),(0,r.kt)("p",null,"For more complicated use-cases of this method in image analysis, the interested reader is referred to the paper by S. Sch\xf6nborn et al.\nand references therein:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Sch\xf6nborn, Sandro, et al. "Markov chain monte carlo for automated face image analysis." International Journal of Computer Vision 123.2 (2017): 160-183.')))}h.isMDXComponent=!0},5836:function(a,e,t){e.Z=t.p+"assets/files/Tutorial15-b826331477f54788f975366afb088495.scala"}}]);