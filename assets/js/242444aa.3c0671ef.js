"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2634],{3905:function(e,a,t){t.d(a,{Zo:function(){return p},kt:function(){return d}});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=n.createContext({}),m=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},p=function(e){var a=m(e.components);return n.createElement(l.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=m(t),d=s,u=h["".concat(l,".").concat(d)]||h[d]||c[d]||i;return t?n.createElement(u,r(r({ref:a},p),{},{components:t})):n.createElement(u,r({ref:a},p))}));function d(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=t.length,r=new Array(i);r[0]=h;var o={};for(var l in a)hasOwnProperty.call(a,l)&&(o[l]=a[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,r[1]=o;for(var m=2;m<i;m++)r[m]=t[m];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2463:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return p},default:function(){return h}});var n=t(7462),s=t(3366),i=(t(7294),t(3905)),r=["components"],o={id:"tutorial13",title:"Active Shape Model Fitting"},l=void 0,m={unversionedId:"Tutorials/tutorial13",id:"version-0.92/Tutorials/tutorial13",title:"Active Shape Model Fitting",description:"In this tutorial we show how we can perform active shape model fitting in Scalismo.",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial13.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial13",permalink:"/docs/Tutorials/tutorial13",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial13.md",tags:[],version:"0.92",frontMatter:{id:"tutorial13",title:"Active Shape Model Fitting"},sidebar:"docs",previous:{title:"Parametric, non-rigid registration",permalink:"/docs/Tutorials/tutorial12"},next:{title:"Model fitting using MCMC - The basic framework",permalink:"/docs/Tutorials/tutorial14"}},p=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Active Shape models in Scalismo",id:"active-shape-models-in-scalismo",children:[{value:"Identifying Likely Model Correspondences in an Image",id:"identifying-likely-model-correspondences-in-an-image",children:[],level:4},{value:"The original Active Shape Model Fitting",id:"the-original-active-shape-model-fitting",children:[],level:3}],level:2},{value:"Evaluating the likelihood of a model instance under the image",id:"evaluating-the-likelihood-of-a-model-instance-under-the-image",children:[],level:2}],c={toc:p};function h(e){var a=e.components,o=(0,s.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},c,o,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this tutorial we show how we can perform active shape model fitting in Scalismo."),(0,i.kt)("h5",{id:"related-resources"},"Related resources"),(0,i.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,i.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Fitting models to images ",(0,i.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250379"},"(Video)"))),(0,i.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:t(9967).Z},"Tutorial13.scala"))),(0,i.kt)("h5",{id:"preparation"},"Preparation"),(0,i.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry.*\nimport scalismo.transformations.*\nimport scalismo.registration.*\nimport scalismo.mesh.TriangleMesh\nimport scalismo.statisticalmodel.asm.*\nimport scalismo.io.{ActiveShapeModelIO, ImageIO}\n\nimport scalismo.ui.api.*\nimport breeze.linalg.{DenseVector}\n\nimport java.io.File\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    scalismo.initialize()\n\n    val ui = ScalismoUI()\n")),(0,i.kt)("h2",{id:"active-shape-models-in-scalismo"},"Active Shape models in Scalismo"),(0,i.kt)("p",null,"Scalismo provides comprehensive support for Active Shape models. This capability allows us to learn active shape models from a collection of images and their corresponding contours, save these models, and apply them to fit images. In this tutorial, we focus on model fitting, assuming the model has already been built."),(0,i.kt)("p",null,"The Active Shape Model can be loaded as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'    val asm = ActiveShapeModelIO.readActiveShapeModel(File("datasets/femur-asm.h5")).get\n')),(0,i.kt)("p",null,"An Active Shape Model instance in Scalismo is a combination of a statistical shape model and an intensity model. The shape model part can be retrieved using the statisticalModel method. Let's visualize this model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'    val modelGroup = ui.createGroup("modelGroup")\n    val modelView = ui.show(modelGroup, asm.statisticalModel, "shapeModel")\n')),(0,i.kt)("p",null,"The other component of the model, the intensity model, comprises a set of profiles linked to specific vertices of the shape model, designated by the pointId. Each profile has a defined probability distribution, representing the expected intensity variation for that profile."),(0,i.kt)("p",null,"The following code demonstrates how to access this information:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val profiles = asm.profiles\n    profiles.map(profile => \n        val pointId = profile.pointId\n        val distribution = profile.distribution\n    )\n")),(0,i.kt)("h4",{id:"identifying-likely-model-correspondences-in-an-image"},"Identifying Likely Model Correspondences in an Image"),(0,i.kt)("p",null,"The main use of the profile distribution is to locate points in the image that likely correspond to the given profile points in the model. "),(0,i.kt)("p",null,"Let ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msub",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msub"},"p"),(0,i.kt)("mi",{parentName:"msub"},"i"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_i")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.31166399999999994em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i")))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,i.kt)("span",{parentName:"span"})))))))))),"\u200b denote the i-th profile in the model. We can utilize this information to evaluate the likelihood that a point ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msub",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msub"},"x"),(0,i.kt)("mi",{parentName:"msub"},"j"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_j")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.716668em",verticalAlign:"-0.286108em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.311664em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.05724em"}},"j")))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.286108em"}},(0,i.kt)("span",{parentName:"span"}))))))))))," corresponds to the profile point ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msub",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msub"},"p"),(0,i.kt)("mi",{parentName:"msub"},"i"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_i")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.31166399999999994em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i")))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,i.kt)("span",{parentName:"span"})))))))))),", based on the image intensity patterns ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03c1"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("msub",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msub"},"x"),(0,i.kt)("mn",{parentName:"msub"},"1")),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mo",{parentName:"mrow"},"\u2026"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"\u03c1"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("msub",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msub"},"x"),(0,i.kt)("mi",{parentName:"msub"},"n")),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rho(x_1), \\ldots, \\rho(x_n)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03c1"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.30110799999999993em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,i.kt)("span",{parentName:"span"})))))),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"minner"},"\u2026"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03c1"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.151392em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"n")))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,i.kt)("span",{parentName:"span"})))))),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," at these points in an image."),(0,i.kt)("p",null,"To illustrate, we first load an image:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'    val image = ImageIO.read3DScalarImage[Short](new java.io.File("datasets/femur-image.nii")).get.map(_.toFloat)\n    val targetGroup = ui.createGroup("target")\n\n    val imageView = ui.show(targetGroup, image, "image")\n')),(0,i.kt)("p",null,"Scalismo's ASM implementation can work not only with raw intensities, but also with preprocessed images that have undergone transformations\nsuch as smoothing or gradient transformations. This preprocessed image can be obtained using the preprocessor method of the asm object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val preprocessedImage = asm.preprocessor(image)\n")),(0,i.kt)("p",null,"We can now extract features at a given point:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val point1 = image.domain.origin + EuclideanVector3D(10.0, 10.0, 10.0)\n    val profile = asm.profiles.head\n    val feature1 : DenseVector[Double] = asm.featureExtractor(preprocessedImage, point1, asm.statisticalModel.mean, profile.pointId).get\n")),(0,i.kt)("p",null,"Here we've passed the preprocessed image to the extractor, together with a point in the image where we wish to evaluate the feature vector, a mesh instance, and a mesh point id. The mesh instance and point id are necessary since the feature extractor might opt to extract the feature based on mesh data, such as the normal direction of a line at this point."),(0,i.kt)("p",null,"We can also assess the likelihood of each point corresponding to a given profile point:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val point2 = image.domain.origin + EuclideanVector3D(20.0, 10.0, 10.0)\n    val featureVec1 = asm.featureExtractor(preprocessedImage, point1, asm.statisticalModel.mean, profile.pointId).get\n    val featureVec2 = asm.featureExtractor(preprocessedImage, point2, asm.statisticalModel.mean, profile.pointId).get\n\n    val probabilityPoint1 = profile.distribution.logpdf(featureVec1)\n    val probabilityPoint2 = profile.distribution.logpdf(featureVec2)\n")),(0,i.kt)("p",null,"Based on this information, we can decide, which point is more likely to correspond to the model point. This idea forms the\nbasis of the original m Active Shape Model Fitting algorithm."),(0,i.kt)("h3",{id:"the-original-active-shape-model-fitting"},"The original Active Shape Model Fitting"),(0,i.kt)("p",null,"Scalismo features an implementation of Active Shape Model fitting algorithm, as proposed by ",(0,i.kt)("a",{parentName:"p",href:"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.3089&rep=rep1&type=pdf"},"Cootes and Taylor"),"."),(0,i.kt)("p",null,'To configure the fitting process, we need to set up a search method, which searches for a given model point, corresponding  points\nin the image. From these points, the most likely point is select and used as as the corresponding point for one iteration of\nthe algorithm. Once these "candidate correspondences" have been established, the rest of the algorithm works in exactly the same as\nthe ICP algorithm that we described in the previous tutorials.'),(0,i.kt)("p",null,"One search strategy that is already implemented in Scalismo is to search along\nthe normal direction of a model point. This behavior is provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"NormalDirectionSearchPointSampler")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val searchSampler = NormalDirectionSearchPointSampler(numberOfPoints = 100, searchDistance = 3)\n")),(0,i.kt)("p",null,"In addition to the search strategy, we can specify some additional configuration parameters to control the fitting process:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val config = FittingConfiguration(featureDistanceThreshold = 3, pointDistanceThreshold = 5, modelCoefficientBounds = 3)\n")),(0,i.kt)("p",null,"The first parameter determines how far away (as measured by the mahalanobis distance) an intensity feature can be, such that it is still\nchosen as corresponding. The ",(0,i.kt)("inlineCode",{parentName:"p"},"pointDistanceThreshold")," does the same for the distance of the points; I.e. in this  case points which are\nmore than 5 standard deviations aways are not chosen as corresponding points. The last parameters determines how\nlarge coefficients of the model can become in the fitting process. Whenever a model parameter is larger than this threshold,\nit will be set back to this maximal value. This introduces a regularization into the fitting, which prevents the shape\nfrom becoming too unlikely."),(0,i.kt)("p",null,"The ASM fitting algorithm optimizes both the pose (as defined by a rigid transformation) and the shape.\nIn order to allow it to optimize the rotation, it is important that we choose a rotation center, which is approximately\nthe center of mass of the model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val rotationCenter = asm.statisticalModel.reference.pointSet.centerOfMass\n")),(0,i.kt)("p",null,"To initialize the fitting process, we also need to set up the initial transformation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"\n// we start with the identity transform\n    val translationTransformation = Translation3D(EuclideanVector3D(0, 0, 0))\n    val rotationTransformation = Rotation3D(0, 0, 0, rotationCenter)\n    val initialRigidTransformation = TranslationAfterRotation3D(translationTransformation, rotationTransformation)\n    val initialModelCoefficients = DenseVector.zeros[Double](asm.statisticalModel.rank)\n    val initialTransformation = ModelTransformations(initialModelCoefficients, initialRigidTransformation)\n")),(0,i.kt)("p",null,"To start the fitting, we obtain an iterator, which we subsequently use to drive the iteration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val numberOfIterations = 20\n    val asmIterator = asm.fitIterator(image, searchSampler, numberOfIterations, config, initialTransformation)\n")),(0,i.kt)("p",null,"Especially in a debugging phase, we visualize the result in every iteration is useful. The following code shows,\nhow to obtain a new iterator, which updates the pose transformation and model coefficients in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui"),"\nin every iteration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val asmIteratorWithVisualization = asmIterator.map(it => \n        it match \n        case scala.util.Success(iterationResult) => \n            modelView.shapeModelTransformationView.poseTransformationView.transformation = iterationResult.transformations.rigidTransform\n            modelView.shapeModelTransformationView.shapeTransformationView.coefficients = iterationResult.transformations.coefficients        \n        case scala.util.Failure(error) => System.out.println(error.getMessage)    \n        it\n    )\n")),(0,i.kt)("p",null,"To run the fitting, and get the result, we finally consume the iterator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    val result = asmIteratorWithVisualization.toIndexedSeq.last\n    val finalMesh = result.get.mesh\n")),(0,i.kt)("h2",{id:"evaluating-the-likelihood-of-a-model-instance-under-the-image"},"Evaluating the likelihood of a model instance under the image"),(0,i.kt)("p",null,"In the preceding section, we utilized the intensity distribution to pinpoint the best image point corresponding\nto a specific model point. However, there are instances when we're also want to determine how accurately a model fits an image.\nTo calculate this, we can enhance the previous method to compute the likelihood for all profile points in an Active Shape Model."),(0,i.kt)("p",null,"Given the model instance, we can identify the position of each profile point in the current instance, evaluate its likelihood, and then calculate the joint likelihood for all profiles. Assuming independence, the joint probability is simply the multiplication of the probabilities at each individual profile point. To avoid extreme values, we employ log probabilities (turning the product into a sum)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"    def likelihoodForMesh(asm : ActiveShapeModel, mesh : TriangleMesh[_3D], preprocessedImage: PreprocessedImage) : Double = \n\n        val ids = asm.profiles.ids\n\n        val likelihoods = for (id <- ids) yield \n            val profile = asm.profiles(id)\n            val profilePointOnMesh = mesh.pointSet.point(profile.pointId)\n            // if the feature point is outside the image, we assign it a very low likelihood\n            val featureAtPoint = asm.featureExtractor(preprocessedImage, profilePointOnMesh, mesh, profile.pointId).getOrElse(-1e10)\n            profile.distribution.logpdf(featureAtPoint)\n        \n        likelihoods.sum    \n")),(0,i.kt)("p",null,"This method allows us to compute for each mesh, represented by the model, how likely it is to correspond\nto the given image."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'    val sampleMesh1 = asm.statisticalModel.sample()\n    val sampleMesh2 = asm.statisticalModel.sample()\n    println("Likelihood for mesh 1 = " + likelihoodForMesh(asm, sampleMesh1, preprocessedImage))\n    println("Likelihood for mesh 2 = " + likelihoodForMesh(asm, sampleMesh2, preprocessedImage))\n')),(0,i.kt)("p",null,"This information is all that is need to write probabilistic fitting methods methods using Markov Chain Monte Carlo\nmethods, which will be discussed in a later tutorial."))}h.isMDXComponent=!0},9967:function(e,a,t){a.Z=t.p+"assets/files/Tutorial13-eb74f88e33e5fe0455edcce11bacf60c.scala"}}]);