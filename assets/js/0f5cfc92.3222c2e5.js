"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7661],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),u=c(a),d=i,h=u["".concat(s,".").concat(d)]||u[d]||p[d]||l;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,o=new Array(l);o[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var c=2;c<l;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},65:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return m},default:function(){return u}});var n=a(7462),i=a(3366),l=(a(7294),a(3905)),o=["components"],r={id:"tutorial01",title:"Hello Scalismo!"},s=void 0,c={unversionedId:"Tutorials/tutorial01",id:"Tutorials/tutorial01",title:"Hello Scalismo!",description:"The goal in this tutorial is to present the most important data structures, as well as the visualization capabilities of Scalismo.",source:"@site/docs/Tutorials/tutorial01.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial01",permalink:"/docs/next/Tutorials/tutorial01",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial01.md",tags:[],version:"current",frontMatter:{id:"tutorial01",title:"Hello Scalismo!"},sidebar:"docs",previous:{title:"Using Scalismo with scala-cli and vscode",permalink:"/docs/next/Setup/vscode"},next:{title:"Rigid Alignment",permalink:"/docs/next/Tutorials/tutorial02"}},m=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Imports and Scalismo initialization",id:"imports-and-scalismo-initialization",children:[],level:2},{value:"Meshes (surface data)",id:"meshes-surface-data",children:[{value:"Anatomy of a Triangle mesh",id:"anatomy-of-a-triangle-mesh",children:[],level:4}],level:2},{value:"Points and Vectors",id:"points-and-vectors",children:[],level:2},{value:"Scalar Images",id:"scalar-images",children:[{value:"Scalar Image domain",id:"scalar-image-domain",children:[],level:3},{value:"Scalar image values",id:"scalar-image-values",children:[],level:3},{value:"Creating scalar images",id:"creating-scalar-images",children:[],level:3}],level:2},{value:"Point Distribution Models",id:"point-distribution-models",children:[{value:"Sampling in the UI",id:"sampling-in-the-ui",children:[],level:3},{value:"Sampling programmatically",id:"sampling-programmatically",children:[{value:"Retrieving objects from Scalismo-ui",id:"retrieving-objects-from-scalismo-ui",children:[],level:5},{value:"Related resources:",id:"related-resources-1",children:[],level:5}],level:3}],level:2}],p={toc:m};function u(e){var t=e.components,r=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The goal in this tutorial is to present the most important data structures, as well as the visualization capabilities of Scalismo."),(0,l.kt)("h5",{id:"related-resources"},"Related resources"),(0,l.kt)("p",null,"The ressources from week 1 of our ",(0,l.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course")," may provide helpful context for this tutorial."),(0,l.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{target:"_blank",href:a(2487).Z},"Tutorial01.scala"))),(0,l.kt)("h2",{id:"imports-and-scalismo-initialization"},"Imports and Scalismo initialization"),(0,l.kt)("p",null,"Before we start with writing actual Scalismo code, we import all\nobjects that we will need in this tutorial. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"\n// Basic geometric primitives\nimport scalismo.geometry.*\nimport scalismo.common.PointId\n\n// Geometric objects\nimport scalismo.mesh.{TriangleMesh, TriangleId}\nimport scalismo.mesh.TriangleId\nimport scalismo.image.{DiscreteImage, DiscreteImage3D}\nimport scalismo.statisticalmodel.PointDistributionModel \n\n// IO Methods\nimport scalismo.io.*\n\n// Visualization\nimport scalismo.ui.api.*\n\n// File object from java\nimport java.io.File\n\n// Choosing seeding mechanism for random number generator\nimport scalismo.utils.Random.FixedSeed.randBasis\n\n")),(0,l.kt)("p",null,"Before we can start working with Scalismo objects, we need to initialize Scalismo. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  scalismo.initialize()\n\n")),(0,l.kt)("p",null,"The call to ",(0,l.kt)("inlineCode",{parentName:"p"},"scalismo.initialize")," loads native C++ libraries such as ",(0,l.kt)("a",{parentName:"p",href:"https://www.vtk.org"},"vtk"),". "),(0,l.kt)("p",null,"As we progress, you will see that we create various objects in Scalismo. To better understand and manipulate these objects, we need to visualize them. This is where ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/unibas-gravis/scalismo-ui"},"Scalismo-ui")," comes into play. Scalismo-ui is a dedicated visualization library, designed to work seamlessly with Scalismo."),(0,l.kt)("p",null,"We can load an instance of the Graphical User Interface, which we name ",(0,l.kt)("inlineCode",{parentName:"p"},"ui")," as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val ui = ScalismoUI()\n")),(0,l.kt)("h2",{id:"meshes-surface-data"},"Meshes (surface data)"),(0,l.kt)("p",null,"The first fundamental data structure we discuss is the triangle mesh,\nwhich is defined in the package ",(0,l.kt)("inlineCode",{parentName:"p"},"scalismo.mesh"),".\nMeshes can be read from a file using the method ",(0,l.kt)("inlineCode",{parentName:"p"},"readMesh")," from the ",(0,l.kt)("inlineCode",{parentName:"p"},"MeshIO"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val mesh: TriangleMesh[_3D] = MeshIO.readMesh(new java.io.File("datasets/Paola.ply")).get\n')),(0,l.kt)("p",null,"In Scalismo, the show method of the ui object is used for visualization.\nIt's common to group different visualizations of an object.\nWe'll demonstrate this by creating a new group and adding our mesh to it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val paolaGroup = ui.createGroup("paola")\n  val meshView = ui.show(paolaGroup, mesh, "Paola")\n')),(0,l.kt)("p",null,'Once the mesh is rendered in the "Scalismo Viewer\'s 3D view", you can manipulate it in several ways:'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Rotate: Click and drag with the left mouse button."),(0,l.kt)("li",{parentName:"ul"},"Translate: Click and drag with the middle mouse button."),(0,l.kt)("li",{parentName:"ul"},"Scale: Click the right mouse button and drag up or down.")),(0,l.kt)("p",null,"Mac users should refer to their specific mouse or trackpad instructions to replicate these actions. Note that the RC, X, Y, and Z buttons in the 3D view can be used to recenter the camera on the object."),(0,l.kt)("h4",{id:"anatomy-of-a-triangle-mesh"},"Anatomy of a Triangle mesh"),(0,l.kt)("p",null,"A 3D Triangle Mesh in Scalismo is composed of a pointSet, a collection of 3D points,\nand a list of triangle cells. Individual points can be accessed via their point IDs.\nThe following code snippet demonstrates how to retrieve the first point in the mesh:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  println("first point " + mesh.pointSet.point(PointId(0)))\n')),(0,l.kt)("p",null,"Similarly, we can access the triangles using their IDs. Here's how you can get the first triangle:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  println("first cell " + mesh.triangulation.triangle(TriangleId(0)))\n')),(0,l.kt)("p",null,"The first cell is a triangle made up of the first, second, and third points of the mesh.\nIt's important to note that the cell refers to the identifiers of the points (their indices in the point sequence),\nnot their geometric positions."),(0,l.kt)("p",null,"We can visualize not just the mesh but also the individual points forming it:"),(0,l.kt)("p",null,"Instead of visualizing the mesh, we can also display the points forming the mesh."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val pointCloudView = ui.show(paolaGroup, mesh.pointSet, "pointCloud")\n')),(0,l.kt)("p",null,'Executing this will add a new element to the scene, a point cloud named "pointCloud".'),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: Be aware that visualizing the full point cloud might impact performance depending on your computer's specifications.")),(0,l.kt)("p",null,"For a neat and organized 3D scene, objects can be removed either directly from the user interface (by right-clicking the object's name) or programmatically by invoking remove on the corresponding view object:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  pointCloudView.remove()\n")),(0,l.kt)("h2",{id:"points-and-vectors"},"Points and Vectors"),(0,l.kt)("p",null,"Transformations of point sets are a common aspect of modelling in Scalismo. To understand how to manipulate point positions, we need to explore two fundamental classes: ",(0,l.kt)("inlineCode",{parentName:"p"},"Point")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"EuclideanVector"),"."),(0,l.kt)("p",null,"We define points by specifying their coordinates:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val p1: Point[_3D] = Point3D(4.0, 5.0, 6.0)\n  val p2: Point[_3D] = Point3D(1.0, 2.0, 3.0)\n")),(0,l.kt)("p",null,"The difference between two points is a ",(0,l.kt)("inlineCode",{parentName:"p"},"EuclideanVector")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val v1: EuclideanVector[_3D] = Point3D(4.0, 5.0, 6.0) - Point3D(1.0, 2.0, 3.0)\n")),(0,l.kt)("p",null,"Adding a point to a vector results in a new point:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val p3: Point[_3D] = p1 + v1\n")),(0,l.kt)("p",null,"A point can be converted into a vector:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val v2: EuclideanVector[_3D] = p1.toVector\n")),(0,l.kt)("p",null,"And a vector can be converted into a point:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val v3: Point[_3D] = v1.toPoint\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: The type of the expression is a parametric type ",(0,l.kt)("inlineCode",{parentName:"em"},"Point[_3D]"),", where the type parameter ",(0,l.kt)("inlineCode",{parentName:"em"},"_3D")," denotes the dimensionality. This pattern is consistent in Scalismo. The object constructor includes the dimensionality in its name (like ",(0,l.kt)("inlineCode",{parentName:"em"},"Point3D"),", ",(0,l.kt)("inlineCode",{parentName:"em"},"TriangleMesh3D"),"), and the returned Type is the parametric type (such as ",(0,l.kt)("inlineCode",{parentName:"em"},"Point[_3D]")," or ",(0,l.kt)("inlineCode",{parentName:"em"},"TriangleMesh[_3D]"),"). This system allows the creation of generic code that's independent of the objects' dimensionality.")),(0,l.kt)("p",null,"To illustrate these concepts, let's compute the center of mass for a sequence of points:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val pointList = Seq(\n      Point3D(4.0, 5.0, 6.0),\n      Point3D(1.0, 2.0, 3.0),\n      Point3D(14.0, 15.0, 16.0),\n      Point3D(7.0, 8.0, 9.0),\n      Point3D(10.0, 11.0, 12.0)\n    )\n")),(0,l.kt)("p",null,"In a first step, we treat all the points as displacement vectors (the displacement of the points from the origin)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val vectors = pointList.map { (p: Point[_3D]) => p - Point3D(0, 0, 0) } // use map to turn points into vectors\n")),(0,l.kt)("p",null,"Next, we compute the average displacement by averaging all the vectors:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val vectorSum = vectors.reduce { (v1, v2) => v1 + v2 } // sum up all vectors in the collection\n  val centerV: EuclideanVector[_3D] = vectorSum * (1.0 / pointList.length) // divide the sum by the number of points\n")),(0,l.kt)("p",null,"And finally we treat the average displacement again as a point in space."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val center = Point3D(0, 0, 0) + centerV\n")),(0,l.kt)("h2",{id:"scalar-images"},"Scalar Images"),(0,l.kt)("p",null,"In Scalismo, a discrete scalar image, such as a gray level image, is represented as a function mapping a discrete domain of points to a scalar value."),(0,l.kt)("p",null,"Let's read a 3D image (an MRI of a human head ) and display it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val image: DiscreteImage[_3D, Short] = ImageIO.read3DScalarImage[Short](File("datasets/PaolaMRI.vtk")).get\n  val imageView = ui.show(paolaGroup, image, "mri")\n')),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: Depending on your scene's viewpoint, it may initially appear as if the image isn't displaying. If that's the case, rotate the scene and adjust the slice positions as instructed below.")),(0,l.kt)("p",null,'To view different image slices in the viewer, select "Scene" (the top node in the scene tree graph) and use the X, Y, Z sliders.'),(0,l.kt)("p",null,"Furthermore, the visualization perspective for the 3D scene can be adjusted via the"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"View -> Perspective")," menu."),(0,l.kt)("h3",{id:"scalar-image-domain"},"Scalar Image domain"),(0,l.kt)("p",null,"As mentioned above, an image is a function defined on a (discrete) domain. In the case of an image,\nthe domain is defined by its origin (a point), the spacing between voxels, and the size (number of voxels). "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val origin: Point[_3D] = image.domain.origin\n  val spacing: EuclideanVector[_3D] = image.domain.spacing\n  val size: IntVector[_3D] = image.domain.size\n")),(0,l.kt)("h3",{id:"scalar-image-values"},"Scalar image values"),(0,l.kt)("p",null,"The other important part of a discrete image is the values associated with the domain points"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val values : Iterator[Short] = image.values\n")),(0,l.kt)("p",null,"This provides an iterator of scalar values of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Short"),", as encoded in the image we've read.\nNote that the choice of providing an iterator is deliberate. For large images, the number of\nvalues can be huge and it is often best, to consume them one by one instead of having all of\nthem in memory at the same time. "),(0,l.kt)("p",null,"Let's look at the first 10 values of the image:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  println(image.values.take(10).toSeq)\n")),(0,l.kt)("p",null,"The point ",(0,l.kt)("em",{parentName:"p"},"origin")," corresponds to the grid point with index (0,0,0). Hence, the same value can be obtained by accessing the image at this index :"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  image(IntVector3D(0,0,0))\n")),(0,l.kt)("p",null,"Naturally, the number of scalar values should be equal to the number of points"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  image.values.size == image.domain.pointSet.numberOfPoints\n")),(0,l.kt)("p",null,"Notice that you can check the intensity value at a particular point position in the image, by maintaining the Ctrl key pressed and hovering over the image. The intensity value will then be displayed in the lower left corner of the Scalismo viewer window."),(0,l.kt)("h3",{id:"creating-scalar-images"},"Creating scalar images"),(0,l.kt)("p",null,"Discrete scalar images are essentially a mapping between points and values. Therefore, we can generate such images programmatically."),(0,l.kt)("p",null,"In the following example, we'll create a new image defined on the same domain as the original image, but with artificially created values. We're going to apply a threshold to an MRI image, replacing all values above 300 with 0."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val threshValues = image.values.map { (v: Short) => if (v <= 300) v else 0.toShort }\n  val thresholdedImage: DiscreteImage[_3D, Short] = DiscreteImage3D[Short](image.domain, threshValues.toIndexedSeq)\n  ui.show(paolaGroup, thresholdedImage, "thresh")\n')),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: We need to write 0.toShort or 0 : Short in order to ensure that the ",(0,l.kt)("inlineCode",{parentName:"em"},"threshValues")," have type ",(0,l.kt)("inlineCode",{parentName:"em"},"Short")," and not ",(0,l.kt)("inlineCode",{parentName:"em"},"Int"),".")),(0,l.kt)("p",null,"There is, however, a more concise way to write the above code: using the map method. The map method applies an operation to all values. By using this method, we can simply write:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val thresholdedImage2 = image.map(v => if (v <= 300) v else 0.toShort)\n")),(0,l.kt)("h2",{id:"point-distribution-models"},"Point Distribution Models"),(0,l.kt)("p",null,"Finally, we look at Statistical Shape Models, which in Scalismo come in the form of Point Distribution Models (PDMs)."),(0,l.kt)("p",null,"PDMs can be read by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"readStatisticalTriangleMeshModel3D")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val faceModel: PointDistributionModel[_3D, TriangleMesh] = StatisticalModelIO.readStatisticalTriangleMeshModel3D(File("datasets/bfm.h5")).get\n  val faceModelView = ui.show(faceModel, "faceModel")\n')),(0,l.kt)("h3",{id:"sampling-in-the-ui"},"Sampling in the UI"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},'Exercise: Sample random instances of faces by using the graphical tools in the scene pane : click on the "model" tree node and then the "Random" button')),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},'Exercise: click a landmark on a position of the face model, e.g. chin or eye corner.. (use the toggle button "LM" in the toolbar to activate landmark clicking). Rename this landmark and call it '),"noseLM",(0,l.kt)("em",{parentName:"p"},". Now continue sampling from the model. What happens to the selected point?")),(0,l.kt)("p",null,'As you can see, a new instance of the face model is displayed each time along with the corresponding landmark point. Notice how the position of the landmark point changes in space while it keeps the same "meaning" on the face (eye corner, tip of nose ..)'),(0,l.kt)("h3",{id:"sampling-programmatically"},"Sampling programmatically"),(0,l.kt)("p",null,"Sampling in the ui is useful for getting a visual impression of the variability of a model. But more often we want to\nsample from a model programmatically. We can obtain a sample from the model, by calling the ",(0,l.kt)("inlineCode",{parentName:"p"},"sample method"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val randomFace: TriangleMesh[_3D] = faceModel.sample()\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exercise:")," Visualize a few randomly generated meshes in the ui."),(0,l.kt)("h5",{id:"retrieving-objects-from-scalismo-ui"},"Retrieving objects from Scalismo-ui"),(0,l.kt)("p",null,"This is a good opportunity to demonstrate how we can programmatically retrieve objects that were manually added in Scalismo-ui. A typical use case might be if we manually identified a landmark (like our noseLM) on one of the visualized objects and now we want to utilize it in our program. We can accomplish this using the filter method of the UI object, which operates as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'  val matchingLandmarkViews : Seq[LandmarkView] = ui.filter[LandmarkView](paolaGroup, (l : LandmarkView) => l.name == "noseLM")\n  val matchingLandmarks : Seq[Landmark[_3D]] = matchingLandmarkViews.map(lmView => lmView.landmark)\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"filter")," method is quite versatile. The type parameter (specified inside []) designates the type of view object we are looking for. In this case, we are only interested in landmarks, hence we specify the type ",(0,l.kt)("inlineCode",{parentName:"p"},"LandmarkView"),'. We pass the group where we want to search for an object as the first argument. The second argument is a predicate function that will be executed for all objects in the group of the correct type. Here, we instruct filter to match all objects with the name "noseLM". The filter method then returns a sequence of view objects that match this predicate. To obtain the corresponding Scalismo object, we call the landmark method on the view object. We can do this for all landmark view objects in the sequence using the familiar map function.'),(0,l.kt)("p",null,"Finally, we can retrieve the id and position of the matched landmark as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"  val landmarkId : String = matchingLandmarks.head.id\n  val landmarkPosition : Point[_3D] = matchingLandmarks.head.point\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: We can retrieve all other types of objects visualized in Scalismo-ui in exactly the same manner. This includes images, meshes, point clouds, etc.")),(0,l.kt)("h5",{id:"related-resources-1"},"Related resources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{target:"_blank",href:a(2487).Z},"Scala-code for this tutorial"))))}u.isMDXComponent=!0},2487:function(e,t,a){t.Z=a.p+"assets/files/Tutorial01-e51c7af286ca6a113f66d05b9dae0c7d.scala"}}]);