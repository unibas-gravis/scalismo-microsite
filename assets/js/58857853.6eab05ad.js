"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1840],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(a),d=i,h=p["".concat(l,".").concat(d)]||p[d]||m[d]||o;return a?n.createElement(h,r(r({ref:t},u),{},{components:a})):n.createElement(h,r({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1164:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return u},toc:function(){return m},default:function(){return d}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],s={slug:"pdms-images-scalismo-090",title:"Images in Scalismo 0.90",author:"Marcel L\xfcthi",author_title:"Lecturer, Department of Mathematics and Computer Science, University of Basel",author_url:"https://github.com/marcelluethi/",author_image_url:"https://avatars2.githubusercontent.com/u/1332115?s=400&u=85f196182f47120058b7ae6edd0a41151b77ceb7&v=4",tags:["scalismo","website"]},l=void 0,c={permalink:"/blog/pdms-images-scalismo-090",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2020-12-21-images-in-scalismo-090.md",source:"@site/blog/2020-12-21-images-in-scalismo-090.md",title:"Images in Scalismo 0.90",description:"Introduction",date:"2020-12-21T00:00:00.000Z",formattedDate:"December 21, 2020",tags:[{label:"scalismo",permalink:"/blog/tags/scalismo"},{label:"website",permalink:"/blog/tags/website"}],readingTime:5.65,truncated:!1,authors:[{name:"Marcel L\xfcthi",title:"Lecturer, Department of Mathematics and Computer Science, University of Basel",url:"https://github.com/marcelluethi/",imageURL:"https://avatars2.githubusercontent.com/u/1332115?s=400&u=85f196182f47120058b7ae6edd0a41151b77ceb7&v=4"}],frontMatter:{slug:"pdms-images-scalismo-090",title:"Images in Scalismo 0.90",author:"Marcel L\xfcthi",author_title:"Lecturer, Department of Mathematics and Computer Science, University of Basel",author_url:"https://github.com/marcelluethi/",author_image_url:"https://avatars2.githubusercontent.com/u/1332115?s=400&u=85f196182f47120058b7ae6edd0a41151b77ceb7&v=4",tags:["scalismo","website"]},prevItem:{title:"MDX Blog Post",permalink:"/blog/mdx-blog-post"},nextItem:{title:"Point Distribution Models in Scalismo 0.90",permalink:"/blog/pdms-scalismo-090"}},u={authorsImageUrls:[void 0]},m=[{value:"Introduction",id:"introduction",children:[],level:3},{value:"Continuous and discrete Images",id:"continuous-and-discrete-images",children:[],level:3},{value:"Structured Points",id:"structured-points",children:[],level:3},{value:"Image domain",id:"image-domain",children:[],level:3},{value:"Creating images",id:"creating-images",children:[],level:3},{value:"Interpolation and discretization.",id:"interpolation-and-discretization",children:[],level:3},{value:"Summary",id:"summary",children:[],level:3}],p={toc:m};function d(e){var t=e.components,a=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"The recently released version of Scalismo - version 0.90 - comes with a number of important changes in its\ncore classes. In this blog post, we will look at images. "),(0,o.kt)("p",null,"In older versions of Scalismo images had a special status in the library. While conceptually they were thought to be just discrete fields, they were implemented using a number of special classes, representing the differnet types of images.\nThis led to inconsistencies in the\nAPI and complicated the type hierarchy. Even worse, it enforced the wrong notion that image are conceptually different from other representations of\nintensities used in Scalismo. In version 0.90 we cleaned up the hierarchy and removed all the special classes. Discrete images are now simply a special instantiation of a discrete field, whose\ndomain is a regular grid. In the following we explain the underlying concepts, show how we can create images and how\nwe can obtain a continuous from a discrete representations and vice versa."),(0,o.kt)("h3",{id:"continuous-and-discrete-images"},"Continuous and discrete Images"),(0,o.kt)("p",null,"Similar to other types of representations, images come in two types: Discrete images and continuous images.\nContinuous images are modeled as a ",(0,o.kt)("inlineCode",{parentName:"p"},"Field"),"; I.e. they are functions that have a domain $$D \\subset \\mathbb{R}^d$$ and\nmap each point of the domain to some values. The mapped values can be scalars, vectors or even more complicated objects."),(0,o.kt)("p",null,"Discrete images in turn are a special case of a discrete field. Discrete fields are defined as a finite set of points, where for each point we have an associated value.\nA discrete image is a discrete field, whose domain is constrained to be a regular grid; I.e. whose domain points are equally spaced. That the points are equally spaces makes\nit possible to represent the domain points implicitly by a mathematical formula rather than having to explicitly store them.\nFurthermore, accessing the image values and looking up closest points becomes a constant time operation."),(0,o.kt)("h3",{id:"structured-points"},"Structured Points"),(0,o.kt)("p",null,"The basic object to represent such a set of structured points is the class ",(0,o.kt)("inlineCode",{parentName:"p"},"StructuredPoints"),".\nWe can create a set of points on a grid as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val origin = Point3D(10.0, 15.0, 7.0) // some point defining the lower left corner of the image\nval spacing = EuclideanVector3D(0.1, 0.1, 0.1) // the spacing between two grid points in each space dimension\nval size = IntVector3D(32, 64, 92) // size in each space dimension\nval points = StructuredPoints3D(origin, spacing, size)\n")),(0,o.kt)("p",null,"This creates a grid of points $$32 \\times 64 \\times 92$$ points, where the bottom left point is at the ",(0,o.kt)("inlineCode",{parentName:"p"},"origin"),",\nand the points are the in the $$x, y, z$$ direction $$0.1mm$$ apart."),(0,o.kt)("p",null,"Note that the grid of points is aligned to the coordinate axis. In case you would like to have a different\nalignment, it is possible to specify a rotation of the points. The rotation is specified by 1 or 3 Euler angles,\ndepending on whether there is a 2 or 3 dimensional image."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val yaw = Math.PI / 2\nval pitch = 0.0\nval roll = Math.PI\nval points2 = StructuredPoints3D(origin, spacing, size, yaw, pitch, roll)\n")),(0,o.kt)("h3",{id:"image-domain"},"Image domain"),(0,o.kt)("p",null,"The image domain represents a domain, whose points are aligned in a rectangular grid.\nNaturally, it uses ",(0,o.kt)("inlineCode",{parentName:"p"},"StructuredPoints")," as a representation of the underlying points of the\ndomain. We can create an image domain from structured points as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val imageDomain = DiscreteImageDomain3D(StructuredPoints3D(origin, spacing, size))\n")),(0,o.kt)("p",null,"For convenience, Scalismo also offers the possibility to specify the origin, spacing and size directly, as we did\nfor the structured points."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val imageDomain2 = DiscreteImageDomain3D(origin, spacing, size)\n")),(0,o.kt)("p",null,"Note however, that this still creates a structured points object internally."),(0,o.kt)("p",null,"As for structured points, we can also define a rotation, by specifying the corresponding\nEuler angles."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val imageDomain3 = DiscreteImageDomain3D(origin, spacing, size, yaw, pitch, roll)\n")),(0,o.kt)("p",null,"Finally, we can specify the points by specifying its bounding box together with the information about the spacing or size:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val boundingBox : BoxDomain[_3D] = imageDomain.boundingBox\nval imageDomain4 = DiscreteImageDomain3D(boundingBox, spacing = spacing)\n")),(0,o.kt)("p",null,"or"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val imageDomain5 = DiscreteImageDomain3D(boundingBox, size = size)\n")),(0,o.kt)("p",null,"This last creation method is particularly useful for changing the resolution of an image,\nas we will see later."),(0,o.kt)("h3",{id:"creating-images"},"Creating images"),(0,o.kt)("p",null,"To create an image, we need to specify a value for each\npoint in the domain. In this example, we create an image, which assigns a zero value to each point."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val image = DiscreteImage3D(imageDomain, p => 0.toShort)\n")),(0,o.kt)("p",null,"Alternatively, we could have specified the values using an array, as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val image2 = DiscreteImage3D(imageDomain, Array.fill(imageDomain.pointSet.numberOfPoints)(0.toShort))\n")),(0,o.kt)("p",null,"Note that an image is just another name for a discrete field with a image domain. We could\nhave equally well constructed the image as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val image3 = DiscreteField3D(imageDomain, p => 0.toShort)\n")),(0,o.kt)("h3",{id:"interpolation-and-discretization"},"Interpolation and discretization."),(0,o.kt)("p",null,"It is often more convenient to work with a continuous representation of the image.\nTo obtain a continuous image, we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"interpolate")," method and specify a suitable\ninterpolator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val continuousImage : Field[_3D, Short] = image.interpolate(BSplineImageInterpolator3D(degree = 3))\n")),(0,o.kt)("p",null,"The resulting object is defined on all the points within the bounding box of the image domain.\nTo go back to a discrete representation, we can specify a new image domain and use the\n",(0,o.kt)("inlineCode",{parentName:"p"},"discretize")," method. As the new domain could be bigger than the domain of the continuous image,\nwe need to specify a value that is assigned to the points, which fall outside this domain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val newDomain = DiscreteImageDomain3D(image.domain.boundingBox, size=IntVector(32, 32, 32))\nval resampledImage : DiscreteImage[_3D, Short] = continuousImage.discretize(newDomain, outsideValue = 0.toShort)\n")),(0,o.kt)("p",null,"Of course, we could also resample the continuous image using a different type of domain. Assume for example that we\nhave a CT image of the upper leg, but we are only interested in representing the intensities for the femur bone. We could then\ndiscretize the (interpolated) image using a tetrahederal mesh, and thus obtain a representation of the field which is restricted\nto the femur bone only. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val femurMesh : TetrahedralMesh[_3D] = ???\nval femurVolumeMeshModel : DiscreteField[_3D, TetrahedralMesh, Short] = continuousImage.discretize(femurMesh)\n")),(0,o.kt)("h3",{id:"summary"},"Summary"),(0,o.kt)("p",null,"We have discussed the new design of images in Scalismo. Discrete images are modelled as discrete fields, and thus have a domain and\nassociated values attached to it. The points of the domain are represented using the class ",(0,o.kt)("inlineCode",{parentName:"p"},"StructuredPoints"),", which\nrepresent points that lie on a regular grid. Exploiting this special structure, we can efficiently access values\nassociated to the grid points in the image, or use dedicated interpolation methods to swich from a discrete to a\ncontinuous representation. Once we have the continuous representation, we can discretize using a different domain, which\nallows us for example to resample the image in a different resolution, restrict the image to a part of the domain or even change the\ntype of the domain."))}d.isMDXComponent=!0}}]);