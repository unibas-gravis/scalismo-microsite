"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6767],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||p[u]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var m=2;m<r;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7379:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return c},default:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],s={id:"tutorial03",title:"From meshes to deformation fields"},l=void 0,m={unversionedId:"Tutorials/tutorial03",id:"version-0.92/Tutorials/tutorial03",title:"From meshes to deformation fields",description:"This tutorial aims to demonstrate the process of computing and visualizing the deformation field that represent the shape differences between two meshes.",source:"@site/versioned_docs/version-0.92/Tutorials/tutorial03.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial03",permalink:"/docs/Tutorials/tutorial03",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.92/Tutorials/tutorial03.md",tags:[],version:"0.92",frontMatter:{id:"tutorial03",title:"From meshes to deformation fields"},sidebar:"docs",previous:{title:"Rigid Alignment",permalink:"/docs/Tutorials/tutorial02"},next:{title:"Gaussian processes and Point Distribution Models",permalink:"/docs/Tutorials/tutorial04"}},c=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Representing meshes as deformations",id:"representing-meshes-as-deformations",children:[],level:3},{value:"Deformation fields over continuous domains:",id:"deformation-fields-over-continuous-domains",children:[],level:3},{value:"The mean deformation and the mean mesh",id:"the-mean-deformation-and-the-mean-mesh",children:[],level:3}],p={toc:c};function d(e){var t=e.components,s=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This tutorial aims to demonstrate the process of computing and visualizing the deformation field that represent the shape differences between two meshes. "),(0,r.kt)("h5",{id:"related-resources"},"Related resources"),(0,r.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,r.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Modelling Shape Deformations ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250326"},"(Video)"))),(0,r.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:n(1740).Z},"Tutorial03.scala"))),(0,r.kt)("h5",{id:"preparation"},"Preparation"),(0,r.kt)("p",null,"Similar to the prior tutorials, our first step involves importing frequently utilized objects and initializing the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry.*\nimport scalismo.common.*\nimport scalismo.transformations.*\nimport scalismo.common.interpolation.*\nimport scalismo.ui.api.*\nimport scalismo.io.MeshIO\nimport scalismo.mesh.TriangleMesh\n\nimport java.io.File\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  scalismo.initialize()\n\n  val ui = ScalismoUI()\n")),(0,r.kt)("p",null,"Let's read a number of meshes and visualize them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'\n  val dsGroup = ui.createGroup("datasets")\n\n  val meshFiles = new File("datasets/testFaces/").listFiles.take(3) // take first 3 files\n  val (meshes, meshViews) = meshFiles.map(meshFile => {\n    val mesh = MeshIO.readMesh(meshFile).get // load mesh\n    val meshView = ui.show(dsGroup, mesh, "mesh") // visualize it\n    (mesh, meshView) // return a tuple of the mesh and the associated view\n  }).unzip // take the tuples apart, to get a sequence of meshes and one of meshViews\n')),(0,r.kt)("h3",{id:"representing-meshes-as-deformations"},"Representing meshes as deformations"),(0,r.kt)("p",null,"In the following we show how we can represent a mesh as a reference mesh plus a deformation field. This is possible\nbecause the meshes are all in correspondence; I.e. they all have the same number of points and points with the same id in the meshes represent\nthe same point/region in the mesh."),(0,r.kt)("p",null,"We consider the first mesh as the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val reference = meshes.head \n")),(0,r.kt)("p",null,"Given that a mesh is in correspondence with this reference, it can be expressed as a deformation field.\nThis deformation field is defined on the reference mesh, implying that the points of the reference mesh\nrepresent the domain on which the deformation field is formulated."),(0,r.kt)("p",null,"The deformations can be computed by taking the difference between the corresponding\npoint of the mesh and the reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val deformations : IndexedSeq[EuclideanVector[_3D]] =\n    reference.pointSet.pointIds.map (\n        id =>  meshes(1).pointSet.point(id) - reference.pointSet.point(id)\n    ).toIndexedSeq\n")),(0,r.kt)("p",null,"From these deformations, we can then create a ",(0,r.kt)("inlineCode",{parentName:"p"},"DiscreteVectorField"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val deformationField: DiscreteField[_3D, TriangleMesh, EuclideanVector[_3D]] = DiscreteField3D(reference, deformations)\n")),(0,r.kt)("p",null,"Similar to images, the deformation vector corresponding to a specific point id in a ",(0,r.kt)("em",{parentName:"p"},"DiscreteVectorField")," can be retrieved through its point id:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  deformationField(PointId(0))\n")),(0,r.kt)("p",null,"In Scalismo-ui, this deformation field can be visualized using the standard show command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  val deformationFieldView = ui.show(dsGroup, deformationField, "deformations")\n')),(0,r.kt)("p",null,"The visualization reveals that the deformation vectors indeed point from the reference to face_1.\nTo enhance this effect, we must remove face2 from the UI and make the reference transparent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  meshViews(2).remove()\n  meshViews(0).opacity = 0.3\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Exercise: generate the rest of the deformation fields that represent the rest of the faces in the dataset and display them.")),(0,r.kt)("h3",{id:"deformation-fields-over-continuous-domains"},"Deformation fields over continuous domains:"),(0,r.kt)("p",null,"The deformation field calculated in the previous section is discrete, as it is only defined over the mesh points.\nConsidering that the real-world objects we are modelling are continuous, and the discretization of our meshes is relatively arbitrary, this is not ideal.\nIn Scalismo, we prefer working with continuous domains. When we have an object in Scalismo defined on a discrete domain,\nwe can achieve a continuous representation by using interpolation."),(0,r.kt)("p",null,"To convert our deformation field into a continuous deformation field, we need to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Interpolator")," and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"interpolate")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\n  val continuousDeformationField : Field[_3D, EuclideanVector[_3D]] = deformationField.interpolate(interpolator)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TriangleMeshInterpolator")," utilized here identifies the nearest point on the surface for each point in Euclidean space and uses the corresponding deformation as the deformation at that point.\nThe point on the surface is obtained through barycentric interpolation of the corresponding vertex points.\nAs a result of the interpolation, we get a deformation field over the entire real space, which can be evaluated at any 3D point:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  continuousDeformationField(Point3D(-100,-100,-100))\n")),(0,r.kt)("p",null,"Note: This method is general and any discrete object in Scalismo can be interpolated. All objects defined on discrete domains support interpolation using the ",(0,r.kt)("inlineCode",{parentName:"p"},"NearestNeighborInterpolator"),".\nFor most domains, however, more specialized interpolators are defined. For instance, to interpolate an image, we can use efficient linear or b-spline interpolation schemes."),(0,r.kt)("h3",{id:"the-mean-deformation-and-the-mean-mesh"},"The mean deformation and the mean mesh"),(0,r.kt)("p",null,"The mean shape of a set of meshes often needs to be computed in shape analysis.\nThis is equivalent to calculating the mean deformation, denoted as ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mstyle",{parentName:"mrow",mathcolor:"#cc0000"},(0,r.kt)("mtext",{parentName:"mstyle"},"\\overine")),(0,r.kt)("mi",{parentName:"mrow"},"u")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\overine{u}")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord text",style:{color:"#cc0000"}},(0,r.kt)("span",{parentName:"span",className:"mord",style:{color:"#cc0000"}},"\\overine")),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"u")))))),", and applying this deformation to the mean mesh."),(0,r.kt)("p",null,"Let's compute the mean deformation. We achieve this by calculating the sample mean of the deformations at each point in our deformation fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\n  val nMeshes = meshes.length\n  val meanDeformations = reference.pointSet.pointIds.map(id => {\n\n    val deformationsForId = meshes.map(mesh => { // loop through meshes\n      (mesh.pointSet.point(id) - reference.pointSet.point(id)) * (1.0 / nMeshes)\n    })\n    deformationsForId.reduce(_ + _) // sum the deformations\n  })\n\n  val meanDeformationField = DiscreteField3D(reference, meanDeformations.toIndexedSeq)\n")),(0,r.kt)("p",null,"To create the mean mesh, we apply the deformation to each point of the reference mesh.\nWe achieve this by first generating a transformation from the deformation field, which can then be used to map every point of the reference to its mean position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val continuousMeanDeformationField = meanDeformationField.interpolate(TriangleMeshInterpolator3D())\n  val meanTransformation = Transformation((pt : Point[_3D]) => pt + continuousMeanDeformationField(pt))\n")),(0,r.kt)("p",null,"To get the mean mesh, we simply apply this transformation to the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  val meanMesh = reference.transform(meanTransformation)\n")),(0,r.kt)("p",null,"Finally, we display the result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'  ui.show(dsGroup, meanMesh, "mean mesh")\n')))}d.isMDXComponent=!0},1740:function(e,t,n){t.Z=n.p+"assets/files/Tutorial03-6e5eb8c5fe45790c82bb8a34cb53a093.scala"}}]);