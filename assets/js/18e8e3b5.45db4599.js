"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4393],{3905:function(e,t,o){o.d(t,{Zo:function(){return p},kt:function(){return m}});var a=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function s(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,a,r=function(e,t){if(null==e)return{};var o,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):s(s({},t),e)),o},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var o=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(o),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||n;return o?a.createElement(h,s(s({ref:t},p),{},{components:o})):a.createElement(h,s({ref:t},p))}));function m(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=o.length,s=new Array(n);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<n;c++)s[c]=o[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,o)}d.displayName="MDXCreateElement"},5514:function(e,t,o){o.r(t),o.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=o(7462),r=o(3366),n=(o(7294),o(3905)),s=["components"],i={id:"tutorial08",title:"Posterior shape models"},l=void 0,c={unversionedId:"Tutorials/tutorial08",id:"Tutorials/tutorial08",title:"Posterior shape models",description:"In this tutorial we will use Gaussian processes for regression tasks and experiment with the concept of posterior shape models.",source:"@site/docs/Tutorials/tutorial08.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial08",permalink:"/docs/next/Tutorials/tutorial08",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial08.md",tags:[],version:"current",frontMatter:{id:"tutorial08",title:"Posterior shape models"},sidebar:"docs",previous:{title:"Shape modelling with Gaussian processes and kernels",permalink:"/docs/next/Tutorials/tutorial07"},next:{title:"Shape completion using GP regression",permalink:"/docs/next/Tutorials/tutorial09"}},p=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Fitting observed data using Gaussian process regression",id:"fitting-observed-data-using-gaussian-process-regression",children:[{value:"Posterior of a StatisticalMeshModel:",id:"posterior-of-a-statisticalmeshmodel",children:[{value:"Landmark uncertainty:",id:"landmark-uncertainty",children:[],level:4}],level:3}],level:2}],u={toc:p};function d(e){var t=e.components,i=(0,r.Z)(e,s);return(0,n.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"In this tutorial we will use Gaussian processes for regression tasks and experiment with the concept of posterior shape models.\nThis will form the basics for the next tutorial, where we will see how these tools\ncan be applied to construct a reconstruction of partial shapes."),(0,n.kt)("h5",{id:"related-resources"},"Related resources"),(0,n.kt)("p",null,"To enhance your understanding of this tutorial, we recommend the following resources from our ",(0,n.kt)("a",{parentName:"p",href:"https://shapemodelling.cs.unibas.ch/ssm-course/"},"online course"),":"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The regression problem ",(0,n.kt)("a",{parentName:"li",href:"https://shapemodelling.cs.unibas.ch/ssm-course/week5/step5-2"},"(Article)")),(0,n.kt)("li",{parentName:"ul"},"Gaussian process regression ",(0,n.kt)("a",{parentName:"li",href:"https://shapemodelling.cs.unibas.ch/ssm-course/week5/step5-3"},"(Video)")),(0,n.kt)("li",{parentName:"ul"},"Posterior models for different kernels ",(0,n.kt)("a",{parentName:"li",href:"https://shapemodelling.cs.unibas.ch/ssm-course/week5/step5-4"},"(Article)"))),(0,n.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{target:"_blank",href:o(7906).Z},"Tutorial08.scala"))),(0,n.kt)("h5",{id:"preparation"},"Preparation"),(0,n.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry.*\nimport scalismo.common.*\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.mesh.*\nimport scalismo.io.{StatisticalModelIO, MeshIO}\nimport scalismo.statisticalmodel.*\nimport scalismo.numerics.UniformMeshSampler3D\nimport scalismo.kernels.*\n\nimport scalismo.ui.api.*\n\nimport java.io.File\n\nimport breeze.linalg.{DenseMatrix, DenseVector}\n\nimport scalismo.utils.Random.FixedSeed.randBasis\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    scalismo.initialize()\n\n    val ui = ScalismoUI()\n")),(0,n.kt)("p",null,"We also load and visualize the face model:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'    val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(File("datasets/bfm.h5")).get\n\n    val modelGroup = ui.createGroup("modelGroup")\n    val ssmView = ui.show(modelGroup, model, "model")\n')),(0,n.kt)("h2",{id:"fitting-observed-data-using-gaussian-process-regression"},"Fitting observed data using Gaussian process regression"),(0,n.kt)("p",null,"The purpose of constructing statistical models is to utilize them for interpreting data.\nMore precisely, given some observed data, we fit the model\nto the data and get as a result a distribution over the model parameters.\nIn this scenario, our model represents a Gaussian process model of shape deformations,\nand the data represents observed shape deformations, i.e., deformation vectors from the reference surface."),(0,n.kt)("p",null,"To illustrate this, let's simulate some data.\nWe'll generate a deformation vector at the tip of the nose, mimicking a significantly elongated nose:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    val idNoseTip = PointId(8156)\n    val noseTipReference = model.reference.pointSet.point(idNoseTip)\n    val noseTipMean = model.mean.pointSet.point(idNoseTip)\n    val noseTipDeformation = (noseTipReference - noseTipMean) * 2.0\n")),(0,n.kt)("p",null,"To visualize this deformation, we'll have to define a ",(0,n.kt)("inlineCode",{parentName:"p"},"DiscreteField")," which can then be\npassed to the show method of our ui object:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'    val noseTipDomain = UnstructuredPointsDomain3D(IndexedSeq(noseTipReference))\n    val noseTipDeformationField = DiscreteField3D(noseTipDomain,  IndexedSeq(noseTipDeformation))\n\n    val observationGroup = ui.createGroup("observation")\n    ui.show(observationGroup, noseTipDeformationField, "noseTip")\n')),(0,n.kt)("p",null,"Now let's set up the regression. The Gaussian process model assumes that the deformation is only observed up to some level of uncertainty, which can be modeled using a normal distribution:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    val noise = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3))\n")),(0,n.kt)("p",null,"In Scalismo, the data for regression is specified by a sequence of triples, consisting of the point of the reference, the corresponding deformation vector, and the noise at that point:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    val regressionData = IndexedSeq((noseTipReference, noseTipDeformation, noise))\n")),(0,n.kt)("p",null,"The regression result can be obtained by feeding this data to the regression method of the ",(0,n.kt)("inlineCode",{parentName:"p"},"GaussianProcess")," object:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    val gp : LowRankGaussianProcess[_3D, EuclideanVector[_3D]] = model.gp.interpolate(TriangleMeshInterpolator3D())\n    val posteriorGP : LowRankGaussianProcess[_3D, EuclideanVector[_3D]] = LowRankGaussianProcess.regression(gp, regressionData)\n")),(0,n.kt)("p",null,"The regression result is a Gaussian process over the same domain as the original process,\ntermed the posterior process. This setup is of crucial importance in Scalismo, leading to a convenience method defined directly on the Gaussian process object, allowing us to write the same in a more succinct manner:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    gp.posterior(regressionData)\n")),(0,n.kt)("p",null,"Regardless of how we invoke the method, the returned type is a continuous (low rank) Gaussian Process from which we can now sample deformations at any set of points:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'    val posteriorSample: DiscreteField[_3D, TriangleMesh, EuclideanVector[_3D]] =\n        posteriorGP.sampleAtPoints(model.reference)\n    \n    val posteriorSampleGroup = ui.createGroup("posteriorSamples")\n\n    for (i <- 0 until 10) do\n        ui.show(posteriorSampleGroup, posteriorSample, "posteriorSample")\n')),(0,n.kt)("h3",{id:"posterior-of-a-statisticalmeshmodel"},"Posterior of a StatisticalMeshModel:"),(0,n.kt)("p",null,"As the StatisticalMeshModel is essentially a wrapper around a Gaussian Process (GP), the same posterior functionality is available for statistical mesh models:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"    val littleNoise = MultivariateNormalDistribution(\n        DenseVector.zeros[Double](3), \n        DenseMatrix.eye[Double](3) * 0.01\n        )\n    val pointOnLargeNose = noseTipReference + noseTipDeformation\n    val discreteTrainingData = IndexedSeq((PointId(8156), pointOnLargeNose, littleNoise))\n    val meshModelPosterior: PointDistributionModel[_3D, TriangleMesh] = model.posterior(discreteTrainingData)\n")),(0,n.kt)("p",null,"Notice in this case, since we are working with a discrete Gaussian process, the observed data is specified in terms of the ",(0,n.kt)("em",{parentName:"p"},"point identifier")," of the nose tip point instead of its 3D coordinates."),(0,n.kt)("p",null,"Let's visualize the obtained posterior model:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'    val posteriorModelGroup = ui.createGroup("posteriorModel")\n    ui.show(posteriorModelGroup, meshModelPosterior, "NoseyModel")\n')),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Exercise: sample a few random faces from the graphical interface using the random button. Notice how all faces display large noses :) with the tip of the nose remaining close to the selected landmark.")),(0,n.kt)("p",null,"What we have here is far more than just a single face instance that fits the input data: we have a full normal distribution of shapes that accommodate the observation. The most probable shape, and hence our best fit, is the mean of the posterior."),(0,n.kt)("p",null,"Upon sampling from the posterior model, we tend to get faces with rather large noses. This is because we chose our observation to be twice the length of the average (mean) deformation at the tip of the nose."),(0,n.kt)("h4",{id:"landmark-uncertainty"},"Landmark uncertainty:"),(0,n.kt)("p",null,"When specifying the training data for the computation of the posterior GP, we model the uncertainty of the input data. The variance of this noise model greatly influences the resulting posterior distribution. It should always be chosen so that it closely aligns with the real uncertainty of our observation."),(0,n.kt)("p",null,"To illustrate how this variance influences the posterior, let's perform the posterior computation again, but this time with a noise variance that is 5 times bigger."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'    val largeNoise = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * 5.0)\n    val discreteTrainingDataLargeNoise = IndexedSeq((PointId(8156), pointOnLargeNose, largeNoise))\n    val discretePosteriorLargeNoise = model.posterior(discreteTrainingDataLargeNoise)\n    val posteriorGroupLargeNoise = ui.createGroup("posteriorLargeNoise")\n    ui.show(posteriorGroupLargeNoise, discretePosteriorLargeNoise, "NoisyNoseyModel")\n')),(0,n.kt)("p",null,"We observe, that there is now much more variance left in this posterior process.\nThis is a consequence of the larger uncertainty that was associated with the\nobserved data."))}d.isMDXComponent=!0},7906:function(e,t,o){t.Z=o.p+"assets/files/Tutorial08-be1f05061e072d1869128f8ac5cfb2c7.scala"}}]);