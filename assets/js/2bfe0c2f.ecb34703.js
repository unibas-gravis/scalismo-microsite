"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9068],{3905:function(e,a,t){t.d(a,{Zo:function(){return o},kt:function(){return h}});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function m(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=n.createContext({}),p=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):m(m({},a),e)),t},o=function(e){var a=p(e.components);return n.createElement(i.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),u=p(t),h=s,k=u["".concat(i,".").concat(h)]||u[h]||c[h]||r;return t?n.createElement(k,m(m({ref:a},o),{},{components:t})):n.createElement(k,m({ref:a},o))}));function h(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=t.length,m=new Array(r);m[0]=u;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l.mdxType="string"==typeof e?e:s,m[1]=l;for(var p=2;p<r;p++)m[p]=t[p];return n.createElement.apply(null,m)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1033:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return p},toc:function(){return o},default:function(){return u}});var n=t(7462),s=t(3366),r=(t(7294),t(3905)),m=["components"],l={id:"tutorial07",title:"Shape modelling with Gaussian processes and kernels"},i=void 0,p={unversionedId:"Tutorials/tutorial07",id:"Tutorials/tutorial07",title:"Shape modelling with Gaussian processes and kernels",description:"In this tutorial we learn how to define our own Gaussian processes using analytically",source:"@site/docs/Tutorials/tutorial07.md",sourceDirName:"Tutorials",slug:"/Tutorials/tutorial07",permalink:"/docs/next/Tutorials/tutorial07",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial07.md",tags:[],version:"current",frontMatter:{id:"tutorial07",title:"Shape modelling with Gaussian processes and kernels"},sidebar:"docs",previous:{title:"Building a shape model from data",permalink:"/docs/next/Tutorials/tutorial06"},next:{title:"Posterior shape models",permalink:"/docs/next/Tutorials/tutorial08"}},o=[{value:"Related resources",id:"related-resources",children:[],level:5},{value:"Preparation",id:"preparation",children:[],level:5},{value:"Modelling deformations using Gaussian processes:",id:"modelling-deformations-using-gaussian-processes",children:[{value:"The mean:",id:"the-mean",children:[],level:5},{value:"The covariance function:",id:"the-covariance-function",children:[],level:5},{value:"Building the GP :",id:"building-the-gp-",children:[],level:5},{value:"Low-rank approximation",id:"low-rank-approximation",children:[],level:4},{value:"Building more interesting kernels",id:"building-more-interesting-kernels",children:[{value:"Kernels from Statistical Shape Models",id:"kernels-from-statistical-shape-models",children:[],level:4},{value:"Changepoint kernel:",id:"changepoint-kernel",children:[],level:4},{value:"Symmetrizing a kernel",id:"symmetrizing-a-kernel",children:[],level:4}],level:3}],level:2}],c={toc:o};function u(e){var a=e.components,l=(0,s.Z)(e,m);return(0,r.kt)("wrapper",(0,n.Z)({},c,l,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial we learn how to define our own Gaussian processes using analytically\ndefined kernels. Further, we experiment with different kernels that are useful in\nshape modelling."),(0,r.kt)("h5",{id:"related-resources"},"Related resources"),(0,r.kt)("p",null,"The following resources from our ",(0,r.kt)("a",{parentName:"p",href:"https://www.futurelearn.com/courses/statistical-shape-modelling"},"online course")," may provide\nsome helpful context for this tutorial:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Covariance functions ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250350"},"(Video)")),(0,r.kt)("li",{parentName:"ul"},"Constructing kernels for shape modelling ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250351"},"(Article)")),(0,r.kt)("li",{parentName:"ul"},"Enlarging the flexibility of statistical shape models ",(0,r.kt)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250357"},"(Article)"))),(0,r.kt)("p",null,"To run the code from this tutorial, download the following Scala file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:t(6222).Z},"Tutorial07.scala"))),(0,r.kt)("h5",{id:"preparation"},"Preparation"),(0,r.kt)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry._\nimport scalismo.common._\nimport scalismo.common.interpolation.TriangleMeshInterpolator3D\nimport scalismo.mesh._\nimport scalismo.io.{StatisticalModelIO, MeshIO}\nimport scalismo.statisticalmodel._\nimport scalismo.numerics.UniformMeshSampler3D\nimport scalismo.kernels._\n\nimport scalismo.ui.api._\n\nimport breeze.linalg.{DenseMatrix, DenseVector}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"scalismo.initialize()\nimplicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)\n\nval ui = ScalismoUI()\n")),(0,r.kt)("p",null,"In the following we will always visualize the effect of different Gaussian process models,\nby applying the deformations to a reference mesh. We therefore start by loading the mesh and visualizing\nit in a separate group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val referenceMesh = MeshIO.readMesh(new java.io.File("datasets/lowResPaola.ply")).get\n\nval modelGroup = ui.createGroup("gp-model")\nval referenceView = ui.show(modelGroup, referenceMesh, "reference")\n')),(0,r.kt)("h2",{id:"modelling-deformations-using-gaussian-processes"},"Modelling deformations using Gaussian processes:"),(0,r.kt)("p",null,"A Gaussian Process is defined by two components: the ",(0,r.kt)("strong",{parentName:"p"},"mean function")," and the ",(0,r.kt)("strong",{parentName:"p"},"covariance function"),"."),(0,r.kt)("h5",{id:"the-mean"},"The mean:"),(0,r.kt)("p",null,"As we are modelling deformation fields, the mean of the Gaussian process will, of course, itself be a deformation field.\nIn terms of shape models, we can think of the mean function as the deformation field that deforms our reference mesh into the mean shape."),(0,r.kt)("p",null,"If the reference shape that we choose corresponds approximately to an average shape, and we do not have any further knowledge\nabout our shape space, it is entirely reasonable to use a zero mean; I.e. a deformation field which applies to\nevery point a zero deformation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val zeroMean = Field(EuclideanSpace3D, (pt:Point[_3D]) => EuclideanVector3D(0,0,0))\n")),(0,r.kt)("h5",{id:"the-covariance-function"},"The covariance function:"),(0,r.kt)("p",null,"The covariance function, which is also referred to as a ",(0,r.kt)("em",{parentName:"p"},"kernel"),",\ndefines the properties that characterize likely deformations in our model.\nFormally, it is a symmetric, positive semi-definite function,\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"k"),(0,r.kt)("mo",{parentName:"mrow"},":"),(0,r.kt)("mi",{parentName:"mrow"},"X"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"X"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"R"),(0,r.kt)("mrow",{parentName:"msup"},(0,r.kt)("mi",{parentName:"mrow"},"d"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"d")))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k: X \\times X \\to R^{ d \\times d}")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},":"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8491079999999999em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.00773em"}},"R"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8491079999999999em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"d"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"d"))))))))))))),", which defines the covariance between the\nvalues at any pair of points ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"x"),(0,r.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x, x'")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.946332em",verticalAlign:"-0.19444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.751892em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032")))))))))))))," of the domain. Since we are modelling deformation\nfields (I.e. vector-valued functions), the covariance function is matrix-valued."),(0,r.kt)("p",null,"To define a kernel in Scalismo, we need to implement the following methods of the abstract class ",(0,r.kt)("inlineCode",{parentName:"p"},"MatrixValuedPDKernel"),", which is defined in Scalismo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"abstract class MatrixValuedPDKernel[D]() {\n\n    def outputDim: Int;\n    def domain: Domain[D];\n    def k(x: Point[D], y: Point[D]): DenseMatrix[Double];\n  }\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: This class is already defined as part of Scalismo. Don't paste it into your code.")),(0,r.kt)("p",null,"The field ",(0,r.kt)("inlineCode",{parentName:"p"},"outputDim")," determines the dimensionality of the values we model. In our case, we model 3D vectors, and hence ",(0,r.kt)("inlineCode",{parentName:"p"},"outputDim"),"should be 3.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"domain")," indicates the set of points on which our kernel is defined. Most often, we set this to the entire Euclidean space ",(0,r.kt)("inlineCode",{parentName:"p"},"RealSpace3D"),".\nFinally ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," denotes the covariance function."),(0,r.kt)("p",null,"The most often used kernel is the Gaussian kernel. Recall that the scalar-valued Gaussian kernel, is defined by the following formula:"),(0,r.kt)("div",{className:"math math-display"},(0,r.kt)("span",{parentName:"div",className:"katex-display"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"k"),(0,r.kt)("mi",{parentName:"msub"},"g")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"x"),(0,r.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mo",{parentName:"msup"},(0,r.kt)("mi",{parentName:"mo"},"exp"),(0,r.kt)("mo",{parentName:"mo"},"\u2061")),(0,r.kt)("mrow",{parentName:"msup"},(0,r.kt)("mo",{parentName:"mrow"},"\u2212"),(0,r.kt)("mfrac",{parentName:"mrow"},(0,r.kt)("msup",{parentName:"mfrac"},(0,r.kt)("mrow",{parentName:"msup"},(0,r.kt)("mo",{parentName:"mrow",fence:"true"},"\u2225"),(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mo",{parentName:"mrow"},"\u2212"),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"x"),(0,r.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032")),(0,r.kt)("mo",{parentName:"mrow",fence:"true"},"\u2225")),(0,r.kt)("mn",{parentName:"msup"},"2")),(0,r.kt)("msup",{parentName:"mfrac"},(0,r.kt)("mi",{parentName:"msup"},"\u03c3"),(0,r.kt)("mn",{parentName:"msup"},"2"))))),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},".")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k_g(x,x') = \\exp^{-\\frac{\\left\\lVert x-x'\\right\\rVert^2}{\\sigma^2} }.")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.088em",verticalAlign:"-0.286108em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15139200000000003em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5500000000000003em",marginLeft:"-0.03148em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03588em"}},"g")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.286108em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.801892em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.113em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032"))))))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.6495299999999997em",verticalAlign:"-0.19444em"}}),(0,r.kt)("span",{parentName:"span",className:"mop"},(0,r.kt)("span",{parentName:"span",className:"mop"},"exp"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.4550899999999998em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.45509em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.00167em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"\u2212"),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mopen nulldelimiter sizing reset-size3 size6"}),(0,r.kt)("span",{parentName:"span",className:"mfrac"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.4309571428571428em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.5061857142857145em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size3 size1 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03588em"}},"\u03c3"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.9384399999999999em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.93844em",marginRight:"0.1em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.64444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))),(0,r.kt)("span",{parentName:"span",style:{top:"-3.2255000000000003em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"frac-line mtight",style:{borderBottomWidth:"0.049em"}})),(0,r.kt)("span",{parentName:"span",style:{top:"-3.6245204081632654em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size3 size1 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"minner mtight"},(0,r.kt)("span",{parentName:"span",className:"minner mtight"},(0,r.kt)("span",{parentName:"span",className:"mopen sizing reset-size1 size3 mtight delimcenter",style:{top:"0.07142857142857142em"}},(0,r.kt)("span",{parentName:"span",className:"mtight"},"\u2225")),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"x"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"\u2212"),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"x"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.9595600000000001em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.9595599999999997em",marginRight:"0.1em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.55556em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032")))))))),(0,r.kt)("span",{parentName:"span",className:"mclose sizing reset-size1 size3 mtight delimcenter",style:{top:"0.07142857142857142em"}},(0,r.kt)("span",{parentName:"span",className:"mtight"},"\u2225"))),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.1290114285714283em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.1290114285714283em",marginRight:"0.1em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.64444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.49381428571428565em"}},(0,r.kt)("span",{parentName:"span"}))))),(0,r.kt)("span",{parentName:"span",className:"mclose nulldelimiter sizing reset-size3 size6"})))))))))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},".")))))),(0,r.kt)("p",null,"A corresponding matrix-valued kernel can be obtained by multiplying the value with an identity matrix (which implies, that we treat each space dimension as independent). In Scalismo, this is defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class MatrixValuedGaussianKernel3D(sigma2 : Double) extends MatrixValuedPDKernel[_3D]() {\n\n  override def outputDim: Int = 3\n  override def domain: Domain[_3D] = EuclideanSpace3D;\n\n  override def k(x: Point[_3D], y: Point[_3D]): DenseMatrix[Double] = {\n    DenseMatrix.eye[Double](outputDim) * Math.exp(- (x - y).norm2 / sigma2)\n  }\n}\n")),(0,r.kt)("p",null,"This constructions allows us to define any kernel. For the most commonly used ones, such as the Gaussian kernel, there is, however,\nan easier way in Scalismo. First, the scalar-valued Gaussian kernel is already implemented in Scalismo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val scalarValuedGaussianKernel : PDKernel[_3D]= GaussianKernel3D(sigma = 100.0)\n")),(0,r.kt)("p",null,"Further, the class ",(0,r.kt)("inlineCode",{parentName:"p"},"DiagonalKernel"),"allows us to turn any scalar-valued kernel into a matrix-valued kernel,\nby specifying for each dimension of the output-space a kernel and assuming them to be independent. To obtain the same kernel as defined above, we can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val matrixValuedGaussianKernel = DiagonalKernel3D(scalarValuedGaussianKernel, scalarValuedGaussianKernel, scalarValuedGaussianKernel)\n")),(0,r.kt)("p",null,"In this case, since we are using the same kernel in every space dimension, we can write this even more succinct as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"DiagonalKernel3D(scalarValuedGaussianKernel, 3)\n")),(0,r.kt)("h5",{id:"building-the-gp-"},"Building the GP :"),(0,r.kt)("p",null,"Now that we have our mean and covariance functions, we can build a Gaussian process as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val gp = GaussianProcess3D[EuclideanVector[_3D]](zeroMean, matrixValuedGaussianKernel)\n")),(0,r.kt)("p",null,"We can now sample deformations from our Gaussian process ",(0,r.kt)("strong",{parentName:"p"},"at any desired set of points"),". Below we choose the points to be those of the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val sampleGroup = ui.createGroup("samples")\nval sample = gp.sampleAtPoints(referenceMesh)\nui.show(sampleGroup, sample, "gaussianKernelGP_sample")\n')),(0,r.kt)("p",null,"The result is an instance from the Gaussian Process evaluated at the points\nwe indicated;  in this case on the points of the reference mesh."),(0,r.kt)("p",null,"We can visualize its effect by interpolating the deformation field, which we then use to deform the reference mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val interpolatedSample = sample.interpolate(TriangleMeshInterpolator3D())\nval deformedMesh = referenceMesh.transform((p : Point[_3D]) => p + interpolatedSample(p))\nui.show(sampleGroup, deformedMesh, "deformed mesh")\n')),(0,r.kt)("h4",{id:"low-rank-approximation"},"Low-rank approximation"),(0,r.kt)("p",null,"Whenever we create a sample using the ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleAtPoints")," method of the Gaussian process, internally a matrix of dimensionality ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"d"),(0,r.kt)("mo",{parentName:"mrow"},"\xd7"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"d")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"nd \\times nd")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.77777em",verticalAlign:"-0.08333em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"))))),",where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," denotes the number of points and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"d")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"d")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d")))))," the dimensionality of the output space, is created. Hence if we want to sample\nfrom many points we quickly run out of memory."),(0,r.kt)("p",null,"We can get around this problem by computing a low-rank approximation of the Gaussian process.\nTo obtain such a representation in Scalismo, we can use the method\n`",(0,r.kt)("inlineCode",{parentName:"p"},"approximateGPCholesky")," of the ",(0,r.kt)("em",{parentName:"p"},"LowRankGaussianProcess")," object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(\n  referenceMesh,\n  gp,\n  relativeTolerance = 0.01,\n  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\n)\n")),(0,r.kt)("p",null,"This call computes a finite-rank approximation of the Gaussian Process using a\nPivoted Cholesky approximation. The procedure automatically chooses the rank (I.e. the\nnumber of basis functions of the Gaussian process), such that the given relative error\nis achieved. (The error is measures in terms of the variance of the Gaussian\nprocess, approximated on the points of the reference Mesh).\nUsing this low rank Gaussian process, we can now directly sample continuous deformation fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val  defField : Field[_3D, EuclideanVector[_3D]]= lowRankGP.sample()\n")),(0,r.kt)("p",null,"These in turn, can be used to warp a reference mesh, as discussed above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"referenceMesh.transform((p : Point[_3D]) => p + defField(p))\n")),(0,r.kt)("p",null,"More conveniently, we can visualize the sampled meshes by building again a Point Distribution Model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val pdm = PointDistributionModel3D(referenceMesh, lowRankGP)\n")),(0,r.kt)("p",null,"This model can be visualized directly in ScalismoUI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val pdmView = ui.show(modelGroup, pdm, "group")\n')),(0,r.kt)("h3",{id:"building-more-interesting-kernels"},"Building more interesting kernels"),(0,r.kt)("p",null,"In the following we show a few more examples of kernels, which are interesting for shape modelling."),(0,r.kt)("h4",{id:"kernels-from-statistical-shape-models"},"Kernels from Statistical Shape Models"),(0,r.kt)("p",null,"As discussed previously, a Statistical Shape Model (SSM) in Scalismo is a discrete Gaussian process.\nWe have seen how to interpolate it to obtain a continuously defined Gaussian Process. As any\nGaussian process is  completely defined by its mean and covariance function, it follows that this is\nalso true for the GP in our statistical shape model."),(0,r.kt)("p",null,"This allows us to use this ",(0,r.kt)("em",{parentName:"p"},"sample covariance kernel")," in combination with other kernels.\nFor example, we often want to slightly enlarge the flexibility of our statistical models.\nIn the following, we show how this can be achieved."),(0,r.kt)("p",null,"In a first step, we get the Gaussian process from the model an interpolate it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val pcaModel = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File("datasets/lowresModel.h5")).get\nval gpSSM = pcaModel.gp.interpolate(TriangleMeshInterpolator3D())\n')),(0,r.kt)("p",null,"We can then access its covariance function, which is a kernel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val covSSM : MatrixValuedPDKernel[_3D] = gpSSM.cov\n")),(0,r.kt)("p",null,"In the next step, we model the additional variance using a Gaussian kernel and add it to the\n",(0,r.kt)("em",{parentName:"p"},"sample covariance kernel"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val augmentedCov = covSSM + DiagonalKernel(GaussianKernel[_3D](100.0), 3)\n")),(0,r.kt)("p",null,"Finally, we build the Gaussian process with the new kernel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val augmentedGP = GaussianProcess(gpSSM.mean, augmentedCov)\n")),(0,r.kt)("p",null,"From here on, we follow the steps outlined above to obtain the ",(0,r.kt)("em",{parentName:"p"},"augmented")," SSM."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val lowRankAugmentedGP = LowRankGaussianProcess.approximateGPCholesky(\n  referenceMesh,\n  augmentedGP,\n  relativeTolerance = 0.01,\n  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()\n)\nval augmentedSSM = PointDistributionModel3D(pcaModel.reference, lowRankAugmentedGP)\n")),(0,r.kt)("h4",{id:"changepoint-kernel"},"Changepoint kernel:"),(0,r.kt)("p",null,"Another very useful kernel is the ",(0,r.kt)("em",{parentName:"p"},"changepoint kernel"),".\nA changepoint kernel is a combination of different kernels, where each kernel is active only in\na certain region of the space."),(0,r.kt)("p",null,"Here we show how we can define a kernel, which has different behavior in two different regions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class ChangePointKernel(kernel1 : MatrixValuedPDKernel[_3D], kernel2 : MatrixValuedPDKernel[_3D])\n  extends MatrixValuedPDKernel[_3D]() {\n\n  override def domain = EuclideanSpace[_3D]\n  val outputDim = 3\n\n  def s(p: Point[_3D]) =  1.0 / (1.0 + math.exp(-p(0)))\n  def k(x: Point[_3D], y: Point[_3D]) = {\n    val sx = s(x)\n    val sy = s(y)\n    kernel1(x,y) * sx * sy + kernel2(x,y) * (1-sx) * (1-sy)\n  }\n}\n")),(0,r.kt)("p",null,"Let's visualize its effect with two different Gaussian Kernels"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val gk1 = DiagonalKernel3D(GaussianKernel3D(100.0), 3)\nval gk2 = DiagonalKernel3D(GaussianKernel3D(10.0), 3)\nval changePointKernel = ChangePointKernel(gk1, gk2)\nval gpCP = GaussianProcess3D(zeroMean, changePointKernel)\nval sampleCP =  gpCP.sampleAtPoints(referenceMesh)\nui.show(sampleGroup, sampleCP, "ChangePointKernelGP_sample")\n')),(0,r.kt)("p",null,"As you can see each kernel is now active only on one half of the face."),(0,r.kt)("h4",{id:"symmetrizing-a-kernel"},"Symmetrizing a kernel"),(0,r.kt)("p",null,"Quite often, the shapes that we aim to model exhibit a symmetry. This is particularly valid in the case of faces.\nTherefore when modelling over such shapes, one would want deformation fields that yield symmetric shapes."),(0,r.kt)("p",null,"Once we obtained a kernel yielding the type of deformations we desire, it is possible to symmetrize the resulting deformation fields by applying the formula below:"),(0,r.kt)("img",{src:" data:image/png;base64,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"}),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"x",(0,r.kt)("sub",null,"m"))," is the symmetric point to ",(0,r.kt)("em",{parentName:"p"},"x")," around the YZ plane."),(0,r.kt)("p",null,"The resulting kernel will preserve the same smoothness properties of the deformation fields while adding the symmetry around the YZ plane."),(0,r.kt)("p",null,"Let's turn it into code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class xMirroredKernel(kernel : PDKernel[_3D]) extends PDKernel[_3D] {\n  override def domain = kernel.domain\n  override def k(x: Point[_3D], y: Point[_3D]) = kernel(Point(x(0) * -1.0 ,x(1), x(2)), y)\n}\n\ndef symmetrizeKernel(kernel : PDKernel[_3D]) : MatrixValuedPDKernel[_3D] = {\n  val xmirrored = xMirroredKernel(kernel)\n  val k1 = DiagonalKernel(kernel, 3)\n  val k2 = DiagonalKernel(xmirrored * -1f, xmirrored, xmirrored)\n  k1 + k2\n}\n\nval symmetrizedGaussian = symmetrizeKernel(GaussianKernel[_3D](100))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val gpSym = GaussianProcess3D(zeroMean, symmetrizedGaussian)\nval sampleGpSym =  gpSym.sampleAtPoints(referenceMesh)\n\nui.show(sampleGroup, sampleGpSym, "ChangePointKernelGP_sample")\n')))}u.isMDXComponent=!0},6222:function(e,a,t){a.Z=t.p+"assets/files/Tutorial07-fb0fe762ab1fc2df20be8999b60f166b.scala"}}]);