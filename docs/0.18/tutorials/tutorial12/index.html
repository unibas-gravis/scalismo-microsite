<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.68">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Parametric, non-rigid registration | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="0.18"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-0.18"><meta data-react-helmet="true" property="og:title" content="Parametric, non-rigid registration | Scalismo"><meta data-react-helmet="true" name="description" content="We have seen how non-rigid ICP can be used to establish correspondences."><meta data-react-helmet="true" property="og:description" content="We have seen how non-rigid ICP can be used to establish correspondences."><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/0.18/tutorials/tutorial12"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/0.18/tutorials/tutorial12"><link rel="stylesheet" href="/styles.656a0876.css">
<link rel="preload" href="/styles.0daa2ecb.js" as="script">
<link rel="preload" href="/runtime~main.543c9bbc.js" as="script">
<link rel="preload" href="/main.0069e762.js" as="script">
<link rel="preload" href="/1.d0a04477.js" as="script">
<link rel="preload" href="/88.19909525.js" as="script">
<link rel="preload" href="/90.32728c13.js" as="script">
<link rel="preload" href="/7ca117c4.beb00885.js" as="script">
<link rel="preload" href="/87.bdda081e.js" as="script">
<link rel="preload" href="/5772da5e.bdb51f02.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_2AhQ">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/docs/0.18/">0.18</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/tutorials/tutorial12">Next</a></li><li><a class="dropdown__link" href="/docs/tutorials/tutorial12">0.90</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/0.18/tutorials/tutorial12">0.18</a></li></ul></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/onlinecourse">Online courses</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a class="menu__link" href="/support">Support</a></li><li class="menu__list-item"><a class="menu__link" href="/about">About</a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/next/tutorials/tutorial12">Next</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/tutorials/tutorial12">0.90</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/0.18/tutorials/tutorial12">0.18</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive thin-scrollbar menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial1">Hello Scalismo!</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial2">Rigid Alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial3">From meshes to deformation fields</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial4">Gaussian processes and Point Distribution Models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial5">Gaussian processes, sampling and marginalization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial6">Building a shape model from data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial7">Shape modelling with Gaussian processes and kernels</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial8">Posterior Shape Models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial9">Shape completion using Gaussian process regression</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/0.18/tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial13">Active Shape Model fitting</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.18/tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/0.18/tutorials/scalismo-ui-introduction">Introduction to Scalismo-ui</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_39qw"><div class="row"><div class="col docItemCol_2ASc"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for Scalismo <strong>0.18</strong>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <strong><a href="/docs/tutorials/tutorial12">latest version</a></strong> (0.90).</div></div><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: 0.18</span></div><header><h1 class="docTitle_1Lrw">Parametric, non-rigid registration</h1></header><div class="markdown"><p>We have seen how non-rigid ICP can be used to establish correspondences.
In this tutorial we discuss a different approach to model-fitting and non-rigid registration.
We are formulating the registration problem as an optimization problem, which we optimize
using gradient-based optimization.</p><p>This registration is more general than ICP, in the sense that it can not only
be used for surface-to-surface registration, but also for image-to-image-registration.
In this tutorial we show the complete work-flow involved in a typical registration task,
from building the Gaussian process model to performing the actual optimization.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="related-resources"></a>Related resources<a aria-hidden="true" class="hash-link" href="#related-resources" title="Direct link to heading">#</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371" target="_blank" rel="noopener noreferrer">(Video)</a></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparation"></a>Preparation<a aria-hidden="true" class="hash-link" href="#preparation" title="Direct link to heading">#</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.geometry._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.common._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.ui.api._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.mesh._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.registration._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.io.{MeshIO}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.numerics._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.kernels._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.statisticalmodel._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import breeze.linalg.{DenseVector}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">scalismo.initialize()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">implicit val rng = scalismo.utils.Random(42)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val ui = ScalismoUI()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="loading-and-visualizing-a-mesh"></a>Loading and visualizing a mesh<a aria-hidden="true" class="hash-link" href="#loading-and-visualizing-a-mesh" title="Direct link to heading">#</a></h2><p>We start by loading and visualizing the reference mesh, which we will later use as the
domain for our Gaussian Process model.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val referenceMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/quickstart/facemesh.ply&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelGroup = ui.createGroup(&quot;model&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val refMeshView = ui.show(modelGroup, referenceMesh, &quot;referenceMesh&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">refMeshView.color = java.awt.Color.RED</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-a-gaussian-process-shape-model"></a>Building a Gaussian process shape model<a aria-hidden="true" class="hash-link" href="#building-a-gaussian-process-shape-model" title="Direct link to heading">#</a></h2><p>We assume that our reference surface represents an approximately average face.
This justifies the use of a zero-mean Gaussian process. As a covariance function we use a Gaussian kernel and choose to treat the x,y,z component
of the vector field to be uncorrelated (indicated by the use of the <code>DiagonalKernel</code>).</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mean = VectorField(RealSpace[_3D], (_ : Point[_3D]) =&gt; EuclideanVector.zeros[_3D])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val kernel = DiagonalKernel[_3D](GaussianKernel(sigma = 70) * 50.0, outputDim = 3)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gp = GaussianProcess(mean, kernel)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We then perform a low-rank approximation, to get a parametric representation of the
Gaussian process:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    referenceMesh.pointSet,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    gp,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    relativeTolerance = 0.05,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    interpolator = NearestNeighborInterpolator()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>To visualize the effect of this Gaussian process, we add it to the
model group as a transformation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gpView = ui.addTransformation(modelGroup, lowRankGP, &quot;gp&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>This has the effect, that the transformations represented by this GP,
are applied to all the geometric objects, which are present in the group.
In this case, it is the mean of the Gaussian process, which is applied to
the reference mesh we loaded previously. By changing the parameters in the
ui, we can visualize different transformations, as we did previously
for statistical shape models.</p><p><em>Note: Adding the reference mesh to the scene, followed by a Gaussian process transformation
is indeed what happend internally, we visualized Statistical Shape Models in the
previous tutorials</em></p><p>Having visualized the Gaussian process, we can now draw random samples,
to assess whether out choice of parameters of the Gaussian process leads to
reasonable deformations. If not, we adjust the parameters until we are happy
with the deformations that are modelled.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="registration"></a>Registration<a aria-hidden="true" class="hash-link" href="#registration" title="Direct link to heading">#</a></h2><p>In the next step we perform the registration to a target mesh.
We start by loading the target mesh and displaying it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetGroup = ui.createGroup(&quot;target&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/quickstart/face-2.ply&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetMeshView = ui.show(targetGroup, targetMesh, &quot;targetMesh&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p><em>To visualize a registration, it is best to change the perspective in the graphical user interface to &quot;orthogonal slices&quot;. You can find this functionality in the &quot;View -&gt; Perspective&quot; menu.</em></p><p>To define a registration, we need to define four things:</p><ol><li>a <code>transformation space</code> that models the possible transformations of the reference surface (or the ambient space)</li><li>a <code>metric</code> to measure the distance between the model (the deformed reference mesh) an the target surface.</li><li>a <code>regularizer</code>, which penalizes unlikely transformations.</li><li>an <code>optimizer</code>.</li></ol><p>For non-rigid registration we usually model the possible transformations using a Gaussian process. We use the Gaussian process that
we have defined above to define the transformation space.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As a metric, we use a simple mean squares metric. Currently, all metrics that are available in scalismo are implemented as
image to image metrics. These can, however, easily be used for surface registration by representing the surface as  a distance image.
In addition to the images, the metric also needs to know the possible transformations (as modelled by the transformation space) and
a sampler. The sampler determines the points where the metric is evaluated. In our case we choose uniformely sampled points on the
reference mesh.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val fixedImage = referenceMesh.operations.toDistanceImage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val movingImage = targetMesh.operations.toDistanceImage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sampler = FixedPointsUniformMeshSampler3D(referenceMesh, numberOfPoints = 1000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val metric = MeanSquaresMetric(fixedImage, movingImage, transformationSpace, sampler)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As an optimizer, we choose an LBFGS Optimizer</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val optimizer = LBFGSOptimizer(maxNumberOfIterations = 100)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>and for regularization we choose to penalize the L2 norm using the <code>L2Regularizer</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val regularizer = L2Regularizer(transformationSpace)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We are now ready to define Scalismo&#x27;s registration object.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val registration = Registration(metric, regularizer, regularizationWeight = 1e-5, optimizer)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Registration is an iterative process. Consequently, we work with the registration using an iterator. We obtain an iterator by
calling the <code>iterator</code> method, where we also provide a starting position for the iteration (which is in this case the zero vector):</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val initialCoefficients = DenseVector.zeros[Double](lowRankGP.rank)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val registrationIterator = registration.iterator(initialCoefficients)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Before running the registration, we change the iterator such that it prints in each iteration to current objective value,
and updates the visualization. This lets us visually inspect the progress of the registration procedure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val visualizingRegistrationIterator = for ((it, itnum) &lt;- registrationIterator.zipWithIndex) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(s&quot;object value in iteration $itnum is ${it.value}&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gpView.coefficients = it.parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Note that the above code does not yet run the registration. It simply returns a new iterator, which augments
the original iteration with visualization. The actual registration is executed once we &quot;consume&quot; the iterator.
This can, for example be achieved by converting it to a sequence. The resulting sequence holds all the intermediate
states of the registration. We are usually only interested in the last one:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val registrationResult = visualizingRegistrationIterator.toSeq.last</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>You should see in the graphical user interface, how the face mesh slowly adapts to the shape of the target mesh.</p><p>The final mesh representation can be obtained by obtaining the transform corresponding to the parameters and to
warp the reference mesh with this tranform:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val registrationTransformation = transformationSpace.transformForParameters(registrationResult.parameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val fittedMesh = referenceMesh.transform(registrationTransformation)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="working-with-the-registration-result"></a>Working with the registration result<a aria-hidden="true" class="hash-link" href="#working-with-the-registration-result" title="Direct link to heading">#</a></h3><p>The fittedMesh that we obtained above is a surface that approximates the target surface.  It corresponds to the best representation of the target in the model. For most tasks, this approximation is sufficient.
However, sometimes, we need an exact representation of the target mesh. This can be achieved by defining a projection function, which projects each point onto its closest point on the target.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetMeshOperations = targetMesh.operations</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val projection = (pt : Point[_3D]) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  targetMeshOperations.closestPointOnSurface(pt).point</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Composing the result of the registration with this projection, will give us a mapping that identifies for each point of the reference mesh the corresponding point of the target mesh.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val finalTransformation = registrationTransformation.andThen(projection)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>To check this last point, we warp the reference mesh with the finalTransform and visualize it. Note that the projected target now coincides with the target mesh..</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val projectedMesh = referenceMesh.transform(finalTransformation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val resultGroup = ui.createGroup(&quot;result&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val projectionView = ui.show(resultGroup, projectedMesh, &quot;projection&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="improving-registrations-for-more-complex-shapes"></a>Improving registrations for more complex shapes.<a aria-hidden="true" class="hash-link" href="#improving-registrations-for-more-complex-shapes" title="Direct link to heading">#</a></h3><p>This registration procedure outlined above works reasonably well for simple cases. In complex cases, in particular if you have large
shape variations, you may find it difficult to find a suitable regularization weight. When you choose the regularization weight
large, the procedure will result in a nice and smooth mesh, but fails to closely fit the surface. If you choose it small, it may
result in folds and bad correspondences. In such cases it has proven extremely useful to simply iterate the registration procedure,
with decreasing regularization weights. In the following we illustrate this procedure. We start by defining a case class, which
collects all relevant parameters:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class RegistrationParameters(regularizationWeight : Double, numberOfIterations : Int, numberOfSampledPoints : Int)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We put all the registration code into a function, which takes (among others) the registration parameters as an argument.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def doRegistration(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            lowRankGP : LowRankGaussianProcess[_3D, EuclideanVector[_3D]],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            referenceMesh : TriangleMesh[_3D],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            targetmesh : TriangleMesh[_3D],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            registrationParameters : RegistrationParameters,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            initialCoefficients : DenseVector[Double]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ) : DenseVector[Double] =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val fixedImage = referenceMesh.operations.toDistanceImage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val movingImage = targetMesh.operations.toDistanceImage</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val sampler = FixedPointsUniformMeshSampler3D(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            referenceMesh,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            registrationParameters.numberOfSampledPoints</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val metric = MeanSquaresMetric(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            fixedImage,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            movingImage,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            transformationSpace,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            sampler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val optimizer = LBFGSOptimizer(registrationParameters.numberOfIterations)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val regularizer = L2Regularizer(transformationSpace)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val registration = Registration(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            metric,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            regularizer,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            registrationParameters.regularizationWeight,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            optimizer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val registrationIterator = registration.iterator(initialCoefficients)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val visualizingRegistrationIterator = for ((it, itnum) &lt;- registrationIterator.zipWithIndex) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">              println(s&quot;object value in iteration $itnum is ${it.value}&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">              gpView.coefficients = it.parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">              it</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val registrationResult = visualizingRegistrationIterator.toSeq.last</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        registrationResult.parameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Finally, we define the parameters and run the registration. Note that for large regularization weights, we sample fewer points on the surface to save some computation time.
This is justified as, a strongly regularized model will not be able to adapt to fine details and hence it is not necessary to have a very accurate sampling of the surface.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val registrationParameters = Seq(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        RegistrationParameters(regularizationWeight = 1e-1, numberOfIterations = 20, numberOfSampledPoints = 1000),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        RegistrationParameters(regularizationWeight = 1e-2, numberOfIterations = 30, numberOfSampledPoints = 1000),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        RegistrationParameters(regularizationWeight = 1e-4, numberOfIterations = 40, numberOfSampledPoints = 2000),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        RegistrationParameters(regularizationWeight = 1e-6, numberOfIterations = 50, numberOfSampledPoints = 4000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val finalCoefficients = registrationParameters.foldLeft(initialCoefficients)((modelCoefficients, regParameters) =&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            doRegistration(lowRankGP, referenceMesh, targetMesh, regParameters, modelCoefficients))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>From this point we use the procedure described above to work with the registration result.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/versioned_docs/version-0.18/tutorials/tutorial12.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/0.18/tutorials/tutorial11"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Model fitting with Iterative Closest Points</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/0.18/tutorials/tutorial13"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Active Shape Model fitting »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#loading-and-visualizing-a-mesh" class="table-of-contents__link">Loading and visualizing a mesh</a></li><li><a href="#building-a-gaussian-process-shape-model" class="table-of-contents__link">Building a Gaussian process shape model</a></li><li><a href="#registration" class="table-of-contents__link">Registration</a><ul><li><a href="#working-with-the-registration-result" class="table-of-contents__link">Working with the registration result</a></li><li><a href="#improving-registrations-for-more-complex-shapes" class="table-of-contents__link">Improving registrations for more complex shapes.</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Forum</a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitter-Chat</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2021 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.0daa2ecb.js"></script>
<script src="/runtime~main.543c9bbc.js"></script>
<script src="/main.0069e762.js"></script>
<script src="/1.d0a04477.js"></script>
<script src="/88.19909525.js"></script>
<script src="/90.32728c13.js"></script>
<script src="/7ca117c4.beb00885.js"></script>
<script src="/87.bdda081e.js"></script>
<script src="/5772da5e.bdb51f02.js"></script>
</body>
</html>