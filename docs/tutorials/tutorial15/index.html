<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.68">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Model fitting using MCMC - Fitting a shape model | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="0.90"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-0.90"><meta data-react-helmet="true" property="og:title" content="Model fitting using MCMC - Fitting a shape model | Scalismo"><meta data-react-helmet="true" name="description" content="In this tutorial we show how the MCMC framework, which was introduced in the previous"><meta data-react-helmet="true" property="og:description" content="In this tutorial we show how the MCMC framework, which was introduced in the previous"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/tutorials/tutorial15"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/tutorials/tutorial15"><link rel="stylesheet" href="/styles.ecbe9e9d.css">
<link rel="preload" href="/styles.4711b045.js" as="script">
<link rel="preload" href="/runtime~main.2d058dcb.js" as="script">
<link rel="preload" href="/main.8cd2c6cb.js" as="script">
<link rel="preload" href="/1.376038f2.js" as="script">
<link rel="preload" href="/93.937fb28c.js" as="script">
<link rel="preload" href="/95.e7fffad1.js" as="script">
<link rel="preload" href="/f68ef350.555d9479.js" as="script">
<link rel="preload" href="/92.8a719913.js" as="script">
<link rel="preload" href="/868e6417.89a63019.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_2AhQ">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/docs/">0.90</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/tutorials/tutorial15">Next</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/tutorials/tutorial15">0.90</a></li><li><a class="dropdown__link" href="/docs/0.18/tutorials/tutorial15">0.18</a></li></ul></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/onlinecourse">Online courses</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a class="menu__link" href="/support">Support</a></li><li class="menu__list-item"><a class="menu__link" href="/about">About</a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/next/tutorials/tutorial15">Next</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/tutorials/tutorial15">0.90</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.18/tutorials/tutorial15">0.18</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive thin-scrollbar menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial1">Hello Scalismo!</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial2">Rigid Alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial3">From meshes to deformation fields</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial4">Gaussian processes and Point Distribution Models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial5">Gaussian processes, sampling and marginalization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial6">Building a shape model from data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial7">Shape modelling with Gaussian processes and kernels</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial8">Posterior shape models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial9">Shape completion using GP regression</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/scalismo-ui-introduction">Introduction to Scalismo-ui</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_39qw"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: 0.90</span></div><header><h1 class="docTitle_1Lrw">Model fitting using MCMC - Fitting a shape model</h1></header><div class="markdown"><p>In this tutorial we show how the MCMC framework, which was introduced in the previous
tutorial, can be used for shape model fitting.</p><p>We will illustrate it by computing a posterior of a shape model,
given a set of corresponding landmark pairs. This is the same setup that we have
discussed in the tutorial about Gaussian process regression. The difference is,
that here we will also allow for rotation and translation of the model. In this setting,
it is not possible anymore to compute the posterior analytically. Rather, our only hope are approximation methods, such as
using Markov-chain monte carlo methods.</p><p>In this tutorial we show not only a working example, but also how to make it
computationally efficient. Making the individual parts as efficient as possible is
important in sampling approaches, as we need to produce many samples to get accurate
estimates.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="related-resources"></a>Related resources<a aria-hidden="true" class="hash-link" href="#related-resources" title="Direct link to heading">#</a></h5><p>Week 3 of our <a href="https://shapemodelling.cs.unibas.ch/probabilistic-fitting-course/" target="_blank" rel="noopener noreferrer">online course</a> on shape model fitting may provide some helpful context for this tutorial.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparation"></a>Preparation<a aria-hidden="true" class="hash-link" href="#preparation" title="Direct link to heading">#</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and
initializing the system.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.common.{PointId, UnstructuredPointsDomain}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.geometry._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.io.{LandmarkIO, MeshIO, StatisticalModelIO}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.mesh.TriangleMesh</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.sampling.algorithms.MetropolisHastings</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.sampling.evaluators.ProductEvaluator</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.sampling.proposals.MixtureProposal</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.sampling.loggers.AcceptRejectLogger</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.sampling.{DistributionEvaluator, ProposalGenerator, TransitionProbability}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.statisticalmodel.{MultivariateNormalDistribution, PointDistributionModel, PointDistributionModel3D}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.transformations.{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  RigidTransformation,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Rotation3D,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Translation3D,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TranslationAfterRotation,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TranslationAfterRotation3D</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.utils.Memoize</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.ui.api.ScalismoUI</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import breeze.linalg.{DenseMatrix, DenseVector}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">implicit val rng = scalismo.utils.Random(42)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">scalismo.initialize()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val ui = ScalismoUI()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="loading-and-visualizing-the-data"></a>Loading and visualizing the data<a aria-hidden="true" class="hash-link" href="#loading-and-visualizing-the-data" title="Direct link to heading">#</a></h3><p>In a first step, we load and visualize all the data that we need.
First, we load the statistical model:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File(&quot;datasets/bfm.h5&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelGroup = ui.createGroup(&quot;model&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelView = ui.show(modelGroup, model, &quot;model&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">modelView.referenceView.opacity = 0.5</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In this example, we will fit the model such that a set of model landmarks, coincide
with a set of landmark points defined on a target face. We load and visualize the corresponding landmark data:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelLms = LandmarkIO.readLandmarksJson[_3D](new java.io.File(&quot;datasets/modelLM_mcmc.json&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelLmViews = ui.show(modelGroup, modelLms, &quot;modelLandmarks&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">modelLmViews.foreach(lmView =&gt; lmView.color = java.awt.Color.BLUE)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetGroup = ui.createGroup(&quot;target&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetLms = LandmarkIO.readLandmarksJson3D(new java.io.File(&quot;datasets/targetLM_mcmc.json&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetLmViews = ui.show(targetGroup, targetLms, &quot;targetLandmarks&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">modelLmViews.foreach(lmView =&gt; lmView.color = java.awt.Color.RED)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In the following, we will refer to the points on the model using their point id, while the target
position is represented as physical points. The reason why we use the point id for the model is that the model instances,
and therefore the points, which are represented by the point id, are changing as we fit the model.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelLmIds = modelLms.map(l =&gt; model.mean.pointSet.pointId(l.point).get)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetPoints = targetLms.map(l =&gt; l.point)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We summarize the correspondences as a tuple, consisting of model id and target position.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val correspondences = modelLmIds</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .zip(targetPoints)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .map(modelIdWithTargetPoint =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val (modelId, targetPoint) = modelIdWithTargetPoint</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (modelId, targetPoint)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  })</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-parameter-class"></a>The parameter class<a aria-hidden="true" class="hash-link" href="#the-parameter-class" title="Direct link to heading">#</a></h3><p>In this example, we want to model the posterior <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em">D</span><span class="mclose">)</span></span></span></span></span>, where
the parameters <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta =( t, r, \alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.0037em">α</span><span class="mclose">)</span></span></span></span></span> consist of the translation parameters
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=(t_x, t_y, t_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>, the rotation parameters <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>ψ</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = (\phi, \psi, \omega)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.03588em">ψ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.03588em">ω</span><span class="mclose">)</span></span></span></span></span>,
represented as Euler angles as well a shape model coefficients <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>α</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha = (\alpha_1, \ldots, \alpha_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.
Furthermore, we also model the noise as a parameter.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class Parameters(translationParameters: EuclideanVector[_3D],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      rotationParameters: (Double, Double, Double),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      modelCoefficients: DenseVector[Double],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      noiseStddev : Double</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                     )</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As in the previous tutorial, we wrap this into a class representing the sample, which can keep track by whom it was generated. Furthermore, we will add convenience method,
which builds a <code>RigidTransformation</code> from the parameters. As a rigid transformation
is not completely determined by the translation and rotation parameters, we need to
store also the center of rotation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class Sample(generatedBy: String, parameters: Parameters, rotationCenter: Point[_3D]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def poseTransformation: TranslationAfterRotation[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val translation = Translation3D(parameters.translationParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val rotation = Rotation3D(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      parameters.rotationParameters._1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      parameters.rotationParameters._2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      parameters.rotationParameters._3,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      rotationCenter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    TranslationAfterRotation3D(translation, rotation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="evaluators-modelling-the-target-density"></a>Evaluators: Modelling the target density<a aria-hidden="true" class="hash-link" href="#evaluators-modelling-the-target-density" title="Direct link to heading">#</a></h3><p>As in the previous tutorial, we represent the unnormalized posterior distribution
as the product of prior and likelihood:
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo><mo>∝</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D) \propto p(\theta) p(D | \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">D</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mclose">)</span></span></span></span></span>,
where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.02778em">D</span></span></span></span></span> denotes the data (i.e. the corresponding landmark points) and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span></span></span></span></span>
are our parameters.</p><p>As a prior over the shape parameters is given by the shape model. For the
translation and rotation, we assume a zero-mean normal distribution. As the standard deviation
characterizing the noise needs to be positive, we use a lognormal distribution.:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class PriorEvaluator(model: PointDistributionModel[_3D, TriangleMesh]) extends DistributionEvaluator[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val translationPrior = breeze.stats.distributions.Gaussian(0.0, 5.0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val rotationPrior = breeze.stats.distributions.Gaussian(0, 0.1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val noisePrior = breeze.stats.distributions.LogNormal(0, 0.25)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logValue(sample: Sample): Double = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    model.gp.logpdf(sample.parameters.modelCoefficients) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      translationPrior.logPdf(sample.parameters.translationParameters.x) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      translationPrior.logPdf(sample.parameters.translationParameters.y) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      translationPrior.logPdf(sample.parameters.translationParameters.z) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      rotationPrior.logPdf(sample.parameters.rotationParameters._1) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      rotationPrior.logPdf(sample.parameters.rotationParameters._2) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      rotationPrior.logPdf(sample.parameters.rotationParameters._3) +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      noisePrior.logPdf(sample.parameters.noiseStddev)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>To compute the likelihood <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D | \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">D</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mclose">)</span></span></span></span></span> we first compute
the current model instance as determined by the shape and pose parameters.
From this model instance, the points at the given points id are extracted and
the distance to their target position is computed. This distance is what was
modelled by the uncertainty of the observations. We can therefore directly use
the modelled uncertainty to compute the likelihood of our model given the data:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class SimpleCorrespondenceEvaluator(model: PointDistributionModel[_3D, TriangleMesh],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                         correspondences: Seq[(PointId, Point[_3D])])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    extends DistributionEvaluator[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logValue(sample: Sample): Double = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val currModelInstance = model.instance(sample.parameters.modelCoefficients).transform(sample.poseTransformation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val lmUncertainty = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val likelihoods = correspondences.map(correspondence =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val (id, targetPoint) = correspondence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val modelInstancePoint = currModelInstance.pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val observedDeformation = targetPoint - modelInstancePoint</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      lmUncertainty.logpdf(observedDeformation.toBreezeVector)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val loglikelihood = likelihoods.sum</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loglikelihood</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Conceptually, this is all that needed to be done to specify the target distribution.
In practice, we are interested to make these evaluators as efficient as possible,
as they are usually called thousands of times.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="performance-improvements"></a>Performance improvements<a aria-hidden="true" class="hash-link" href="#performance-improvements" title="Direct link to heading">#</a></h5><p>In the above implementation, we compute a full model instance (the new position of all the mesh points
represented by the shape model), although we are only interested in the position of the landmark points.
This is rather inefficient. A more efficient version would first marginalize the model to the
points of interest. Since marginalization changes the point ids, we need to map the
ids given as<code>correspondences</code> to their new ids. This is achieved by the following helper function:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def marginalizeModelForCorrespondences(model: PointDistributionModel[_3D, TriangleMesh],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                        correspondences: Seq[(PointId, Point[_3D])])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">: (PointDistributionModel[_3D, UnstructuredPointsDomain],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Seq[(PointId, Point[_3D])]) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val (modelIds, _) = correspondences.unzip</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val marginalizedModel = model.marginal(modelIds.toIndexedSeq)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val newCorrespondences = correspondences.map(idWithTargetPoint =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val (id, targetPoint) = idWithTargetPoint</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val modelPoint = model.reference.pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newId = marginalizedModel.reference.pointSet.findClosestPoint(modelPoint).id</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (newId, targetPoint)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (marginalizedModel, newCorrespondences)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The more efficient version of the evaluator uses now the marginalized model to evaluate the likelihood:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class CorrespondenceEvaluator(model: PointDistributionModel[_3D, TriangleMesh],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                   correspondences: Seq[(PointId, Point[_3D])])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  extends DistributionEvaluator[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val (marginalizedModel, newCorrespondences) = marginalizeModelForCorrespondences(model, correspondences)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logValue(sample: Sample): Double = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val lmUncertainty = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val currModelInstance = marginalizedModel</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .instance(sample.parameters.modelCoefficients)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .transform(sample.poseTransformation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val likelihoods = newCorrespondences.map(correspondence =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val (id, targetPoint) = correspondence</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val modelInstancePoint = currModelInstance.pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val observedDeformation = targetPoint - modelInstancePoint</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      lmUncertainty.logpdf(observedDeformation.toBreezeVector)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val loglikelihood = likelihoods.sum</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    loglikelihood</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In order for the Metropolis-Hastings algorithm to decide if a new sample is accepted,
the likelihood needs to be computed several times for each set of parameters. To further
increase the efficiency, we should therefore cache the computations, such that when
an evaluator is used the second time with the same parameters, the <code>logValue</code> is
not recomputed, but simply taken from cache. Using the following utility class,
we can obtain for any evaluator a new evaluator, which performs such caching:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class CachedEvaluator[A](evaluator: DistributionEvaluator[A]) extends DistributionEvaluator[A] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val memoizedLogValue = Memoize(evaluator.logValue, 10)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logValue(sample: A): Double = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    memoizedLogValue(sample)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-posterior-evaluator"></a>The posterior evaluator<a aria-hidden="true" class="hash-link" href="#the-posterior-evaluator" title="Direct link to heading">#</a></h4><p>Given these evaluators, we can now build the computationally efficient version of
our target density <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em">D</span><span class="mclose">)</span></span></span></span></span></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val likelihoodEvaluator = CachedEvaluator(CorrespondenceEvaluator(model, correspondences))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val priorEvaluator = CachedEvaluator(PriorEvaluator(model))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val posteriorEvaluator = ProductEvaluator(priorEvaluator, likelihoodEvaluator)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-proposal-generator"></a>The proposal generator<a aria-hidden="true" class="hash-link" href="#the-proposal-generator" title="Direct link to heading">#</a></h3><p>As in the previous tutorials, we will use simple random walk proposals.
We will define separate proposals for shape, translation and rotation.
On one hand, this lets us set the step length (i.e. stddev of the distribution from which we
sample the next step) individually for each group, and thus to incorporate our knowledge
that changes in rotation will be much smaller than the shape changes. On the other hand,
splitting the parameter updates in blocks will increase our chance for the random updates
to be accepted. The reason for this is that when many parameters are updated at one,
chances are high that some of the proposed changes make the new state more unlikely,
and hence increase the chance of the new state being rejected.</p><p>The definition of the proposals are straight-forward.</p><p>We start with the shape update proposal:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class ShapeUpdateProposal(paramVectorSize: Int, stddev: Double)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    extends ProposalGenerator[Sample]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    with TransitionProbability[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val perturbationDistr = new MultivariateNormalDistribution(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    DenseVector.zeros(paramVectorSize),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    DenseMatrix.eye[Double](paramVectorSize) * stddev * stddev</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def propose(sample: Sample): Sample = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val perturbation = perturbationDistr.sample()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newParameters =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sample.parameters.copy(modelCoefficients = sample.parameters.modelCoefficients + perturbationDistr.sample)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sample.copy(generatedBy = s&quot;ShapeUpdateProposal ($stddev)&quot;, parameters = newParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logTransitionProbability(from: Sample, to: Sample) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val residual = to.parameters.modelCoefficients - from.parameters.modelCoefficients</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perturbationDistr.logpdf(residual)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The update of the roation parameters is very similar. Note that we only update the
rotation parameters, but keep the center of rotation unchanged.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class RotationUpdateProposal(stddev: Double)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    extends ProposalGenerator[Sample]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    with TransitionProbability[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val perturbationDistr =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    new MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * stddev * stddev)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def propose(sample: Sample): Sample = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val perturbation = perturbationDistr.sample</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newRotationParameters = (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sample.parameters.rotationParameters._1 + perturbation(0),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sample.parameters.rotationParameters._2 + perturbation(1),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sample.parameters.rotationParameters._3 + perturbation(2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newParameters = sample.parameters.copy(rotationParameters = newRotationParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sample.copy(generatedBy = s&quot;RotationUpdateProposal ($stddev)&quot;, parameters = newParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logTransitionProbability(from: Sample, to: Sample) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val residual = DenseVector(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      to.parameters.rotationParameters._1 - from.parameters.rotationParameters._1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      to.parameters.rotationParameters._2 - from.parameters.rotationParameters._2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      to.parameters.rotationParameters._3 - from.parameters.rotationParameters._3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perturbationDistr.logpdf(residual)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We define a similar proposal for the translation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class TranslationUpdateProposal(stddev: Double)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    extends ProposalGenerator[Sample]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    with TransitionProbability[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val perturbationDistr =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    new MultivariateNormalDistribution(DenseVector.zeros(3), DenseMatrix.eye[Double](3) * stddev * stddev)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def propose(sample: Sample): Sample = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newTranslationParameters = sample.parameters.translationParameters + EuclideanVector.fromBreezeVector(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      perturbationDistr.sample()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newParameters = sample.parameters.copy(translationParameters = newTranslationParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sample.copy(generatedBy = s&quot;TranlationUpdateProposal ($stddev)&quot;, parameters = newParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logTransitionProbability(from: Sample, to: Sample) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val residual = to.parameters.translationParameters - from.parameters.translationParameters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perturbationDistr.logpdf(residual.toBreezeVector)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class NoiseStddevUpdateProposal(stddev: Double)(implicit rng : scalismo.utils.Random)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  extends ProposalGenerator[Sample]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    with TransitionProbability[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val perturbationDistr = breeze.stats.distributions.Gaussian(0, stddev)(rng.breezeRandBasis)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def propose(sample: Sample): Sample = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newSigma = sample.parameters.noiseStddev +  perturbationDistr.sample()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val newParameters = sample.parameters.copy(noiseStddev = newSigma)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sample.copy(generatedBy = s&quot;NoiseStddevUpdateProposal ($stddev)&quot;, parameters = newParameters)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def logTransitionProbability(from: Sample, to: Sample) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val residual = to.parameters.noiseStddev - from.parameters.noiseStddev</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perturbationDistr.logPdf(residual)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The final proposal is a mixture of the  proposals we defined above.
We choose to update the shape more often than the translation and rotation parameters,
as we expect most changes to be shape changes.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val shapeUpdateProposal = ShapeUpdateProposal(model.rank, 0.1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val rotationUpdateProposal = RotationUpdateProposal(0.01)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val translationUpdateProposal = TranslationUpdateProposal(1.0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val noiseStddevUpdateProposal = NoiseStddevUpdateProposal(0.1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val generator = MixtureProposal.fromProposalsWithTransition(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (0.5, shapeUpdateProposal),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (0.2, rotationUpdateProposal),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (0.2, translationUpdateProposal),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (0.1, noiseStddevUpdateProposal)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-the-markov-chain"></a>Building the Markov Chain<a aria-hidden="true" class="hash-link" href="#building-the-markov-chain" title="Direct link to heading">#</a></h4><p>For running the Markov Chain, we proceed exactly as in the previous tutorial. We start by defining the logger,
to compute the accept/reject ratios of the individual generators</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Logger extends AcceptRejectLogger[Sample] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private val numAccepted = collection.mutable.Map[String, Int]()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private val numRejected = collection.mutable.Map[String, Int]()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def accept(current: Sample,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      sample: Sample,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      generator: ProposalGenerator[Sample],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      evaluator: DistributionEvaluator[Sample]): Unit = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val numAcceptedSoFar = numAccepted.getOrElseUpdate(sample.generatedBy, 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    numAccepted.update(sample.generatedBy, numAcceptedSoFar + 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def reject(current: Sample,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      sample: Sample,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      generator: ProposalGenerator[Sample],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                      evaluator: DistributionEvaluator[Sample]): Unit = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val numRejectedSoFar = numRejected.getOrElseUpdate(sample.generatedBy, 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    numRejected.update(sample.generatedBy, numRejectedSoFar + 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def acceptanceRatios(): Map[String, Double] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val generatorNames = numRejected.keys.toSet.union(numAccepted.keys.toSet)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val acceptanceRatios = for (generatorName &lt;- generatorNames) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      val total = (numAccepted.getOrElse(generatorName, 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        + numRejected.getOrElse(generatorName, 0)).toDouble</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      (generatorName, numAccepted.getOrElse(generatorName, 0) / total)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    acceptanceRatios.toMap</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We then create the initial sample, where we choose here the center of mass of the model mean as the
rotation center.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def computeCenterOfMass(mesh: TriangleMesh[_3D]): Point[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val normFactor = 1.0 / mesh.pointSet.numberOfPoints</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  mesh.pointSet.points.foldLeft(Point(0, 0, 0))((sum, point) =&gt; sum + point.toVector * normFactor)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val initialParameters = Parameters(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  translationParameters = EuclideanVector(0, 0, 0),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rotationParameters = (0.0, 0.0, 0.0),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  modelCoefficients = DenseVector.zeros[Double](model.rank),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  noiseStddev = 1.0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val initialSample = Sample(&quot;initial&quot;, initialParameters, computeCenterOfMass(model.mean))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p><em>Remark: Setting the rotation center correctly is very important for the rotation proposal to work as expected.
Fortunately, most of the time this error is easy to diagnose, as the acceptance ratio of the rotation proposal will be unexpectedly low.</em></p><p>Next we set up the chain and obtain an iterator.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val chain = MetropolisHastings(generator, posteriorEvaluator)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val logger = new Logger()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mhIterator = chain.iterator(initialSample, logger)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In this example we are interested to visualize some samples from the posterior as we run the chain. This can be done
by augmenting the iterator with visualization code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val samplingIterator = for ((sample, iteration) &lt;- mhIterator.zipWithIndex) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;iteration &quot; + iteration)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (iteration % 500 == 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modelView.shapeModelTransformationView.shapeTransformationView.coefficients = sample.parameters.modelCoefficients</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modelView.shapeModelTransformationView.poseTransformationView.transformation = sample.poseTransformation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sample</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Finally, we draw the samples using the chain by consuming the iterator. We drop the first 1000 iterations, as the
chain needs some burn-in time to converge to a equilibrium solution:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val samples = samplingIterator.drop(1000).take(10000).toIndexedSeq</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Before working with the results, we check the acceptance ratios to verify that all the proposals work as expected:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(logger.acceptanceRatios())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Map(RotationUpdateProposal (0.01) -&gt; 0.27049910873440286, TranlationUpdateProposal (1.0) -&gt; 0.10995475113122172, ShapeUpdateProposal (0.1) -&gt; 0.4661405762525234, NoiseStddevUpdateProposal (0.1) -&gt; 0.8394160583941606)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="analyzing-the-results"></a>Analyzing the results<a aria-hidden="true" class="hash-link" href="#analyzing-the-results" title="Direct link to heading">#</a></h3><p>Once we have the samples, we can now use them to analyze our fit.
For example, we can select the best fit from these samples and visualize it</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val bestSample = samples.maxBy(posteriorEvaluator.logValue)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val bestFit = model.instance(bestSample.parameters.modelCoefficients).transform(bestSample.poseTransformation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val resultGroup = ui.createGroup(&quot;result&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(resultGroup, bestFit, &quot;best fit&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The samples allow us to infer much more about the distribution. For example, we can estimate the expected position of
any point in the model and the variance from the samples:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def computeMean(model: PointDistributionModel[_3D, UnstructuredPointsDomain], id: PointId): Point[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var mean = EuclideanVector(0, 0, 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (sample &lt;- samples) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val modelInstance = model.instance(sample.parameters.modelCoefficients)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val pointForInstance = modelInstance.transform(sample.poseTransformation).pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    mean += pointForInstance.toVector</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (mean * 1.0 / samples.size).toPoint</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def computeCovarianceFromSamples(model: PointDistributionModel[_3D, UnstructuredPointsDomain],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 id: PointId,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 mean: Point[_3D]): SquareMatrix[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var cov = SquareMatrix.zeros[_3D]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (sample &lt;- samples) yield {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val modelInstance = model.instance(sample.parameters.modelCoefficients)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val pointForInstance = modelInstance.transform(sample.poseTransformation).pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val v = pointForInstance - mean</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cov += v.outer(v)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cov * (1.0 / samples.size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>For efficiency reasons, we do the computations here only for the landmark points, using again the marginalized model:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val (marginalizedModel, newCorrespondences) = marginalizeModelForCorrespondences(model, correspondences)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">for ((id, _) &lt;- newCorrespondences) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val meanPointPosition = computeMean(marginalizedModel, id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(s&quot;expected position for point at id $id  = $meanPointPosition&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val cov = computeCovarianceFromSamples(marginalizedModel, id, meanPointPosition)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s&quot;posterior variance computed  for point at id (shape and pose) $id  = ${cov(0, 0)}, ${cov(1, 1)}, ${cov(2, 2)}&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(0)  = Point3D(148.0324861283622,-6.275576357568034,290.59079814866135)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(0)  = 0.5361626780401172, 0.44518844783183426, 0.4712449612711684</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(1)  = Point3D(142.25613155050056,-4.578502616840517,267.6662118948927)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(1)  = 0.3358273564280193, 0.27412211397165964, 0.3834512258930212</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(2)  = Point3D(141.51450447249726,-5.396538351594542,225.53365136081703)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(2)  = 0.32450811724762585, 0.34599403442859433, 0.38706424978868814</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(3)  = Point3D(143.24561920715632,-4.760308138497735,201.7722641818853)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(3)  = 0.5900000898872085, 0.4373150359903246, 0.5292405759059319</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(4)  = Point3D(102.70685297949743,32.6549651676325,248.25560554976087)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(4)  = 0.6541511267089476, 0.6578223533565591, 0.44885292685051964</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// expected position for point at id PointId(5)  = Point3D(136.9987480392464,100.7251991156642,249.83446273567114)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// posterior variance computed  for point at id (shape and pose) PointId(5)  = 0.7664814741591471, 0.7557594068764044, 0.6117844332219701</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="beyond-landmark-fitting"></a>Beyond landmark fitting<a aria-hidden="true" class="hash-link" href="#beyond-landmark-fitting" title="Direct link to heading">#</a></h3><p>We have shown above how Scalismo can be used to perform Bayesian model fitting on the example of fitting 3D landmarks. This example
can easily be extended to other fitting tasks, such as fitting the model to points with unkown correspondences, fitting shapes in surfaces
of fitting a model to an image using an Active Shape Model as a likelihood function. In principle, all that is required is to
change the likelihood function and rerun the fit.
In practice, however, as a change in the likelihood function can dramatically change the posterior density, it is often required
to tune the proposals, such that good convergence can be achieved. Indeed, finding good proposal distributions is the key to
applying this method successfully. The more prior knowledge about the target distribution we can incorporate into the proposals,
the faster will the chain converge to the equilibrium distribution.</p><p>For more complicated use-cases of this method in image analysis , we refer the interested reader is referred to the paper by S. Schönborn et al.
and references therein:</p><ul><li>Schönborn, Sandro, et al. &quot;Markov chain monte carlo for automated face image analysis.&quot; International Journal of Computer Vision 123.2 (2017): 160-183.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/versioned_docs/version-0.90/tutorials/tutorial15.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/tutorials/tutorial14"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Model fitting using MCMC - The basic framework</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/tutorials/scalismo-ui-introduction"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Introduction to Scalismo-ui »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#loading-and-visualizing-the-data" class="table-of-contents__link">Loading and visualizing the data</a></li><li><a href="#the-parameter-class" class="table-of-contents__link">The parameter class</a></li><li><a href="#evaluators-modelling-the-target-density" class="table-of-contents__link">Evaluators: Modelling the target density</a></li><li><a href="#the-proposal-generator" class="table-of-contents__link">The proposal generator</a></li><li><a href="#analyzing-the-results" class="table-of-contents__link">Analyzing the results</a></li><li><a href="#beyond-landmark-fitting" class="table-of-contents__link">Beyond landmark fitting</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Forum</a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitter-Chat</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2021 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4711b045.js"></script>
<script src="/runtime~main.2d058dcb.js"></script>
<script src="/main.8cd2c6cb.js"></script>
<script src="/1.376038f2.js"></script>
<script src="/93.937fb28c.js"></script>
<script src="/95.e7fffad1.js"></script>
<script src="/f68ef350.555d9479.js"></script>
<script src="/92.8a719913.js"></script>
<script src="/868e6417.89a63019.js"></script>
</body>
</html>