<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.68">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Shape modelling with Gaussian processes and kernels | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="0.90"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-0.90"><meta data-react-helmet="true" property="og:title" content="Shape modelling with Gaussian processes and kernels | Scalismo"><meta data-react-helmet="true" name="description" content="In this tutorial we learn how to define our own Gaussian processes using analytically"><meta data-react-helmet="true" property="og:description" content="In this tutorial we learn how to define our own Gaussian processes using analytically"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/tutorials/tutorial7"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/tutorials/tutorial7"><link rel="stylesheet" href="/styles.656a0876.css">
<link rel="preload" href="/styles.0daa2ecb.js" as="script">
<link rel="preload" href="/runtime~main.32a709e5.js" as="script">
<link rel="preload" href="/main.0069e762.js" as="script">
<link rel="preload" href="/1.d0a04477.js" as="script">
<link rel="preload" href="/88.19909525.js" as="script">
<link rel="preload" href="/90.32728c13.js" as="script">
<link rel="preload" href="/f68ef350.93153e1c.js" as="script">
<link rel="preload" href="/87.bdda081e.js" as="script">
<link rel="preload" href="/ca786a3e.3aa3ba20.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_2AhQ">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/docs/">0.90</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/tutorials/tutorial7">Next</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/tutorials/tutorial7">0.90</a></li><li><a class="dropdown__link" href="/docs/0.18/tutorials/tutorial7">0.18</a></li></ul></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/onlinecourse">Online courses</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a class="menu__link" href="/support">Support</a></li><li class="menu__list-item"><a class="menu__link" href="/about">About</a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/next/tutorials/tutorial7">Next</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/tutorials/tutorial7">0.90</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.18/tutorials/tutorial7">0.18</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive thin-scrollbar menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial1">Hello Scalismo!</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial2">tutorial2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial3">From meshes to deformation fields</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial4">Gaussian processes and Point Distribution Models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial5">Gaussian processes, sampling and marginalization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial6">Building a shape model from data</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/tutorials/tutorial7">Shape modelling with Gaussian processes and kernels</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial8">Posterior shape models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial9">Shape completion using GP regression</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/scalismo-ui-introduction">Introduction to Scalismo-ui</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_39qw"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: 0.90</span></div><header><h1 class="docTitle_1Lrw">Shape modelling with Gaussian processes and kernels</h1></header><div class="markdown"><p>In this tutorial we learn how to define our own Gaussian processes using analytically
defined kernels. Further, we experiment with different kernels that are useful in
shape modelling.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="related-resources"></a>Related resources<a aria-hidden="true" class="hash-link" href="#related-resources" title="Direct link to heading">#</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Covariance functions <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250350" target="_blank" rel="noopener noreferrer">(Video)</a></li><li>Constructing kernels for shape modelling <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250351" target="_blank" rel="noopener noreferrer">(Article)</a></li><li>Enlarging the flexibility of statistical shape models <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250357" target="_blank" rel="noopener noreferrer">(Article)</a></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparation"></a>Preparation<a aria-hidden="true" class="hash-link" href="#preparation" title="Direct link to heading">#</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.geometry._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.common._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.common.interpolation.TriangleMeshInterpolator3D</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.mesh._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.io.{StatisticalModelIO, MeshIO}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.statisticalmodel._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.numerics.UniformMeshSampler3D</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.kernels._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.ui.api._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import breeze.linalg.{DenseMatrix, DenseVector}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">scalismo.initialize()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">implicit val rng = scalismo.utils.Random(42)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val ui = ScalismoUI()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In the following we will always visualize the effect of different Gaussian process models,
by applying the deformations to a reference mesh. We therefore start by loading the mesh and visualizing
it in a separate group.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val referenceMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/lowResPaola.ply&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val modelGroup = ui.createGroup(&quot;gp-model&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val referenceView = ui.show(modelGroup, referenceMesh, &quot;reference&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="modelling-deformations-using-gaussian-processes"></a>Modelling deformations using Gaussian processes:<a aria-hidden="true" class="hash-link" href="#modelling-deformations-using-gaussian-processes" title="Direct link to heading">#</a></h2><p>A Gaussian Process is defined by two components: the <strong>mean function</strong> and the <strong>covariance function</strong>.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-mean"></a>The mean:<a aria-hidden="true" class="hash-link" href="#the-mean" title="Direct link to heading">#</a></h5><p>As we are modelling deformation fields, the mean of the Gaussian process will, of course, itself be a deformation field.
In terms of shape models, we can think of the mean function as the deformation field that deforms our reference mesh into the mean shape.</p><p>If the reference shape that we choose corresponds approximately to an average shape, and we do not have any further knowledge
about our shape space, it is entirely reasonable to use a zero mean; I.e. a deformation field which applies to
every point a zero deformation.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val zeroMean = Field(EuclideanSpace3D, (pt:Point[_3D]) =&gt; EuclideanVector3D(0,0,0))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-covariance-function"></a>The covariance function:<a aria-hidden="true" class="hash-link" href="#the-covariance-function" title="Direct link to heading">#</a></h5><p>The covariance function, which is also referred to as a <em>kernel</em>,
defines the properties that characterize likely deformations in our model.
Formally, it is a symmetric, positive semi-definite function,
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>X</mi><mo>→</mo><msup><mi>R</mi><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k: X \times X \to R^{ d \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.03148em">k</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em"></span><span class="mord mathdefault" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span>, which defines the covariance between the
values at any pair of points <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x, x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> of the domain. Since we are modelling deformation
fields (I.e. vector-valued functions), the covariance function is matrix-valued.</p><p>To define a kernel in Scalismo, we need to implement the following methods of the abstract class <code>MatrixValuedPDKernel</code>, which is defined in Scalismo:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class MatrixValuedPDKernel[D]() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    def outputDim: Int;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    def domain: Domain[D];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    def k(x: Point[D], y: Point[D]): DenseMatrix[Double];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p><em>Note: This class is already defined as part of Scalismo. Don&#x27;t paste it into your code.</em></p><p>The field <code>outputDim</code> determines the dimensionality of the values we model. In our case, we model 3D vectors, and hence <code>outputDim</code>should be 3.
The <code>domain</code> indicates the set of points on which our kernel is defined. Most often, we set this to the entire Euclidean space <code>RealSpace3D</code>.
Finally <code>k</code> denotes the covariance function.</p><p>The most often used kernel is the Gaussian kernel. Recall that the scalar-valued Gaussian kernel, is defined by the following formula:</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mo><mi>exp</mi><mo>⁡</mo></mo><mrow><mo>−</mo><mfrac><msup><mrow><mo fence="true">∥</mo><mi>x</mi><mo>−</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">∥</mo></mrow><mn>2</mn></msup><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">k_g(x,x&#x27;) = \exp^{-\frac{\left\lVert x-x&#x27;\right\rVert^2}{\sigma^2} }.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.088em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.6495299999999997em;vertical-align:-0.19444em"></span><span class="mop"><span class="mop">exp</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.4550899999999998em"><span style="top:-3.45509em;margin-right:0.05em"><span class="pstrut" style="height:3.00167em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4309571428571428em"><span style="top:-2.5061857142857145em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em"><span style="top:-2.93844em;margin-right:0.1em"><span class="pstrut" style="height:2.64444em"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.6245204081632654em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen sizing reset-size1 size3 mtight delimcenter" style="top:0.07142857142857142em"><span class="mtight">∥</span></span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9595600000000001em"><span style="top:-2.9595599999999997em;margin-right:0.1em"><span class="pstrut" style="height:2.55556em"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mclose sizing reset-size1 size3 mtight delimcenter" style="top:0.07142857142857142em"><span class="mtight">∥</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1290114285714283em"><span style="top:-3.1290114285714283em;margin-right:0.1em"><span class="pstrut" style="height:2.64444em"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">.</span></span></span></span></span></div><p>A corresponding matrix-valued kernel can be obtained by multiplying the value with an identity matrix (which implies, that we treat each space dimension as independent). In Scalismo, this is defined as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class MatrixValuedGaussianKernel3D(sigma2 : Double) extends MatrixValuedPDKernel[_3D]() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def outputDim: Int = 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def domain: Domain[_3D] = EuclideanSpace3D;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def k(x: Point[_3D], y: Point[_3D]): DenseMatrix[Double] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    DenseMatrix.eye[Double](outputDim) * Math.exp(- (x - y).norm2 / sigma2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>This constructions allows us to define any kernel. For the most commonly used ones, such as the Gaussian kernel, there is, however,
an easier way in Scalismo. First, the scalar-valued Gaussian kernel is already implemented in Scalismo:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val scalarValuedGaussianKernel : PDKernel[_3D]= GaussianKernel3D(sigma = 100.0)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Further, the class <code>DiagonalKernel</code>allows us to turn any scalar-valued kernel into a matrix-valued kernel,
by specifying for each dimension of the output-space a kernel and assuming them to be independent. To obtain the same kernel as defined above, we can write:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val matrixValuedGaussianKernel = DiagonalKernel3D(scalarValuedGaussianKernel, scalarValuedGaussianKernel, scalarValuedGaussianKernel)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In this case, since we are using the same kernel in every space dimension, we can write this even more succinct as:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">DiagonalKernel3D(scalarValuedGaussianKernel, 3)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-the-gp-"></a>Building the GP :<a aria-hidden="true" class="hash-link" href="#building-the-gp-" title="Direct link to heading">#</a></h5><p>Now that we have our mean and covariance functions, we can build a Gaussian process as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gp = GaussianProcess3D[EuclideanVector[_3D]](zeroMean, matrixValuedGaussianKernel)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We can now sample deformations from our Gaussian process <strong>at any desired set of points</strong>. Below we choose the points to be those of the reference mesh:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sampleGroup = ui.createGroup(&quot;samples&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sample = gp.sampleAtPoints(referenceMesh)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(sampleGroup, sample, &quot;gaussianKernelGP_sample&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The result is an instance from the Gaussian Process evaluated at the points
we indicated;  in this case on the points of the reference mesh.</p><p>We can visualize its effect by interpolating the deformation field, which we then use to deform the reference mesh:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val interpolatedSample = sample.interpolate(TriangleMeshInterpolator3D())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val deformedMesh = referenceMesh.transform((p : Point[_3D]) =&gt; p + interpolatedSample(p))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(sampleGroup, deformedMesh, &quot;deformed mesh&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="low-rank-approximation"></a>Low-rank approximation<a aria-hidden="true" class="hash-link" href="#low-rank-approximation" title="Direct link to heading">#</a></h4><p>Whenever we create a sample using the <code>sampleAtPoints</code> method of the Gaussian process, internally a matrix of dimensionality <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>d</mi><mo>×</mo><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">nd \times nd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span></span>,where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">n</span></span></span></span></span> denotes the number of points and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault">d</span></span></span></span></span> the dimensionality of the output space, is created. Hence if we want to sample
from many points we quickly run out of memory.</p><p>We can get around this problem by computing a low-rank approximation of the Gaussian process.
To obtain such a representation in Scalismo, we can use the method
`<code>approximateGPCholesky</code> of the <em>LowRankGaussianProcess</em> object.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  referenceMesh,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  gp,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  relativeTolerance = 0.01,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>This call computes a finite-rank approximation of the Gaussian Process using a
Pivoted Cholesky approximation. The procedure automatically chooses the rank (I.e. the
number of basis functions of the Gaussian process), such that the given relative error
is achieved. (The error is measures in terms of the variance of the Gaussian
process, approximated on the points of the reference Mesh).
Using this low rank Gaussian process, we can now directly sample continuous deformation fields:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val  defField : Field[_3D, EuclideanVector[_3D]]= lowRankGP.sample</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>These in turn, can be used to warp a reference mesh, as discussed above:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">referenceMesh.transform((p : Point[_3D]) =&gt; p + defField(p))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>More conveniently, we can visualize the sampled meshes by building again a <code>StatisticalMeshModel</code>,</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val pdm = PointDistributionModel3D(referenceMesh, lowRankGP)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>which we can directly visualize</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val pdmView = ui.show(modelGroup, pdm, &quot;group&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="building-more-interesting-kernels"></a>Building more interesting kernels<a aria-hidden="true" class="hash-link" href="#building-more-interesting-kernels" title="Direct link to heading">#</a></h3><p>In the following we show a few more examples of kernels, which are interesting for shape modelling.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kernels-from-statistical-shape-models"></a>Kernels from Statistical Shape Models<a aria-hidden="true" class="hash-link" href="#kernels-from-statistical-shape-models" title="Direct link to heading">#</a></h4><p>As discussed previously, a Statistical Shape Model (SSM) in Scalismo is a discrete Gaussian process.
We have seen how to interpolate it to obtain a continuously defined Gaussian Process. As any
Gaussian process is  completely defined by its mean and covariance function, it follows that this is
also true for the GP in our statistical shape model.</p><p>This allows us to use this <em>sample covariance kernel</em> in combination with other kernels.
For example, we often want to slightly enlarge the flexibility of our statistical models.
In the following, we show how this can be achieved.</p><p>In a first step, we get the Gaussian process from the model an interpolate it.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val pcaModel = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File(&quot;datasets/lowresModel.h5&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gpSSM = pcaModel.gp.interpolate(TriangleMeshInterpolator3D())</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>We can then access its covariance function, which is a kernel:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val covSSM : MatrixValuedPDKernel[_3D] = gpSSM.cov</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>In the next step, we model the additional variance using a Gaussian kernel and add it to the
<em>sample covariance kernel</em>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val augmentedCov = covSSM + DiagonalKernel(GaussianKernel[_3D](100.0), 3)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Finally, we build the Gaussian process with the new kernel.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val augmentedGP = GaussianProcess(gpSSM.mean, augmentedCov)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>From here on, we follow the steps outlined above to obtain the <em>augmented</em> SSM.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val lowRankAugmentedGP = LowRankGaussianProcess.approximateGPCholesky(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  referenceMesh,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  augmentedGP,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  relativeTolerance = 0.01,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val augmentedSSM = PointDistributionModel3D(pcaModel.reference, lowRankAugmentedGP)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="changepoint-kernel"></a>Changepoint kernel:<a aria-hidden="true" class="hash-link" href="#changepoint-kernel" title="Direct link to heading">#</a></h4><p>Another very useful kernel is the <em>changepoint kernel</em>.
A changepoint kernel is a combination of different kernels, where each kernel is active only in
a certain region of the space.</p><p>Here we show how we can define a kernel, which has different behavior in two different regions.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class ChangePointKernel(kernel1 : MatrixValuedPDKernel[_3D], kernel2 : MatrixValuedPDKernel[_3D])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  extends MatrixValuedPDKernel[_3D]() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def domain = EuclideanSpace[_3D]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val outputDim = 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def s(p: Point[_3D]) =  1.0 / (1.0 + math.exp(-p(0)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def k(x: Point[_3D], y: Point[_3D]) = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val sx = s(x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val sy = s(y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    kernel1(x,y) * sx * sy + kernel2(x,y) * (1-sx) * (1-sy)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Let&#x27;s visualize its effect with two different Gaussian Kernels</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gk1 = DiagonalKernel3D(GaussianKernel3D(100.0), 3)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gk2 = DiagonalKernel3D(GaussianKernel3D(10.0), 3)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val changePointKernel = ChangePointKernel(gk1, gk2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gpCP = GaussianProcess3D(zeroMean, changePointKernel)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sampleCP =  gpCP.sampleAtPoints(referenceMesh)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(sampleGroup, sampleCP, &quot;ChangePointKernelGP_sample&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As you can see each kernel is now active only on one half of the face.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="symmetrizing-a-kernel"></a>Symmetrizing a kernel<a aria-hidden="true" class="hash-link" href="#symmetrizing-a-kernel" title="Direct link to heading">#</a></h4><p>Quite often, the shapes that we aim to model exhibit a symmetry. This is particularly valid in the case of faces.
Therefore when modelling over such shapes, one would want deformation fields that yield symmetric shapes.</p><p>Once we obtained a kernel yielding the type of deformations we desire, it is possible to symmetrize the resulting deformation fields by applying the formula below:</p><img src="data:image/png;base64,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"><p>where <em>x<sub>m</sub></em> is the symmetric point to <em>x</em> around the YZ plane.</p><p>The resulting kernel will preserve the same smoothness properties of the deformation fields while adding the symmetry around the YZ plane.</p><p>Let&#x27;s turn it into code:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">case class xMirroredKernel(kernel : PDKernel[_3D]) extends PDKernel[_3D] {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def domain = kernel.domain</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override def k(x: Point[_3D], y: Point[_3D]) = kernel(Point(x(0) * -1.0 ,x(1), x(2)), y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def symmetrizeKernel(kernel : PDKernel[_3D]) : MatrixValuedPDKernel[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val xmirrored = xMirroredKernel(kernel)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val k1 = DiagonalKernel(kernel, 3)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val k2 = DiagonalKernel(xmirrored * -1f, xmirrored, xmirrored)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  k1 + k2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val symmetrizedGaussian = symmetrizeKernel(GaussianKernel[_3D](100))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val gpSym = GaussianProcess3D(zeroMean, symmetrizedGaussian)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sampleGpSym =  gpSym.sampleAtPoints(referenceMesh)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(sampleGroup, sampleGpSym, &quot;ChangePointKernelGP_sample&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/versioned_docs/version-0.90/tutorials/tutorial7.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/tutorials/tutorial6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Building a shape model from data</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/tutorials/tutorial8"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Posterior shape models »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#modelling-deformations-using-gaussian-processes" class="table-of-contents__link">Modelling deformations using Gaussian processes:</a><ul><li><a href="#building-more-interesting-kernels" class="table-of-contents__link">Building more interesting kernels</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Forum</a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitter-Chat</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2021 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.0daa2ecb.js"></script>
<script src="/runtime~main.32a709e5.js"></script>
<script src="/main.0069e762.js"></script>
<script src="/1.d0a04477.js"></script>
<script src="/88.19909525.js"></script>
<script src="/90.32728c13.js"></script>
<script src="/f68ef350.93153e1c.js"></script>
<script src="/87.bdda081e.js"></script>
<script src="/ca786a3e.3aa3ba20.js"></script>
</body>
</html>