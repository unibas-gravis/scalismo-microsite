<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Scalismo RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Scalismo Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Shape modelling with Gaussian processes and kernels | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/next/Tutorials/tutorial07"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Shape modelling with Gaussian processes and kernels | Scalismo"><meta data-react-helmet="true" name="description" content="In this tutorial we learn how to define our own Gaussian processes using analytically"><meta data-react-helmet="true" property="og:description" content="In this tutorial we learn how to define our own Gaussian processes using analytically"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/next/Tutorials/tutorial07"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial07" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial07" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4461d896.css">
<link rel="preload" href="/assets/js/runtime~main.d00950fd.js" as="script">
<link rel="preload" href="/assets/js/main.78368e62.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Scalismo</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/next">Next</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/next/Tutorials/tutorial07">Next</a></li><li><a class="dropdown__link" href="/docs/Tutorials/tutorial07">0.91.0</a></li><li><a class="dropdown__link" href="/docs/0.90/Tutorials/tutorial07">0.90</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/Setup/ide">Setup</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/next/Tutorials/tutorial01">Tutorials</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial01">Hello Scalismo!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial02">Rigid Alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial03">From meshes to deformation fields</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial04">Gaussian processes and Point Distribution Models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial05">Gaussian processes, sampling and marginalization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial06">Building a shape model from data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/next/Tutorials/tutorial07">Shape modelling with Gaussian processes and kernels</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial08">Posterior shape models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial09">Shape completion using GP regression</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/scalismo-ui-introduction">Others</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->Scalismo<!-- --> <b>Next</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/Tutorials/tutorial07">latest version</a></b> (<!-- -->0.91.0<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->Next</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Shape modelling with Gaussian processes and kernels</h1></header><p>In this tutorial we learn how to define our own Gaussian processes using analytically
defined kernels. Further, we experiment with different kernels that are useful in
shape modelling.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="related-resources">Related resources<a class="hash-link" href="#related-resources" title="Direct link to heading">​</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Covariance functions <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250350" target="_blank" rel="noopener noreferrer">(Video)</a></li><li>Constructing kernels for shape modelling <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250351" target="_blank" rel="noopener noreferrer">(Article)</a></li><li>Enlarging the flexibility of statistical shape models <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250357" target="_blank" rel="noopener noreferrer">(Article)</a></li></ul><p>To run the code from this tutorial, download the following Scala file:</p><ul><li><a target="_blank" href="/assets/files/Tutorial07-bf68fd2f22a8457875db33d3393a204e.scala">Tutorial07.scala</a></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="preparation">Preparation<a class="hash-link" href="#preparation" title="Direct link to heading">​</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.geometry._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.interpolation.TriangleMeshInterpolator3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.mesh._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.io.{StatisticalModelIO, MeshIO}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.statisticalmodel._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.numerics.UniformMeshSampler3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.kernels._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.ui.api._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.{DenseMatrix, DenseVector}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">scalismo.initialize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">implicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val ui = ScalismoUI()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the following we will always visualize the effect of different Gaussian process models,
by applying the deformations to a reference mesh. We therefore start by loading the mesh and visualizing
it in a separate group.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val referenceMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/lowResPaola.ply&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val modelGroup = ui.createGroup(&quot;gp-model&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val referenceView = ui.show(modelGroup, referenceMesh, &quot;reference&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="modelling-deformations-using-gaussian-processes">Modelling deformations using Gaussian processes:<a class="hash-link" href="#modelling-deformations-using-gaussian-processes" title="Direct link to heading">​</a></h2><p>A Gaussian Process is defined by two components: the <strong>mean function</strong> and the <strong>covariance function</strong>.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="the-mean">The mean:<a class="hash-link" href="#the-mean" title="Direct link to heading">​</a></h5><p>As we are modelling deformation fields, the mean of the Gaussian process will, of course, itself be a deformation field.
In terms of shape models, we can think of the mean function as the deformation field that deforms our reference mesh into the mean shape.</p><p>If the reference shape that we choose corresponds approximately to an average shape, and we do not have any further knowledge
about our shape space, it is entirely reasonable to use a zero mean; I.e. a deformation field which applies to
every point a zero deformation.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val zeroMean = Field(EuclideanSpace3D, (pt:Point[_3D]) =&gt; EuclideanVector3D(0,0,0))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="the-covariance-function">The covariance function:<a class="hash-link" href="#the-covariance-function" title="Direct link to heading">​</a></h5><p>The covariance function, which is also referred to as a <em>kernel</em>,
defines the properties that characterize likely deformations in our model.
Formally, it is a symmetric, positive semi-definite function,
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>X</mi><mo>→</mo><msup><mi>R</mi><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k: X \times X \to R^{ d \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em"></span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span>, which defines the covariance between the
values at any pair of points <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x, x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> of the domain. Since we are modelling deformation
fields (I.e. vector-valued functions), the covariance function is matrix-valued.</p><p>To define a kernel in Scalismo, we need to implement the following methods of the abstract class <code>MatrixValuedPDKernel</code>, which is defined in Scalismo:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class MatrixValuedPDKernel[D]() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def outputDim: Int;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def domain: Domain[D];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def k(x: Point[D], y: Point[D]): DenseMatrix[Double];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><em>Note: This class is already defined as part of Scalismo. Don&#x27;t paste it into your code.</em></p><p>The field <code>outputDim</code> determines the dimensionality of the values we model. In our case, we model 3D vectors, and hence <code>outputDim</code>should be 3.
The <code>domain</code> indicates the set of points on which our kernel is defined. Most often, we set this to the entire Euclidean space <code>RealSpace3D</code>.
Finally <code>k</code> denotes the covariance function.</p><p>The most often used kernel is the Gaussian kernel. Recall that the scalar-valued Gaussian kernel, is defined by the following formula:</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>k</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mo><mi>exp</mi><mo>⁡</mo></mo><mrow><mo>−</mo><mfrac><msup><mrow><mo fence="true">∥</mo><mi>x</mi><mo>−</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">∥</mo></mrow><mn>2</mn></msup><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">k_g(x,x&#x27;) = \exp^{-\frac{\left\lVert x-x&#x27;\right\rVert^2}{\sigma^2} }.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.088em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.6495299999999997em;vertical-align:-0.19444em"></span><span class="mop"><span class="mop">exp</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.4550899999999998em"><span style="top:-3.45509em;margin-right:0.05em"><span class="pstrut" style="height:3.00167em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4309571428571428em"><span style="top:-2.5061857142857145em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em"><span style="top:-2.93844em;margin-right:0.1em"><span class="pstrut" style="height:2.64444em"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.6245204081632654em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen sizing reset-size1 size3 mtight delimcenter" style="top:0.07142857142857142em"><span class="mtight">∥</span></span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9595600000000001em"><span style="top:-2.9595599999999997em;margin-right:0.1em"><span class="pstrut" style="height:2.55556em"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mclose sizing reset-size1 size3 mtight delimcenter" style="top:0.07142857142857142em"><span class="mtight">∥</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1290114285714283em"><span style="top:-3.1290114285714283em;margin-right:0.1em"><span class="pstrut" style="height:2.64444em"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">.</span></span></span></span></span></div><p>A corresponding matrix-valued kernel can be obtained by multiplying the value with an identity matrix (which implies, that we treat each space dimension as independent). In Scalismo, this is defined as follows:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">case class MatrixValuedGaussianKernel3D(sigma2 : Double) extends MatrixValuedPDKernel[_3D]() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def outputDim: Int = 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def domain: Domain[_3D] = EuclideanSpace3D;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def k(x: Point[_3D], y: Point[_3D]): DenseMatrix[Double] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DenseMatrix.eye[Double](outputDim) * Math.exp(- (x - y).norm2 / sigma2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This constructions allows us to define any kernel. For the most commonly used ones, such as the Gaussian kernel, there is, however,
an easier way in Scalismo. First, the scalar-valued Gaussian kernel is already implemented in Scalismo:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val scalarValuedGaussianKernel : PDKernel[_3D]= GaussianKernel3D(sigma = 100.0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Further, the class <code>DiagonalKernel</code>allows us to turn any scalar-valued kernel into a matrix-valued kernel,
by specifying for each dimension of the output-space a kernel and assuming them to be independent. To obtain the same kernel as defined above, we can write:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val matrixValuedGaussianKernel = DiagonalKernel3D(scalarValuedGaussianKernel, scalarValuedGaussianKernel, scalarValuedGaussianKernel)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In this case, since we are using the same kernel in every space dimension, we can write this even more succinct as:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">DiagonalKernel3D(scalarValuedGaussianKernel, 3)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="building-the-gp-">Building the GP :<a class="hash-link" href="#building-the-gp-" title="Direct link to heading">​</a></h5><p>Now that we have our mean and covariance functions, we can build a Gaussian process as follows:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val gp = GaussianProcess3D[EuclideanVector[_3D]](zeroMean, matrixValuedGaussianKernel)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can now sample deformations from our Gaussian process <strong>at any desired set of points</strong>. Below we choose the points to be those of the reference mesh:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val sampleGroup = ui.createGroup(&quot;samples&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val sample = gp.sampleAtPoints(referenceMesh)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(sampleGroup, sample, &quot;gaussianKernelGP_sample&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The result is an instance from the Gaussian Process evaluated at the points
we indicated;  in this case on the points of the reference mesh.</p><p>We can visualize its effect by interpolating the deformation field, which we then use to deform the reference mesh:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val interpolatedSample = sample.interpolate(TriangleMeshInterpolator3D())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val deformedMesh = referenceMesh.transform((p : Point[_3D]) =&gt; p + interpolatedSample(p))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(sampleGroup, deformedMesh, &quot;deformed mesh&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="low-rank-approximation">Low-rank approximation<a class="hash-link" href="#low-rank-approximation" title="Direct link to heading">​</a></h4><p>Whenever we create a sample using the <code>sampleAtPoints</code> method of the Gaussian process, internally a matrix of dimensionality <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>d</mi><mo>×</mo><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">nd \times nd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span></span>,where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathnormal">n</span></span></span></span></span> denotes the number of points and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal">d</span></span></span></span></span> the dimensionality of the output space, is created. Hence if we want to sample
from many points we quickly run out of memory.</p><p>We can get around this problem by computing a low-rank approximation of the Gaussian process.
To obtain such a representation in Scalismo, we can use the method
`<code>approximateGPCholesky</code> of the <em>LowRankGaussianProcess</em> object.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  referenceMesh,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  gp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  relativeTolerance = 0.01,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This call computes a finite-rank approximation of the Gaussian Process using a
Pivoted Cholesky approximation. The procedure automatically chooses the rank (I.e. the
number of basis functions of the Gaussian process), such that the given relative error
is achieved. (The error is measures in terms of the variance of the Gaussian
process, approximated on the points of the reference Mesh).
Using this low rank Gaussian process, we can now directly sample continuous deformation fields:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val  defField : Field[_3D, EuclideanVector[_3D]]= lowRankGP.sample()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>These in turn, can be used to warp a reference mesh, as discussed above:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">referenceMesh.transform((p : Point[_3D]) =&gt; p + defField(p))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>More conveniently, we can visualize the sampled meshes by building again a Point Distribution Model:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val pdm = PointDistributionModel3D(referenceMesh, lowRankGP)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This model can be visualized directly in ScalismoUI.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val pdmView = ui.show(modelGroup, pdm, &quot;group&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="building-more-interesting-kernels">Building more interesting kernels<a class="hash-link" href="#building-more-interesting-kernels" title="Direct link to heading">​</a></h3><p>In the following we show a few more examples of kernels, which are interesting for shape modelling.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="kernels-from-statistical-shape-models">Kernels from Statistical Shape Models<a class="hash-link" href="#kernels-from-statistical-shape-models" title="Direct link to heading">​</a></h4><p>As discussed previously, a Statistical Shape Model (SSM) in Scalismo is a discrete Gaussian process.
We have seen how to interpolate it to obtain a continuously defined Gaussian Process. As any
Gaussian process is  completely defined by its mean and covariance function, it follows that this is
also true for the GP in our statistical shape model.</p><p>This allows us to use this <em>sample covariance kernel</em> in combination with other kernels.
For example, we often want to slightly enlarge the flexibility of our statistical models.
In the following, we show how this can be achieved.</p><p>In a first step, we get the Gaussian process from the model an interpolate it.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val pcaModel = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File(&quot;datasets/lowresModel.h5&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val gpSSM = pcaModel.gp.interpolate(TriangleMeshInterpolator3D())</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can then access its covariance function, which is a kernel:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val covSSM : MatrixValuedPDKernel[_3D] = gpSSM.cov</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the next step, we model the additional variance using a Gaussian kernel and add it to the
<em>sample covariance kernel</em>.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val augmentedCov = covSSM + DiagonalKernel(GaussianKernel[_3D](100.0), 3)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, we build the Gaussian process with the new kernel.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val augmentedGP = GaussianProcess(gpSSM.mean, augmentedCov)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>From here on, we follow the steps outlined above to obtain the <em>augmented</em> SSM.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val lowRankAugmentedGP = LowRankGaussianProcess.approximateGPCholesky(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  referenceMesh,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  augmentedGP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  relativeTolerance = 0.01,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val augmentedSSM = PointDistributionModel3D(pcaModel.reference, lowRankAugmentedGP)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="changepoint-kernel">Changepoint kernel:<a class="hash-link" href="#changepoint-kernel" title="Direct link to heading">​</a></h4><p>Another very useful kernel is the <em>changepoint kernel</em>.
A changepoint kernel is a combination of different kernels, where each kernel is active only in
a certain region of the space.</p><p>Here we show how we can define a kernel, which has different behavior in two different regions.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">case class ChangePointKernel(kernel1 : MatrixValuedPDKernel[_3D], kernel2 : MatrixValuedPDKernel[_3D])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends MatrixValuedPDKernel[_3D]() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def domain = EuclideanSpace[_3D]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val outputDim = 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def s(p: Point[_3D]) =  1.0 / (1.0 + math.exp(-p(0)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def k(x: Point[_3D], y: Point[_3D]) = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val sx = s(x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val sy = s(y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel1(x,y) * sx * sy + kernel2(x,y) * (1-sx) * (1-sy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s visualize its effect with two different Gaussian Kernels</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val gk1 = DiagonalKernel3D(GaussianKernel3D(100.0), 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val gk2 = DiagonalKernel3D(GaussianKernel3D(10.0), 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val changePointKernel = ChangePointKernel(gk1, gk2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val gpCP = GaussianProcess3D(zeroMean, changePointKernel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val sampleCP =  gpCP.sampleAtPoints(referenceMesh)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(sampleGroup, sampleCP, &quot;ChangePointKernelGP_sample&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you can see each kernel is now active only on one half of the face.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="symmetrizing-a-kernel">Symmetrizing a kernel<a class="hash-link" href="#symmetrizing-a-kernel" title="Direct link to heading">​</a></h4><p>Quite often, the shapes that we aim to model exhibit a symmetry. This is particularly valid in the case of faces.
Therefore when modelling over such shapes, one would want deformation fields that yield symmetric shapes.</p><p>Once we obtained a kernel yielding the type of deformations we desire, it is possible to symmetrize the resulting deformation fields by applying the formula below:</p><img src="data:image/png;base64,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"><p>where <em>x<sub>m</sub></em> is the symmetric point to <em>x</em> around the YZ plane.</p><p>The resulting kernel will preserve the same smoothness properties of the deformation fields while adding the symmetry around the YZ plane.</p><p>Let&#x27;s turn it into code:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">case class xMirroredKernel(kernel : PDKernel[_3D]) extends PDKernel[_3D] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def domain = kernel.domain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def k(x: Point[_3D], y: Point[_3D]) = kernel(Point(x(0) * -1.0 ,x(1), x(2)), y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def symmetrizeKernel(kernel : PDKernel[_3D]) : MatrixValuedPDKernel[_3D] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val xmirrored = xMirroredKernel(kernel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val k1 = DiagonalKernel(kernel, 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val k2 = DiagonalKernel(xmirrored * -1f, xmirrored, xmirrored)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  k1 + k2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val symmetrizedGaussian = symmetrizeKernel(GaussianKernel[_3D](100))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val gpSym = GaussianProcess3D(zeroMean, symmetrizedGaussian)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val sampleGpSym =  gpSym.sampleAtPoints(referenceMesh)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(sampleGroup, sampleGpSym, &quot;ChangePointKernelGP_sample&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial07.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/Tutorials/tutorial06"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Building a shape model from data</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/Tutorials/tutorial08"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Posterior shape models</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#modelling-deformations-using-gaussian-processes" class="table-of-contents__link toc-highlight">Modelling deformations using Gaussian processes:</a><ul><li><a href="#building-more-interesting-kernels" class="table-of-contents__link toc-highlight">Building more interesting kernels</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitter-Chat<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d00950fd.js"></script>
<script src="/assets/js/main.78368e62.js"></script>
</body>
</html>