<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Scalismo RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Scalismo Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Parametric, non-rigid registration | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/next/Tutorials/tutorial12"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Parametric, non-rigid registration | Scalismo"><meta data-react-helmet="true" name="description" content="We have seen how non-rigid ICP can be used to establish correspondences."><meta data-react-helmet="true" property="og:description" content="We have seen how non-rigid ICP can be used to establish correspondences."><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/next/Tutorials/tutorial12"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial12" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial12" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4461d896.css">
<link rel="preload" href="/assets/js/runtime~main.eba254cd.js" as="script">
<link rel="preload" href="/assets/js/main.1558c061.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Scalismo</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/next">Next</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/next/Tutorials/tutorial12">Next</a></li><li><a class="dropdown__link" href="/docs/Tutorials/tutorial12">0.91.0</a></li><li><a class="dropdown__link" href="/docs/0.90/Tutorials/tutorial12">0.90</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/Setup/ide">Setup</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/next/Tutorials/tutorial01">Tutorials</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial01">Hello Scalismo!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial02">Rigid Alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial03">From meshes to deformation fields</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial04">Gaussian processes and Point Distribution Models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial05">Gaussian processes, sampling and marginalization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial06">Building a shape model from data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial07">Shape modelling with Gaussian processes and kernels</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial08">Posterior shape models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial09">Shape completion using GP regression</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/next/Tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/scalismo-ui-introduction">Others</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->Scalismo<!-- --> <b>Next</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/Tutorials/tutorial12">latest version</a></b> (<!-- -->0.91.0<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->Next</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Parametric, non-rigid registration</h1></header><p>We have seen how non-rigid ICP can be used to establish correspondences.
In this tutorial we discuss a different approach to model-fitting and non-rigid registration.
We are formulating the registration problem as an optimization problem, which we optimize
using gradient-based optimization.</p><p>This registration is more general than ICP, in the sense that it can not only
be used for surface-to-surface registration, but also for image-to-image-registration.
In this tutorial we show the complete work-flow involved in a typical registration task,
from building the Gaussian process model to performing the actual optimization.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="related-resources">Related resources<a class="hash-link" href="#related-resources" title="Direct link to heading">â€‹</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371" target="_blank" rel="noopener noreferrer">(Video)</a></li></ul><p>To run the code from this tutorial, download the following Scala file:</p><ul><li><a target="_blank" href="/assets/files/Tutorial12-8df84448c8575c285374f8dc392d81c0.scala">Tutorial12.scala</a></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="preparation">Preparation<a class="hash-link" href="#preparation" title="Direct link to heading">â€‹</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.geometry._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.interpolation._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.mesh._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.registration._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.io.MeshIO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.numerics._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.kernels._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.statisticalmodel._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.DenseVector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.ui.api._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.{DenseVector}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">scalismo.initialize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">implicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val ui = ScalismoUI()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="loading-and-visualizing-a-mesh">Loading and visualizing a mesh<a class="hash-link" href="#loading-and-visualizing-a-mesh" title="Direct link to heading">â€‹</a></h2><p>We start by loading and visualizing the reference mesh, which we will later use as the
domain for our Gaussian Process model.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val referenceMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/quickstart/facemesh.ply&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val modelGroup = ui.createGroup(&quot;model&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val refMeshView = ui.show(modelGroup, referenceMesh, &quot;referenceMesh&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">refMeshView.color = java.awt.Color.RED</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="building-a-gaussian-process-shape-model">Building a Gaussian process shape model<a class="hash-link" href="#building-a-gaussian-process-shape-model" title="Direct link to heading">â€‹</a></h2><p>We assume that our reference surface represents an approximately average face.
This justifies the use of a zero-mean Gaussian process. As a covariance function we use a Gaussian kernel and choose to treat the x,y,z component
of the vector field to be uncorrelated (indicated by the use of the <code>DiagonalKernel</code>).</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val zeroMean = Field(EuclideanSpace3D, (_: Point[_3D]) =&gt; EuclideanVector.zeros[_3D])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val kernel = DiagonalKernel3D(GaussianKernel3D(sigma = 70) * 50.0, outputDim = 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val gp = GaussianProcess(zeroMean, kernel)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We then perform a low-rank approximation, to get a parametric representation of the
Gaussian process:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val interpolator = TriangleMeshInterpolator3D[EuclideanVector[_3D]]()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    referenceMesh,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    relativeTolerance = 0.05,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interpolator = interpolator)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To visualize the effect of this Gaussian process, we add it to the
model group as a transformation.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val gpView = ui.addTransformation(modelGroup, lowRankGP, &quot;gp&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This has the effect, that the transformations represented by this GP,
are applied to all the geometric objects, which are present in the group.
In this case, it is the mean of the Gaussian process, which is applied to
the reference mesh we loaded previously. By changing the parameters in the
ui, we can visualize different transformations, as we did previously
for statistical shape models.</p><p><em>Note: Adding the reference mesh to the scene, followed by a Gaussian process transformation
is indeed what happend internally, we visualized Statistical Shape Models in the
previous tutorials</em></p><p>Having visualized the Gaussian process, we can now draw random samples,
to assess whether out choice of parameters of the Gaussian process leads to
reasonable deformations. If not, we adjust the parameters until we are happy
with the deformations that are modelled.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="registration">Registration<a class="hash-link" href="#registration" title="Direct link to heading">â€‹</a></h2><p>In the next step we perform the registration to a target mesh.
We start by loading the target mesh and displaying it.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val targetGroup = ui.createGroup(&quot;target&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetMesh = MeshIO.readMesh(new java.io.File(&quot;datasets/quickstart/face-2.ply&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetMeshView = ui.show(targetGroup, targetMesh, &quot;targetMesh&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><em>To visualize a registration, it is best to change the perspective in the graphical user interface to &quot;orthogonal slices&quot;. You can find this functionality in the &quot;View -&gt; Perspective&quot; menu.</em></p><p>To define a registration, we need to define four things:</p><ol><li>a <code>transformation space</code> that models the possible transformations of the reference surface (or the ambient space)</li><li>a <code>metric</code> to measure the distance between the model (the deformed reference mesh) an the target surface.</li><li>a <code>regularizer</code>, which penalizes unlikely transformations.</li><li>an <code>optimizer</code>.</li></ol><p>For non-rigid registration we usually model the possible transformations using a Gaussian process. We use the Gaussian process that
we have defined above to define the transformation space.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As a metric, we use a simple mean squares metric. Currently, all metrics that are available in scalismo are implemented as
image to image metrics. These can, however, easily be used for surface registration by representing the surface as  a distance image.
In addition to the images, the metric also needs to know the possible transformations (as modelled by the transformation space) and
a sampler. The sampler determines the points where the metric is evaluated. In our case we choose uniformely sampled points on the
reference mesh.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val fixedImage = referenceMesh.operations.toDistanceImage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val movingImage = targetMesh.operations.toDistanceImage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val sampler = FixedPointsUniformMeshSampler3D(referenceMesh, numberOfPoints = 1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val metric = MeanSquaresMetric(fixedImage, movingImage, transformationSpace, sampler)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As an optimizer, we choose an LBFGS Optimizer</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val optimizer = LBFGSOptimizer(maxNumberOfIterations = 100)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>and for regularization we choose to penalize the L2 norm using the <code>L2Regularizer</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val regularizer = L2Regularizer(transformationSpace)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We are now ready to define Scalismo&#x27;s registration object.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val registration = Registration(metric, regularizer, regularizationWeight = 1e-5, optimizer)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Registration is an iterative process. Consequently, we work with the registration using an iterator. We obtain an iterator by
calling the <code>iterator</code> method, where we also provide a starting position for the iteration (which is in this case the zero vector):</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val initialCoefficients = DenseVector.zeros[Double](lowRankGP.rank)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val registrationIterator = registration.iterator(initialCoefficients)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Before running the registration, we change the iterator such that it prints in each iteration to current objective value,
and updates the visualization. This lets us visually inspect the progress of the registration procedure.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val visualizingRegistrationIterator = for ((it, itnum) &lt;- registrationIterator.zipWithIndex) yield {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(s&quot;object value in iteration $itnum is ${it.value}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  gpView.coefficients = it.parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that the above code does not yet run the registration. It simply returns a new iterator, which augments
the original iteration with visualization. The actual registration is executed once we &quot;consume&quot; the iterator.
This can, for example be achieved by converting it to a sequence. The resulting sequence holds all the intermediate
states of the registration. We are usually only interested in the last one:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val registrationResult = visualizingRegistrationIterator.toSeq.last</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>You should see in the graphical user interface, how the face mesh slowly adapts to the shape of the target mesh.</p><p>The final mesh representation can be obtained by obtaining the transform corresponding to the parameters and to
warp the reference mesh with this tranform:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val registrationTransformation = transformationSpace.transformationForParameters(registrationResult.parameters)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val fittedMesh = referenceMesh.transform(registrationTransformation)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="working-with-the-registration-result">Working with the registration result<a class="hash-link" href="#working-with-the-registration-result" title="Direct link to heading">â€‹</a></h3><p>The fittedMesh that we obtained above is a surface that approximates the target surface.  It corresponds to the best representation of the target in the model. For most tasks, this approximation is sufficient.
However, sometimes, we need an exact representation of the target mesh. This can be achieved by defining a projection function, which projects each point onto its closest point on the target.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val targetMeshOperations = targetMesh.operations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val projection = (pt: Point[_3D]) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetMeshOperations.closestPointOnSurface(pt).point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Composing the result of the registration with this projection, will give us a mapping that identifies for each point of the reference mesh the corresponding point of the target mesh.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val finalTransformation = registrationTransformation.andThen(projection)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To check this last point, we warp the reference mesh with the finalTransform and visualize it. Note that the projected target now coincides with the target mesh..</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val projectedMesh = referenceMesh.transform(finalTransformation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val resultGroup = ui.createGroup(&quot;result&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val projectionView = ui.show(resultGroup, projectedMesh, &quot;projection&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="improving-registrations-for-more-complex-shapes">Improving registrations for more complex shapes.<a class="hash-link" href="#improving-registrations-for-more-complex-shapes" title="Direct link to heading">â€‹</a></h3><p>This registration procedure outlined above works reasonably well for simple cases. In complex cases, in particular if you have large
shape variations, you may find it difficult to find a suitable regularization weight. When you choose the regularization weight
large, the procedure will result in a nice and smooth mesh, but fails to closely fit the surface. If you choose it small, it may
result in folds and bad correspondences. In such cases it has proven extremely useful to simply iterate the registration procedure,
with decreasing regularization weights. In the following we illustrate this procedure. We start by defining a case class, which
collects all relevant parameters:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">case class RegistrationParameters(regularizationWeight: Double, numberOfIterations: Int, numberOfSampledPoints: Int)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We put all the registration code into a function, which takes (among others) the registration parameters as an argument.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">def doRegistration(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lowRankGP: LowRankGaussianProcess[_3D, EuclideanVector[_3D]],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    referenceMesh: TriangleMesh[_3D],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetmesh: TriangleMesh[_3D],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    registrationParameters: RegistrationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initialCoefficients: DenseVector[Double]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ): DenseVector[Double] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val fixedImage = referenceMesh.operations.toDistanceImage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val movingImage = targetMesh.operations.toDistanceImage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val sampler = FixedPointsUniformMeshSampler3D(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      referenceMesh,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      registrationParameters.numberOfSampledPoints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val metric = MeanSquaresMetric(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      fixedImage,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      movingImage,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      transformationSpace,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      sampler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val optimizer = LBFGSOptimizer(registrationParameters.numberOfIterations)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val regularizer = L2Regularizer(transformationSpace)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val registration = Registration(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      metric,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      regularizer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      registrationParameters.regularizationWeight,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      optimizer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val registrationIterator = registration.iterator(initialCoefficients)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val visualizingRegistrationIterator = for ((it, itnum) &lt;- registrationIterator.zipWithIndex) yield {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      println(s&quot;object value in iteration $itnum is ${it.value}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val registrationResult = visualizingRegistrationIterator.toSeq.last</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    registrationResult.parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, we define the parameters and run the registration. Note that for large regularization weights, we sample fewer points on the surface to save some computation time.
This is justified as, a strongly regularized model will not be able to adapt to fine details and hence it is not necessary to have a very accurate sampling of the surface.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val registrationParameters = Seq(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RegistrationParameters(regularizationWeight = 1e-1, numberOfIterations = 20, numberOfSampledPoints = 1000),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RegistrationParameters(regularizationWeight = 1e-2, numberOfIterations = 30, numberOfSampledPoints = 1000),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RegistrationParameters(regularizationWeight = 1e-4, numberOfIterations = 40, numberOfSampledPoints = 2000),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RegistrationParameters(regularizationWeight = 1e-6, numberOfIterations = 50, numberOfSampledPoints = 4000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val finalCoefficients = registrationParameters.foldLeft(initialCoefficients)((modelCoefficients, regParameters) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    doRegistration(lowRankGP, referenceMesh, targetMesh, regParameters, modelCoefficients)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>From this point we use the procedure described above to work with the registration result.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial12.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/Tutorials/tutorial11"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Model fitting with Iterative Closest Points</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/Tutorials/tutorial13"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Active Shape Model Fitting</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#loading-and-visualizing-a-mesh" class="table-of-contents__link toc-highlight">Loading and visualizing a mesh</a></li><li><a href="#building-a-gaussian-process-shape-model" class="table-of-contents__link toc-highlight">Building a Gaussian process shape model</a></li><li><a href="#registration" class="table-of-contents__link toc-highlight">Registration</a><ul><li><a href="#working-with-the-registration-result" class="table-of-contents__link toc-highlight">Working with the registration result</a></li><li><a href="#improving-registrations-for-more-complex-shapes" class="table-of-contents__link toc-highlight">Improving registrations for more complex shapes.</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitter-Chat<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.eba254cd.js"></script>
<script src="/assets/js/main.1558c061.js"></script>
</body>
</html>