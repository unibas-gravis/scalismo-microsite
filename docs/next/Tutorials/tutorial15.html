<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Scalismo RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Scalismo Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Model fitting using MCMC - Fitting a shape model | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/next/Tutorials/tutorial15"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Model fitting using MCMC - Fitting a shape model | Scalismo"><meta data-react-helmet="true" name="description" content="In this tutorial we show how the MCMC framework, which was introduced in the previous"><meta data-react-helmet="true" property="og:description" content="In this tutorial we show how the MCMC framework, which was introduced in the previous"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/next/Tutorials/tutorial15"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial15" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/next/Tutorials/tutorial15" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4461d896.css">
<link rel="preload" href="/assets/js/runtime~main.ef39b87c.js" as="script">
<link rel="preload" href="/assets/js/main.49e0137e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Scalismo</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/next">Next</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/next/Tutorials/tutorial15">Next</a></li><li><a class="dropdown__link" href="/docs/Tutorials/tutorial15">0.90</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/Setup/ide">Setup</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/next/Tutorials/tutorial01">Tutorials</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial01">Hello Scalismo!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial02">Rigid Alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial03">From meshes to deformation fields</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial04">Gaussian processes and Point Distribution Models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial05">Gaussian processes, sampling and marginalization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial06">Building a shape model from data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial07">Shape modelling with Gaussian processes and kernels</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial08">Posterior shape models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial09">Shape completion using GP regression</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/Tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/next/Tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/next/scalismo-ui-introduction">Others</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->Scalismo<!-- --> <b>Next</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/Tutorials/tutorial15">latest version</a></b> (<!-- -->0.90<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->Next</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Model fitting using MCMC - Fitting a shape model</h1></header><p>In this tutorial we show how the MCMC framework, which was introduced in the previous
tutorial, can be used for shape model fitting.</p><p>We will illustrate it by computing a posterior of a shape model,
given a set of corresponding landmark pairs. This is the same setup that we have
discussed in the tutorial about Gaussian process regression. The difference is,
that here we will also allow for rotation and translation of the model. In this setting,
it is not possible anymore to compute the posterior analytically. Rather, our only hope are approximation methods, such as
using Markov-chain monte carlo methods.</p><p>In this tutorial we show not only a working example, but also how to make it
computationally efficient. Making the individual parts as efficient as possible is
important in sampling approaches, as we need to produce many samples to get accurate
estimates.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="related-resources">Related resources<a class="hash-link" href="#related-resources" title="Direct link to heading">​</a></h5><p>Week 3 of our <a href="https://shapemodelling.cs.unibas.ch/probabilistic-fitting-course/" target="_blank" rel="noopener noreferrer">online course</a> on shape model fitting may provide some helpful context for this tutorial.</p><p>To run the code from this tutorial, download the following Scala file:</p><ul><li><a target="_blank" href="/assets/files/Tutorial15-411bc16a5fef38889856d572e02b2e39.scala">Tutorial15.scala</a></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="preparation">Preparation<a class="hash-link" href="#preparation" title="Direct link to heading">​</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and
initializing the system.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.io.StatisticalModelIO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.io.LandmarkIO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.ui.api.ScalismoUI</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.geometry._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.PointId</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.interpolation.TriangleMeshInterpolator3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.UnstructuredPointsDomain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.interpolation.NearestNeighborInterpolator3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.UnstructuredPointsDomain1D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common.UnstructuredPointsDomain3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.statisticalmodel.PointDistributionModel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.statisticalmodel.MultivariateNormalDistribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.mesh.TriangleMesh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.transformations._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling.proposals._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling.parameters._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling.evaluators._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling.loggers.MHSampleLogger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.sampling.algorithms.MetropolisHastings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.DenseVector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.DenseMatrix</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">implicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">implicit val randBasisBreeze : breeze.stats.distributions.RandBasis = rng.breezeRandBasis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scalismo.initialize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val ui = ScalismoUI()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="loading-and-visualizing-the-data">Loading and visualizing the data<a class="hash-link" href="#loading-and-visualizing-the-data" title="Direct link to heading">​</a></h3><p>In a first step, we load and visualize all the data that we need.
First, we load the statistical model:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val model = StatisticalModelIO.readStatisticalTriangleMeshModel3D(new java.io.File(&quot;datasets/bfm.h5&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val modelGroup = ui.createGroup(&quot;model&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val modelView = ui.show(modelGroup, model, &quot;model&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">modelView.referenceView.opacity = 0.5</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In this example, we will fit the model such that a set of model landmarks, coincide
with a set of landmark points defined on a target face. We load and visualize the corresponding landmark data:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val modelLms = LandmarkIO.readLandmarksJson[_3D](new java.io.File(&quot;datasets/modelLM_mcmc.json&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val modelLmViews = ui.show(modelGroup, modelLms, &quot;modelLandmarks&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">modelLmViews.foreach(lmView =&gt; lmView.color = java.awt.Color.BLUE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetGroup = ui.createGroup(&quot;target&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetLms = LandmarkIO.readLandmarksJson3D(new java.io.File(&quot;datasets/targetLM_mcmc.json&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetLmViews = ui.show(targetGroup, targetLms, &quot;targetLandmarks&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">modelLmViews.foreach(lmView =&gt; lmView.color = java.awt.Color.RED)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The modelPoints (which are actually points on the reference mesh defining the model) and the
target points are assumed to be in correspondence. To highlight this, we zip them together,
such that the corresponding points are stored as a tuple. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val modelPoints = modelLms.map(l =&gt; l.point)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val targetPoints = targetLms.map(l =&gt; l.point)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val correspondences = modelPoints.zip(targetPoints)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In any shape modelling application, it is important to correctly set up the center of rotation.
Usually we take this to be the center of mass of the model mean. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">def computeCenterOfMass(mesh: TriangleMesh[_3D]): Point[_3D] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val normFactor = 1.0 / mesh.pointSet.numberOfPoints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mesh.pointSet.points.foldLeft(Point(0, 0, 0))((sum, point) =&gt; sum + point.toVector * normFactor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val rotationCenter = computeCenterOfMass(model.mean)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-parameter-class">The parameter class<a class="hash-link" href="#the-parameter-class" title="Direct link to heading">​</a></h3><p>In this example, we want to model the posterior <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mclose">)</span></span></span></span></span>, where
the parameters <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta =( t, r, \alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mclose">)</span></span></span></span></span> consist of the translation parameters
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=(t_x, t_y, t_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>, the rotation parameters <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>ψ</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = (\phi, \psi, \omega)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ψ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ω</span><span class="mclose">)</span></span></span></span></span>,
represented as Euler angles as well a shape model coefficients <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>α</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha = (\alpha_1, \ldots, \alpha_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.
As this combination of parameters is very common in shape modelling, Scalismo already provides
a corresponding parameter class, called <code>PoseAndShapeParameters</code>.
We need, however, to define any additional parameters that we want to model by ourselves. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">case class Parameters(poseAndShapeParameters : PoseAndShapeParameters, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      noiseStddev : Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The class <code>PoseAndShapeParameters</code> class is defined as part of Scalismo. In this tutorial,
we add an other parameter, namely the <code>noiseStddev</code>, which regulates the noise that we expect
on the observations. To be able to derive proposals for such a user defined parameter class, we
need to provide conversion methods that tell scalismo how to convert the parameters to and from
a tuple. We will also add a convenience method to extract the pose transformation from the
parameters. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">object Parameters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    implicit object parameterConversion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        extends ParameterConversion[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          Tuple2[PoseAndShapeParameters, Double],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          Parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      def from(p: Parameters): Tuple2[PoseAndShapeParameters, Double] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (p.poseAndShapeParameters, p.noiseStddev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      def to(t: Tuple2[PoseAndShapeParameters, Double]): Parameters =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Parameters(t._1, t._2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def poseTransformationForParameters(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        translationParameters: TranslationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationParameters: RotationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        centerOfRotation: Point[_3D]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ): TranslationAfterRotation[_3D] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      TranslationAfterRotation3D(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Translation3D(translationParameters.translationVector),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Rotation3D(rotationParameters.angles, centerOfRotation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="evaluators-modelling-the-target-density">Evaluators: Modelling the target density<a class="hash-link" href="#evaluators-modelling-the-target-density" title="Direct link to heading">​</a></h3><p>As in the previous tutorial, we represent the unnormalized posterior distribution
as the product of prior and likelihood:
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo><mo>∝</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D) \propto p(\theta) p(D | \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mclose">)</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mclose">)</span></span></span></span></span>,
where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span></span> denotes the data (i.e. the corresponding landmark points) and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span></span>
are our parameters.</p><p>As a prior over the shape parameters is given by the shape model. For the
translation and rotation, we assume a zero-mean normal distribution. As the standard deviation
characterizing the noise needs to be positive, we use a lognormal distribution.:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  case class PriorEvaluator(model: PointDistributionModel[_3D, TriangleMesh])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      extends MHDistributionEvaluator[Parameters] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val translationPrior = breeze.stats.distributions.Gaussian(0.0, 5.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val rotationPrior = breeze.stats.distributions.Gaussian(0, 0.1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val noisePrior = breeze.stats.distributions.LogNormal(0, 0.25)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override def logValue(sample: MHSample[Parameters]): Double = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val poseAndShapeParameters = sample.parameters.poseAndShapeParameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val translationParameters = poseAndShapeParameters.translationParameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val rotationParameters = poseAndShapeParameters.rotationParameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      model.gp.logpdf(poseAndShapeParameters.shapeParameters.coefficients) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        translationPrior.logPdf(translationParameters.translationVector.x) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        translationPrior.logPdf(translationParameters.translationVector.y) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        translationPrior.logPdf(translationParameters.translationVector.z) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationPrior.logPdf(rotationParameters.angles._1) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationPrior.logPdf(rotationParameters.angles._2) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationPrior.logPdf(rotationParameters.angles._3) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        noisePrior.logPdf(sample.parameters.noiseStddev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To compute the likelihood <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(D | \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mclose">)</span></span></span></span></span> we need to determine where
the landmark points on the model are mapped under the transformation
given by the parameters <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span></span>. The distance between these mapped
model points and the target points determine the likelihood.
As we only need to map the landmark points, it is computationally more
efficient to restrict the model to these points first, and then only
to deform these points rather than all the points of the model. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case class CorrespondenceEvaluator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      model: PointDistributionModel[_3D, TriangleMesh],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      rotationCenter: Point[_3D],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      correspondences: Seq[(Point[_3D], Point[_3D])]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ) extends MHDistributionEvaluator[Parameters] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // we extract the points and build a model from only the points</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val (refPoints, targetPoints) = correspondences.unzip</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val newDomain = UnstructuredPointsDomain3D(refPoints.toIndexedSeq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val modelOnLandmarkPoints = model.newReference(newDomain, NearestNeighborInterpolator3D())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override def logValue(sample: MHSample[Parameters]): Double = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val poseTransformation = Parameters.poseTransformationForParameters(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sample.parameters.poseAndShapeParameters.translationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sample.parameters.poseAndShapeParameters.rotationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationCenter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val modelCoefficients = sample.parameters.poseAndShapeParameters.shapeParameters.coefficients</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val currentModelInstance =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modelOnLandmarkPoints.instance(modelCoefficients).transform(poseTransformation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val lmUncertainty = MultivariateNormalDistribution(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DenseVector.zeros[Double](3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DenseMatrix.eye[Double](3) * sample.parameters.noiseStddev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val likelihoods = for ((pointOnInstance, targetPoint) &lt;- currentModelInstance.pointSet.points.zip(targetPoints)) yield {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val observedDeformation = targetPoint - pointOnInstance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lmUncertainty.logpdf(observedDeformation.toBreezeVector)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val loglikelihood = likelihoods.sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      loglikelihood</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-posterior-evaluator">The posterior evaluator<a class="hash-link" href="#the-posterior-evaluator" title="Direct link to heading">​</a></h4><p>Given these evaluators, we can now build the computationally efficient version of
our target density <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\theta | D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mclose">)</span></span></span></span></span></p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val likelihoodEvaluator = CorrespondenceEvaluator(model, rotationCenter, correspondences)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val priorEvaluator = PriorEvaluator(model).cached</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val posteriorEvaluator = ProductEvaluator(priorEvaluator, likelihoodEvaluator)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-proposal-generator">The proposal generator<a class="hash-link" href="#the-proposal-generator" title="Direct link to heading">​</a></h3><p>As in the previous tutorials, we will use simple random walk proposals.
We will define separate proposals for shape, translation and rotation.
On one hand, this lets us set the step length (i.e. stddev of the distribution from which we
sample the next step) individually for each group, and thus to incorporate our knowledge
that changes in rotation will be much smaller than the shape changes. On the other hand,
splitting the parameter updates in blocks will increase our chance for the random updates
to be accepted. The reason for this is that when many parameters are updated at one,
chances are high that some of the proposed changes make the new state more unlikely,
and hence increase the chance of the new state being rejected.</p><p>We start by defining the basic pose proposals</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val rotationProposal = MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(0.01, &quot;rx&quot;).forType[Double],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(0.01, &quot;ry&quot;).forType[Double],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(0.01, &quot;rz&quot;).forType[Double]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ).forType[RotationParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val translationProposal = MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(1.0, &quot;tx&quot;).forType[Double],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(1.0, &quot;ty&quot;).forType[Double],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(1.0, &quot;tz&quot;).forType[Double]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ).forType[TranslationParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The next proposal is for updating the shape parameters. We define two
shape proposals, one for the leading parameters, which adjusts the overall
shape, and one for the remaining parameters. We can achieve this using
the <code>.partial</code> method of the <code>GaussianRandomWalkProposal</code>, which will only
update the components in a given range.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val shapeProposalLeading =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(0.01, &quot;shape-0-5&quot;).partial(0 until 5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[ShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val shapeProposalRemaining =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GaussianRandomWalkProposal(0.01, &quot;shape-6-&quot;).partial(6 until model.rank)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[ShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>From these building blocks, we can define different proposal for shape and pose, which always
only update a part of the parameters. For better readability, we also give them simpler name, under
which they later appear in the logs. </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val identTranslationProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHIdentityProposal.forType[TranslationParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val identRotationProposal = MHIdentityProposal.forType[RotationParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val identShapeProposal = MHIdentityProposal.forType[ShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val poseAndShapeTranslationOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      translationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identRotationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identShapeProposal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[PoseAndShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .relabel(&quot;translation-only&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val poseAndShapeRotationOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identTranslationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      rotationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identShapeProposal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[PoseAndShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .relabel(&quot;rotation-only&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val poseAndShapeLeadingShapeOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identTranslationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identRotationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      shapeProposalLeading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[PoseAndShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .relabel(&quot;shape-leading-only&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val poseAndShapeRemainingShapeOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identTranslationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      identRotationProposal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      shapeProposalRemaining</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[PoseAndShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .relabel(&quot;shape-trailing-only&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Using a mixture proposal, we can combine them to one proposal for pose and shape</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val mixturePoseAndShapeProposal = MHMixtureProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.2, poseAndShapeTranslationOnlyProposal),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.2, poseAndShapeRotationOnlyProposal),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.3, poseAndShapeLeadingShapeOnlyProposal),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.3, poseAndShapeRemainingShapeOnlyProposal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, we do the same for the noise proposal to obtain a proposal
that updates the full parameter vector</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val noiseProposal = GaussianRandomWalkProposal(0.1, &quot;noise&quot;).forType[Double]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val identNoiseProposal = MHIdentityProposal.forType[Double]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val identPoseAndShapeProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHIdentityProposal.forType[PoseAndShapeParameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val noiseOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(identPoseAndShapeProposal, noiseProposal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[Parameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val poseAndShapeOnlyProposal =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MHProductProposal(mixturePoseAndShapeProposal, identNoiseProposal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .forType[Parameters]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val fullproposal = MHMixtureProposal(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.9, poseAndShapeOnlyProposal),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0.1, noiseOnlyProposal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="building-the-markov-chain">Building the Markov Chain<a class="hash-link" href="#building-the-markov-chain" title="Direct link to heading">​</a></h4><p>For running the Markov Chain, we proceed exactly as in the previous tutorial.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val logger = MHSampleLogger[Parameters]()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val chain = MetropolisHastings(fullproposal, posteriorEvaluator)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val initialParameters = Parameters(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PoseAndShapeParameters(TranslationParameters(EuclideanVector3D(0, 0, 0)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            RotationParameters((0.0, 0.0, 0.0)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ShapeParameters(DenseVector.zeros[Double](model.rank))),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    noiseStddev = 1.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val mhIterator = chain.iterator(MHSample(initialParameters, &quot;inital&quot;), logger)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In this example we are interested to visualize some samples from the posterior as we run the chain. This can be done
by augmenting the iterator with visualization code:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val samplingIterator = for ((sample, iteration) &lt;- mhIterator.zipWithIndex) yield {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;iteration &quot; + iteration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (iteration % 500 == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val poseAndShapeParameters = sample.parameters.poseAndShapeParameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val poseTransformation = Parameters.poseTransformationForParameters(poseAndShapeParameters.translationParameters, poseAndShapeParameters.rotationParameters, rotationCenter)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      modelView.shapeModelTransformationView.shapeTransformationView.coefficients =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poseAndShapeParameters.shapeParameters.coefficients</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      modelView.shapeModelTransformationView.poseTransformationView.transformation = poseTransformation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sample</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, we draw the samples using the chain by consuming the iterator. We drop the first 1000 iterations, as the
chain needs some burn-in time to converge to a equilibrium solution:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val samples = samplingIterator.drop(1000).take(10000).toIndexedSeq</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Before working with the results, we check the acceptance ratios to verify that all the proposals work as expected:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  println(logger.samples.acceptanceRatios)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="analyzing-the-results">Analyzing the results<a class="hash-link" href="#analyzing-the-results" title="Direct link to heading">​</a></h3><p>Once we have the samples, we can now use them to analyze our fit.
For example, we can select the best fit from these samples and visualize it</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val bestSample = samples.maxBy(posteriorEvaluator.logValue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val bestPoseAndShapeParameters = bestSample.parameters.poseAndShapeParameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val bestPoseTransformation = Parameters.poseTransformationForParameters(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bestPoseAndShapeParameters.translationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bestPoseAndShapeParameters.rotationParameters,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rotationCenter)    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val bestFit = model.instance(bestPoseAndShapeParameters.shapeParameters.coefficients).transform(bestPoseTransformation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val resultGroup = ui.createGroup(&quot;result&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ui.show(resultGroup, bestFit, &quot;best fit&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The samples allow us to infer much more about the distribution. For example, we could use them to estimate the distribution
of the length of the femur or any other measuremnt of the shape that we are interested. </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="beyond-landmark-fitting">Beyond landmark fitting<a class="hash-link" href="#beyond-landmark-fitting" title="Direct link to heading">​</a></h3><p>We have shown above how Scalismo can be used to perform Bayesian model fitting on the example of fitting 3D landmarks. This example
can easily be extended to other fitting tasks, such as fitting the model to points with unkown correspondences, fitting shapes in surfaces
of fitting a model to an image using an Active Shape Model as a likelihood function. In principle, all that is required is to
change the likelihood function and rerun the fit.
In practice, however, as a change in the likelihood function can dramatically change the posterior density, it is often required
to tune the proposals, such that good convergence can be achieved. Indeed, finding good proposal distributions is the key to
applying this method successfully. The more prior knowledge about the target distribution we can incorporate into the proposals,
the faster will the chain converge to the equilibrium distribution.</p><p>For more complicated use-cases of this method in image analysis, the interested reader is referred to the paper by S. Schönborn et al.
and references therein:</p><ul><li>Schönborn, Sandro, et al. &quot;Markov chain monte carlo for automated face image analysis.&quot; International Journal of Computer Vision 123.2 (2017): 160-183.</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/tutorial15.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/Tutorials/tutorial14"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Model fitting using MCMC - The basic framework</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/scalismo-ui-introduction"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Introduction to Scalismo-ui</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#loading-and-visualizing-the-data" class="table-of-contents__link toc-highlight">Loading and visualizing the data</a></li><li><a href="#the-parameter-class" class="table-of-contents__link toc-highlight">The parameter class</a></li><li><a href="#evaluators-modelling-the-target-density" class="table-of-contents__link toc-highlight">Evaluators: Modelling the target density</a></li><li><a href="#the-proposal-generator" class="table-of-contents__link toc-highlight">The proposal generator</a></li><li><a href="#analyzing-the-results" class="table-of-contents__link toc-highlight">Analyzing the results</a></li><li><a href="#beyond-landmark-fitting" class="table-of-contents__link toc-highlight">Beyond landmark fitting</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitter-Chat<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ef39b87c.js"></script>
<script src="/assets/js/main.49e0137e.js"></script>
</body>
</html>