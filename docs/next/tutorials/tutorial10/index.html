<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.68">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Iterative Closest Points for rigid alignment | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Iterative Closest Points for rigid alignment | Scalismo"><meta data-react-helmet="true" name="description" content="The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm"><meta data-react-helmet="true" property="og:description" content="The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/next/tutorials/tutorial10"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/next/tutorials/tutorial10"><link rel="stylesheet" href="/styles.ecbe9e9d.css">
<link rel="preload" href="/styles.4711b045.js" as="script">
<link rel="preload" href="/runtime~main.6e04eccd.js" as="script">
<link rel="preload" href="/main.a12142ef.js" as="script">
<link rel="preload" href="/1.ae4a5136.js" as="script">
<link rel="preload" href="/94.c6277ced.js" as="script">
<link rel="preload" href="/96.de6c3c3e.js" as="script">
<link rel="preload" href="/935f2afb.5fdf1150.js" as="script">
<link rel="preload" href="/93.9a579cf0.js" as="script">
<link rel="preload" href="/8e00ff3f.ed3c970f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_2AhQ">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/docs/next/">Next</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/next/tutorials/tutorial10">Next</a></li><li><a class="dropdown__link" href="/docs/tutorials/tutorial10">0.90</a></li><li><a class="dropdown__link" href="/docs/0.18/tutorials/tutorial10">0.18</a></li></ul></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Scalismo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Scalismo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Scalismo</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/onlinecourse">Online courses</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a class="menu__link" href="/support">Support</a></li><li class="menu__list-item"><a class="menu__link" href="/about">About</a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/next/tutorials/tutorial10">Next</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/tutorials/tutorial10">0.90</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.18/tutorials/tutorial10">0.18</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive thin-scrollbar menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial1">Hello Scalismo!</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial2">Rigid Alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial3">From meshes to deformation fields</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial4">Gaussian processes and Point Distribution Models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial5">Gaussian processes, sampling and marginalization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial6">Building a shape model from data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial7">Shape modelling with Gaussian processes and kernels</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial8">Posterior shape models</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial9">Shape completion using GP regression</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/next/tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/tutorials/scalismo-ui-introduction">Introduction to Scalismo-ui</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_39qw"><div class="row"><div class="col docItemCol_2ASc"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for Scalismo <strong>Next</strong> version.</div><div class="margin-top--md">For up-to-date documentation, see the <strong><a href="/docs/tutorials/tutorial10">latest version</a></strong> (0.90).</div></div><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: Next</span></div><header><h1 class="docTitle_1Lrw">Iterative Closest Points for rigid alignment</h1></header><div class="markdown"><p>The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm
in the context of rigid alignment of shapes.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="related-resources"></a>Related resources<a aria-hidden="true" class="hash-link" href="#related-resources" title="Direct link to heading">#</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Superimposing shapes <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250330" target="_blank" rel="noopener noreferrer">(Article)</a></li><li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371" target="_blank" rel="noopener noreferrer">(Video)</a></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="preparation"></a>Preparation<a aria-hidden="true" class="hash-link" href="#preparation" title="Direct link to heading">#</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.ui.api._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.geometry._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.common._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.mesh._</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.registration.LandmarkRegistration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.io.{MeshIO}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import scalismo.numerics.UniformMeshSampler3D</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import breeze.linalg.{DenseMatrix, DenseVector}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">scalismo.initialize()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">implicit val rng = scalismo.utils.Random(42)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val ui = ScalismoUI()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="automatic-rigid-alignment"></a>Automatic rigid alignment<a aria-hidden="true" class="hash-link" href="#automatic-rigid-alignment" title="Direct link to heading">#</a></h2><p>We start by loading and visualizing two meshes</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mesh1 = MeshIO.readMesh(new java.io.File(&quot;datasets/Paola.ply&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val group1 = ui.createGroup(&quot;Dataset 1&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mesh1View = ui.show(group1, mesh1, &quot;mesh1&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mesh2 = MeshIO.readMesh(new java.io.File(&quot;datasets/323.ply&quot;)).get</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val group2 = ui.createGroup(&quot;Dataset 2&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val mesh2View = ui.show(group2, mesh2, &quot;mesh2&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mesh2View.color = java.awt.Color.RED</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As you can see here, the meshes are not aligned. As in previous tutorials, we could identify corresponding points
to align the meshes. The downside is, that this requires some manual intervention.
In this tutorial we will instead use the Iterative Closest Point (ICP) method to perform this rigid alignment step <strong>automatically</strong>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="candidate-correspondences"></a>Candidate correspondences<a aria-hidden="true" class="hash-link" href="#candidate-correspondences" title="Direct link to heading">#</a></h3><p>We have seen before that finding the best rigid transformation when given correct correspondences has a closed-form
solution. The problem we are facing here is that we do not have these correspondences. The idea of the ICP algorithm is,
that we can approximate the correspondences, by simply assuming that the corresponding point is always the closest point on
the mesh.</p><p>Let&#x27;s select a few points from the mesh.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val ptIds = (0 until mesh1.pointSet.numberOfPoints by 50).map(i =&gt; PointId(i))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(group1, ptIds.map(id =&gt; mesh1.pointSet.point(id)), &quot;selected&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>The exact number of points is not important. It is only important that we select points, which are approximately
uniformly distributed over the surface.</p><p>In the next step, we find the corresponding points in the other mesh:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def attributeCorrespondences(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId]) : Seq[(Point[_3D], Point[_3D])] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ptIds.map{ id : PointId =&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val pt = movingMesh.pointSet.point(id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val closestPointOnMesh2 = mesh2.pointSet.findClosestPoint(pt).point</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (pt, closestPointOnMesh2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Note that we used here not <code>mesh1</code> directly, but passed the mesh from which we find the closest points as an argument,
which we called the <code>MovingMesh</code>. The reason is, that this will later be iteratively transformed to come closer to our target mesh <code>mesh2</code>.</p><p>Let us now visualize the the chosen correspondences:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val correspondences = attributeCorrespondences(mesh1, ptIds)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val targetPoints = correspondences.map(pointPair =&gt; pointPair._2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(group2, targetPoints.toIndexedSeq, &quot;correspondences&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As expected, the obtained correspondences are clearly not good, as they tend to focus on only one side of the target face.
Nevertheless, we can apply Procrustes analysis based on these correspondences and
retrieve a rigid transformation, which brings us closer to the target.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val rigidTrans =  LandmarkRegistration.rigid3DLandmarkRegistration(correspondences, center = Point3D(0, 0, 0))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val transformed = mesh1.transform(rigidTrans)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val alignedMeshView = ui.show(group1, transformed, &quot;aligned?&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">alignedMeshView.color = java.awt.Color.GREEN</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p><strong>Well, no surprise here.</strong> Given the poor quality of the candidate correspondences, we obtained a poor rigid alignment.
This said, when considering where we started from, that is the original position, we did get closer to the target.</p><p>The second important idea of the ICP algorithm comes is now to <strong>iterate</strong> this steps in the hope that it will converge.
Let&#x27;s try it out:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val newCorrespondences = attributeCorrespondences(transformed, ptIds)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val newClosestPoints = newCorrespondences.map(pointPair =&gt; pointPair._2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ui.show(group2, newClosestPoints.toIndexedSeq, &quot;newCandidateCorr&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val newRigidTransformation =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  LandmarkRegistration.rigid3DLandmarkRegistration(newCorrespondences, center = Point3D(0, 0, 0))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val newTransformed = transformed.transform(newRigidTransformation)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val alignedMeshView2 =  ui.show(group2, newTransformed, &quot;aligned??&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">alignedMeshView2.color = java.awt.Color.BLUE</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As you can see, the candidate correspondences are still clearly wrong,
but start to be more spread around the target face.
Also the resulting rigid transformation seems to bring our mesh a bit closer to the target.</p><p>Finally, we change our implementation such that we can perform an arbitrary number of iterations:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def ICPRigidAlign(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId], numberOfIterations : Int) : TriangleMesh[_3D] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (numberOfIterations == 0) movingMesh</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val correspondences = attributeCorrespondences(movingMesh, ptIds)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val transform = LandmarkRegistration.rigid3DLandmarkRegistration(correspondences, center = Point(0, 0, 0))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val transformed = movingMesh.transform(transform)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ICPRigidAlign(transformed, ptIds, numberOfIterations - 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>Let&#x27;s now run it with 150 iterations:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><div tabindex="0" class="prism-code language-scala codeBlock_3iAC thin-scrollbar"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val rigidfit = ICPRigidAlign(mesh1, ptIds, 150)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val rigidFitView = ui.show(group1, rigidfit, &quot;ICP_rigid_fit&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">rigidFitView.color = java.awt.Color.YELLOW</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button></div></div><p>As you can see here, the quality of the candidate correspondences did indeed result in a proper
<strong>automatic</strong> rigid alignment of Paola to the target. One should not forget, however, that the ICP method is
very sensitive to the initial position, and might easily get stuck in a local minimum.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/docs/tutorials/tutorial10.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/tutorials/tutorial9"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Shape completion using GP regression</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/tutorials/tutorial11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Model fitting with Iterative Closest Points »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#automatic-rigid-alignment" class="table-of-contents__link">Automatic rigid alignment</a><ul><li><a href="#candidate-correspondences" class="table-of-contents__link">Candidate correspondences</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Forum</a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitter-Chat</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2021 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4711b045.js"></script>
<script src="/runtime~main.6e04eccd.js"></script>
<script src="/main.a12142ef.js"></script>
<script src="/1.ae4a5136.js"></script>
<script src="/94.c6277ced.js"></script>
<script src="/96.de6c3c3e.js"></script>
<script src="/935f2afb.5fdf1150.js"></script>
<script src="/93.9a579cf0.js"></script>
<script src="/8e00ff3f.ed3c970f.js"></script>
</body>
</html>