<!doctype html>
<html class="docs-version-0.91.0" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Scalismo RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Scalismo Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Iterative Closest Points for rigid alignment | Scalismo</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalismo.org/docs/0.91.0/Tutorials/tutorial10"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="0.91.0"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-0.91.0"><meta data-react-helmet="true" property="og:title" content="Iterative Closest Points for rigid alignment | Scalismo"><meta data-react-helmet="true" name="description" content="The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm"><meta data-react-helmet="true" property="og:description" content="The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://scalismo.org/docs/0.91.0/Tutorials/tutorial10"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/0.91.0/Tutorials/tutorial10" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalismo.org/docs/0.91.0/Tutorials/tutorial10" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4461d896.css">
<link rel="preload" href="/assets/js/runtime~main.4d3c2240.js" as="script">
<link rel="preload" href="/assets/js/main.b63e4727.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="Scalismo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Scalismo</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Docs</a><a class="navbar__item navbar__link" href="/onlinecourse">Online courses</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/support">Support</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/0.91.0">0.91.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/Tutorials/tutorial10">Next</a></li><li><a class="dropdown__link" href="/docs/Tutorials/tutorial10">0.92</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/0.91.0/Tutorials/tutorial10">0.91.0</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/0.91.0/Setup/ide">Setup</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/0.91.0/Tutorials/tutorial01">Tutorials</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial01">Hello Scalismo!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial02">Rigid Alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial03">From meshes to deformation fields</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial04">Gaussian processes and Point Distribution Models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial05">Gaussian processes, sampling and marginalization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial06">Building a shape model from data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial07">Shape modelling with Gaussian processes and kernels</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial08">Posterior shape models</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial09">Shape completion using GP regression</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial10">Iterative Closest Points for rigid alignment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial11">Model fitting with Iterative Closest Points</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial12">Parametric, non-rigid registration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial13">Active Shape Model Fitting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial14">Model fitting using MCMC - The basic framework</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/0.91.0/Tutorials/tutorial15">Model fitting using MCMC - Fitting a shape model</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/0.91.0/scalismo-ui-introduction">Others</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for <!-- -->Scalismo<!-- --> <b>0.91.0</b>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/Tutorials/tutorial10">latest version</a></b> (<!-- -->0.92<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->0.91.0</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Iterative Closest Points for rigid alignment</h1></header><p>The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm
in the context of rigid alignment of shapes.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="related-resources">Related resources<a class="hash-link" href="#related-resources" title="Direct link to heading">â€‹</a></h5><p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling" target="_blank" rel="noopener noreferrer">online course</a> may provide
some helpful context for this tutorial:</p><ul><li>Superimposing shapes <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250330" target="_blank" rel="noopener noreferrer">(Article)</a></li><li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371" target="_blank" rel="noopener noreferrer">(Video)</a></li></ul><p>To run the code from this tutorial, download the following Scala file:</p><ul><li><a target="_blank" href="/assets/files/Tutorial10-0b648c3e636d0e460c2d0489c4abbb6e.scala">Tutorial10.scala</a></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="preparation">Preparation<a class="hash-link" href="#preparation" title="Direct link to heading">â€‹</a></h5><p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.ui.api._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.geometry._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.common._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.mesh._</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.registration.LandmarkRegistration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.io.{MeshIO}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scalismo.numerics.UniformMeshSampler3D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import breeze.linalg.{DenseMatrix, DenseVector}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">scalismo.initialize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">implicit val rng: scalismo.utils.Random = scalismo.utils.Random(42)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val ui = ScalismoUI()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="automatic-rigid-alignment">Automatic rigid alignment<a class="hash-link" href="#automatic-rigid-alignment" title="Direct link to heading">â€‹</a></h2><p>We start by loading and visualizing two meshes</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val mesh1 = MeshIO.readMesh(new java.io.File(&quot;datasets/Paola.ply&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val group1 = ui.createGroup(&quot;Dataset 1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val mesh1View = ui.show(group1, mesh1, &quot;mesh1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val mesh2 = MeshIO.readMesh(new java.io.File(&quot;datasets/323.ply&quot;)).get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val group2 = ui.createGroup(&quot;Dataset 2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val mesh2View = ui.show(group2, mesh2, &quot;mesh2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mesh2View.color = java.awt.Color.RED</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you can see here, the meshes are not aligned. As in previous tutorials, we could identify corresponding points
to align the meshes. The downside is, that this requires some manual intervention.
In this tutorial we will instead use the Iterative Closest Point (ICP) method to perform this rigid alignment step <strong>automatically</strong>.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="candidate-correspondences">Candidate correspondences<a class="hash-link" href="#candidate-correspondences" title="Direct link to heading">â€‹</a></h3><p>We have seen before that finding the best rigid transformation when given correct correspondences has a closed-form
solution. The problem we are facing here is that we do not have these correspondences. The idea of the ICP algorithm is,
that we can approximate the correspondences, by simply assuming that the corresponding point is always the closest point on
the mesh.</p><p>Let&#x27;s select a few points from the mesh.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val ptIds = (0 until mesh1.pointSet.numberOfPoints by 50).map(i =&gt; PointId(i))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(group1, ptIds.map(id =&gt; mesh1.pointSet.point(id)), &quot;selected&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The exact number of points is not important. It is only important that we select points, which are approximately
uniformly distributed over the surface.</p><p>In the next step, we find the corresponding points in the other mesh:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">def attributeCorrespondences(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId]) : Seq[(Point[_3D], Point[_3D])] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ptIds.map{ (id : PointId) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val pt = movingMesh.pointSet.point(id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val closestPointOnMesh2 = mesh2.pointSet.findClosestPoint(pt).point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (pt, closestPointOnMesh2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that we used here not <code>mesh1</code> directly, but passed the mesh from which we find the closest points as an argument,
which we called the <code>MovingMesh</code>. The reason is, that this will later be iteratively transformed to come closer to our target mesh <code>mesh2</code>.</p><p>Let us now visualize the the chosen correspondences:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val correspondences = attributeCorrespondences(mesh1, ptIds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val targetPoints = correspondences.map(pointPair =&gt; pointPair._2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(group2, targetPoints.toIndexedSeq, &quot;correspondences&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As expected, the obtained correspondences are clearly not good, as they tend to focus on only one side of the target face.
Nevertheless, we can apply Procrustes analysis based on these correspondences and
retrieve a rigid transformation, which brings us closer to the target.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val rigidTrans =  LandmarkRegistration.rigid3DLandmarkRegistration(correspondences, center = Point3D(0, 0, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val transformed = mesh1.transform(rigidTrans)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val alignedMeshView = ui.show(group1, transformed, &quot;aligned?&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">alignedMeshView.color = java.awt.Color.GREEN</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>Well, no surprise here.</strong> Given the poor quality of the candidate correspondences, we obtained a poor rigid alignment.
This said, when considering where we started from, that is the original position, we did get closer to the target.</p><p>The second important idea of the ICP algorithm comes is now to <strong>iterate</strong> this steps in the hope that it will converge.
Let&#x27;s try it out:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val newCorrespondences = attributeCorrespondences(transformed, ptIds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val newClosestPoints = newCorrespondences.map(pointPair =&gt; pointPair._2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ui.show(group2, newClosestPoints.toIndexedSeq, &quot;newCandidateCorr&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val newRigidTransformation =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LandmarkRegistration.rigid3DLandmarkRegistration(newCorrespondences, center = Point3D(0, 0, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val newTransformed = transformed.transform(newRigidTransformation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val alignedMeshView2 =  ui.show(group2, newTransformed, &quot;aligned??&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">alignedMeshView2.color = java.awt.Color.BLUE</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you can see, the candidate correspondences are still clearly wrong,
but start to be more spread around the target face.
Also the resulting rigid transformation seems to bring our mesh a bit closer to the target.</p><p>Finally, we change our implementation such that we can perform an arbitrary number of iterations:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">def ICPRigidAlign(movingMesh: TriangleMesh[_3D], ptIds : Seq[PointId], numberOfIterations : Int) : TriangleMesh[_3D] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (numberOfIterations == 0) movingMesh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val correspondences = attributeCorrespondences(movingMesh, ptIds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transform = LandmarkRegistration.rigid3DLandmarkRegistration(correspondences, center = Point(0, 0, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transformed = movingMesh.transform(transform)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ICPRigidAlign(transformed, ptIds, numberOfIterations - 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s now run it with 150 iterations:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val rigidfit = ICPRigidAlign(mesh1, ptIds, 150)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val rigidFitView = ui.show(group1, rigidfit, &quot;ICP_rigid_fit&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rigidFitView.color = java.awt.Color.YELLOW</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you can see here, the quality of the candidate correspondences did indeed result in a proper
<strong>automatic</strong> rigid alignment of Paola to the target. One should not forget, however, that the ICP method is
very sensitive to the initial position, and might easily get stuck in a local minimum.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-0.91.0/Tutorials/tutorial10.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/0.91.0/Tutorials/tutorial09"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Shape completion using GP regression</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/0.91.0/Tutorials/tutorial11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Model fitting with Iterative Closest Points</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#automatic-rigid-alignment" class="table-of-contents__link toc-highlight">Automatic rigid alignment</a><ul><li><a href="#candidate-correspondences" class="table-of-contents__link toc-highlight">Candidate correspondences</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs">Tutorial</a></li><li class="footer__item"><a href="http://unibas-gravis.github.io/scalismo/latest/api/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">API-Doc</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://groups.google.com/g/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitter.im/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitter-Chat<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/unibas-gravis/scalismo" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2023 University of Basel. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4d3c2240.js"></script>
<script src="/assets/js/main.b63e4727.js"></script>
</body>
</html>