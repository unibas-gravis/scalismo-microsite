<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Gravis Group, University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/img/poster.png" /><meta name="image" property="og:image" content="/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="unibas-gravis" data-github-repo="scalismo-microsite"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="hello-scalismo">Hello Scalismo!</h1>

<p>The goal in this tutorial is to present the most important data structures, as well as the visualization capabilities of Scalismo.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>What is Scalismo <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250314">(Video)</a></li>
</ul>

<h2 id="initializing-the-system">Initializing the system</h2>

<p>Before we start, we need to initialize Scalismo by calling:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>The call to <code class="highlighter-rouge">scalismo.initialize</code> loads all the dependencies to native C++ libraries (such as e.g. <a href="https://www.vtk.org">vtk</a> or <a href="https://www.hdf-group.org">hdf5</a>).
The second call tells scalismo, which source
of randomness to use and at the same time seeds the random number generator appropriately.</p>

<p>Later on we would like to visualize the objects we create. This is done using <a href="https://github.com/unibas-gravis/scalismo-ui">Scalismo-ui</a> - the visualization library accompanying scalismo.
We can load an instance of the GUI, which we name here simply <code class="highlighter-rouge">ui</code> as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.ui.api.ScalismoUI</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="meshes-surface-data">Meshes (surface data)</h2>

<p>The first fundamental data structure we discuss is the triangle mesh,
which is defined in the package <code class="highlighter-rouge">scalismo.mesh</code>.
In the following we will need access to the following object, which we
now import:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.mesh.TriangleMesh</span> <span class="c1">// the mesh class
</span><span class="k">import</span> <span class="nn">scalismo.io.MeshIO</span> <span class="c1">// to read meshes
</span><span class="k">import</span> <span class="nn">scalismo.common.PointId</span> <span class="c1">// to refer to points by id
</span><span class="k">import</span> <span class="nn">scalismo.mesh.TriangleId</span> <span class="c1">// to refer to triangles by id
</span><span class="k">import</span> <span class="nn">scalismo.geometry._3D</span> <span class="c1">// indicates that we work in 3D space
</span></code></pre></div></div>

<p>Meshes can be read from a file using the method <code class="highlighter-rouge">readMesh</code> from the <code class="highlighter-rouge">MeshIO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">mesh</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/Paola.stl"</span><span class="o">)).</span><span class="n">get</span>
</code></pre></div></div>

<p>To visualize any object in Scalismo, we can use the <code class="highlighter-rouge">show</code> method of the <code class="highlighter-rouge">ui</code> object.
We often want to organize different visualizations of an object in a group.
We start directly with this practice and
first create a new group, to which we then add the visualization of the mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">paolaGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"paola"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">meshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="n">mesh</span><span class="o">,</span> <span class="s">"Paola"</span><span class="o">)</span>
</code></pre></div></div>

<p>Now that the mesh is displayed in the “Scalismo Viewer’s 3D view”, you can interact with it as follows:</p>

<ul>
  <li>to rotate: maintain the left mouse button clicked and drag</li>
  <li>to shift/translate: maintain the middle mouse button clicked and drag</li>
  <li>to scale: maintain the right mouse button clicked and drag up or down</li>
</ul>

<p><em>Note: if you are a Mac user, please find out how to emulate these events using your mouse or trackpad</em>
<em>Note also that you can use the *RC</em>, <em>X</em>, <em>Y</em> and <em>Z</em> buttons in the 3D view to recenter the camera on the displayed object.*</p>

<h4 id="anatomy-of-a-triangle-mesh">Anatomy of a Triangle mesh</h4>

<p>A 3D triangle mesh in scalismo consists of a <code class="highlighter-rouge">pointSet</code>, which maintains a collection of 3D points and a
list of triangle cells. We can access individual points using their point id.
Here we show how we can access the first point in the mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">println</span><span class="o">(</span><span class="s">"first point "</span> <span class="o">+</span> <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
<span class="c1">// first point Point3D(162.2697296142578,-11.115056991577148,301.18719482421875)
</span></code></pre></div></div>

<p>Similarly, we can access the first triangles as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">println</span><span class="o">(</span><span class="s">"first cell "</span> <span class="o">+</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangulation</span><span class="o">.</span><span class="n">triangle</span><span class="o">(</span><span class="nc">TriangleId</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
<span class="c1">// first cell TriangleCell(PointId(0),PointId(1),PointId(2))
</span></code></pre></div></div>

<p>The first cell is a triangle between the first, second and third points of the mesh.
Notice here that the cell indicates the identifiers of the points (their index in the point sequence)
instead of the geometric position of the points.</p>

<p>Instead of visualizing the mesh, we can also display the points forming the mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">pointCloudView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span> <span class="s">"pointCloud"</span><span class="o">)</span>
</code></pre></div></div>

<p>This should add a new point cloud element to the scene with the name “pointCloud”.</p>

<p><em>Note: depending on your computer, visualizing the full point cloud may slow down the visualization performance.</em></p>

<p>Note that to clean up the 3D scene, you can delete the objects either from the user interface (by right-clicking on the object’s name), or programmatically by calling <code class="highlighter-rouge">remove</code> on the corresponding view object :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pointCloudView</span><span class="o">.</span><span class="n">remove</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="points-and-vectors">Points and Vectors</h2>

<p>We are very often interested in modelling transformations of point sets. Therefore we need to learn how to manipulate point positions.
The two fundamental classes in this context are <code class="highlighter-rouge">Point</code> and <code class="highlighter-rouge">EuclideanVector</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry.</span><span class="o">{</span><span class="nc">Point</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.geometry.</span><span class="o">{</span><span class="nc">EuclideanVector</span><span class="o">}</span>
</code></pre></div></div>

<p>We define points by specifying their coordinates:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">p1</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">4.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">p2</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</code></pre></div></div>

<p>The difference between two points is a <code class="highlighter-rouge">EuclideanVector</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">v1</span> <span class="k">:</span> <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">4.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">1.0</span> <span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span> 
</code></pre></div></div>

<p>The sum of a point with a vector yields a new point:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">p3</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">v1</span> 
</code></pre></div></div>

<p>Points can be converted to vectors:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">v2</span> <span class="k">:</span> <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">toVector</span>
</code></pre></div></div>

<p>and vice versa:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">v3</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">toPoint</span> 
</code></pre></div></div>

<p><em>Remark: Observe that the type of the expression is a parametric type <code class="highlighter-rouge">Point[_3D]</code>, where the type parameter <code class="highlighter-rouge">_3D</code> encodes the dimensionality. This pattern holds true for most types in Scalismo. It allows us to write generic code, which is independent of the dimensionality of the space.</em></p>

<p>We put these concepts in practice, and illustrate how we can compute the center of mass, given a sequence of points:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">pointList</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mf">4.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">14.0</span><span class="o">,</span> <span class="mf">15.0</span><span class="o">,</span> <span class="mf">16.0</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="mf">7.0</span><span class="o">,</span> <span class="mf">8.0</span><span class="o">,</span> <span class="mf">9.0</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span>
<span class="mf">10.0</span><span class="o">,</span> <span class="mf">11.0</span><span class="o">,</span> <span class="mf">12.0</span><span class="o">))</span>
</code></pre></div></div>

<p>In a first step, we treat all the points as displacement vectors (the displacement of the points from the origin)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">vectors</span> <span class="k">=</span> <span class="n">pointList</span><span class="o">.</span><span class="n">map</span><span class="o">{</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">toVector</span><span class="o">}</span>  <span class="c1">// use map to turn points into vectors
</span></code></pre></div></div>

<p>The average displacement can be easily computed by averaging all the vectors.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">vectorSum</span> <span class="k">=</span> <span class="n">vectors</span><span class="o">.</span><span class="n">reduce</span><span class="o">{</span> <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="o">}</span> <span class="c1">// sum up all vectors in the collection
</span><span class="k">val</span> <span class="n">centerV</span><span class="k">:</span> <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">vectorSum</span> <span class="o">*</span> <span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">pointList</span><span class="o">.</span><span class="n">length</span> <span class="o">)</span> <span class="c1">// divide the sum by the number of points  
</span></code></pre></div></div>

<p>And finally we treat the average displacement again as a point in space.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">center</span> <span class="k">=</span> <span class="n">centerV</span><span class="o">.</span><span class="n">toPoint</span>
</code></pre></div></div>

<h2 id="scalar-images">Scalar Images</h2>

<p>The next important data structure is the (scalar-) image.
A <em>discrete</em> scalar image (e.g. gray level image) in Scalismo is simply a function from a discrete domain of points to a scalar value.</p>

<p>We will need the following imports:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.io.ImageIO</span><span class="o">;</span> <span class="c1">// to read images
</span><span class="k">import</span> <span class="nn">scalismo.image.</span><span class="o">{</span><span class="nc">DiscreteScalarImage</span><span class="o">,</span> <span class="nc">DiscreteScalarImage3D</span><span class="o">}</span> <span class="c1">// discrete images
</span><span class="k">import</span> <span class="nn">scalismo.image.ScalarImage</span> <span class="c1">// continuous images
</span><span class="k">import</span> <span class="nn">scalismo.geometry.</span><span class="o">{</span><span class="nc">IntVector</span><span class="o">,</span> <span class="nc">IntVector3D</span><span class="o">}</span> <span class="c1">// represent image indices
</span></code></pre></div></div>

<p>Let’s read and display a 3D image (MRI of a human):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">image</span> <span class="k">=</span> <span class="nc">ImageIO</span><span class="o">.</span><span class="n">read3DScalarImage</span><span class="o">[</span><span class="kt">Short</span><span class="o">](</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/PaolaMRI.vtk"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">imageView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="n">image</span><span class="o">,</span> <span class="s">"mri"</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Note: depending on your view on the scene, it could appear as if the image is not displayed. In this case, make sure to rotate the scene and change the position of the slices as indicated below.</em></p>

<p>To visualize the different image slices in the viewer, select “Scene” (the upper node in the scene tree graph) and use the X,Y,Z sliders.</p>

<p>You can also change the way of visualizing the 3D scene under the</p>

<p><em>View -&gt; Perspective</em> menu.</p>

<h3 id="scalar-image-domain">Scalar Image domain</h3>

<p>Let’s inspect the domain of the image :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">origin</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">origin</span>
<span class="c1">// origin: Point[_3D] = Point3D(
//   92.54853820800781,
//   -121.92584228515625,
//   135.2670135498047
// )
</span><span class="k">val</span> <span class="n">spacing</span> <span class="k">:</span> <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">spacing</span>
<span class="c1">// spacing: EuclideanVector[_3D] = EuclideanVector3D(1.5, 1.5, 1.5)
</span><span class="k">val</span> <span class="n">size</span> <span class="k">:</span> <span class="kt">IntVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span>  
<span class="c1">// size: IntVector[_3D] = IntVector3D(171, 171, 139)
</span></code></pre></div></div>

<p>The discrete image domain is a 3-dimensional regular grid of points originating at point (92.5485, -121.926, 135.267),
with regular spacing of 1.5 mm in each dimension and containing 171, 171, 139 grid slots in the x, y and z directions respectively.</p>

<p>To better see this, let’s display the first 172 points of the image domain</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">imagePoints</span> <span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">172</span><span class="o">)</span>
<span class="k">val</span> <span class="n">gridPointsView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="n">imagePoints</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">,</span> <span class="s">"imagePoints"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="scalar-image-values">Scalar image values</h3>

<p>The other important part of a discrete image are the values associated with the domain points</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">values</span> <span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Short</span><span class="o">]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">values</span>
</code></pre></div></div>

<p>This is an iterator of scalar values of type <code class="highlighter-rouge">Short</code> as encoded in the read image.</p>

<p>Let’s check the first value, which is the value associated with the origin :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">next</span> 
<span class="c1">// res4: Short = 0
</span></code></pre></div></div>

<p>The point <em>origin</em> corresponds to the grid point with index (0,0,0). Hence, the same value can be obtained by accessing the image at this index :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span><span class="o">(</span><span class="nc">IntVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">))</span> 
<span class="c1">// res5: Short = 0
</span></code></pre></div></div>

<p>Naturally, the number of scalar values should be equal to the number of point domains</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">size</span>
</code></pre></div></div>

<p>Notice that you can check the intensity value at a particular point position in the image, by maintaining the Ctrl key pressed and hovering over the image. The intensity value will then be displayed in the lower left corner of the Scalismo viewer window.</p>

<h3 id="creating-scalar-images">Creating scalar images</h3>

<p>Given that discrete scalar images are a mapping between points and values,
we can easily create such images programmatically.</p>

<p>Here we create a new image defined on the same domain of points with artificially created values: We threshold an MRI image, where
all the values above 300 are replaced with 0.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">threshValues</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">map</span><span class="o">{</span><span class="n">v</span> <span class="k">:</span><span class="kt">Short</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">300</span><span class="o">)</span> <span class="n">v</span> <span class="k">else</span> <span class="mf">0.</span><span class="n">toShort</span><span class="o">}</span>
<span class="k">val</span> <span class="n">thresholdedImage</span> <span class="k">:</span> <span class="kt">DiscreteScalarImage</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">Short</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DiscreteScalarImage</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">Short</span><span class="o">](</span><span class="n">image</span><span class="o">.</span><span class="n">domain</span><span class="o">,</span> <span class="n">threshValues</span><span class="o">.</span><span class="n">toSeq</span><span class="o">)</span>
<span class="n">ui</span> <span class="n">show</span><span class="o">(</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="n">thresholdedImage</span><span class="o">,</span> <span class="s">"thresh"</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Note: We need to write 0.toShort or 0 : Short in order to ensure that the <code class="highlighter-rouge">threshValues</code> have type <code class="highlighter-rouge">Short</code> and not <code class="highlighter-rouge">Int</code>.</em></p>

<p>There is, however, also a more elegant way to write above code. <code class="highlighter-rouge">DiscreteScalarImage</code> supports a <code class="highlighter-rouge">map</code> method, which applies
an operation to all values. Using this method, we can write instead</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">thresholdedImage2</span> <span class="k">:</span> <span class="kt">DiscreteScalarImage</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>,<span class="kt">Short</span><span class="o">]</span> <span class="k">=</span> <span class="n">image</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">v</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">300</span><span class="o">)</span> <span class="n">v</span> <span class="k">else</span> <span class="mf">0.</span><span class="n">toShort</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="statistical-mesh-models">Statistical Mesh Models</h2>

<p>Finally, we look at Statistical Shape Models.</p>

<p>We need the following imports</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.io.StatisticalModelIO</span> <span class="c1">// to read statistical shape models
</span><span class="k">import</span> <span class="nn">scalismo.statisticalmodel.StatisticalMeshModel</span> <span class="c1">// the statistical shape models
</span></code></pre></div></div>

<p>Statistical models can be read by calling <code class="highlighter-rouge">readStatisticalMeshModel</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">faceModel</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/bfm.h5"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">faceModelView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">faceModel</span><span class="o">,</span> <span class="s">"faceModel"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="sampling-in-the-ui">Sampling in the UI</h3>

<p><em>Exercise: Sample random instances of faces by using the graphical tools in the scene pane : click on the “model” tree node and then the “Random” button</em></p>

<p><em>Exercise: click a landmark on a position of the face model, e.g. chin or eye corner.. (use the toggle button “LM” in the toolbar to activate landmark clicking). Rename this landmark and call it *noseLM</em>. Now continue sampling from the model. What happens to the selected point?*</p>

<p>As you can see, a new instance of the face model is displayed each time along with the corresponding landmark point. Notice how the position of the landmark point changes in space while it keeps the same “meaning” on the face (eye corner, tip of nose ..)</p>

<h3 id="sampling-programmatically">Sampling programmatically</h3>

<p>Sampling in the ui is useful for getting a visual impression of the variability of a model. But more often we want to
sample from a model programmatically. We can obtain a sample from the model, by calling the <code class="highlighter-rouge">sample method</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">randomFace</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">faceModel</span><span class="o">.</span><span class="n">sample</span>
</code></pre></div></div>

<h4 id="exercise-visualize-a-few-randomly-generated-meshes-in-the-ui">Exercise: Visualize a few randomly generated meshes in the ui.</h4>

<h5 id="retrieving-objects-from-scalismo-ui">Retrieving objects from Scalismo-ui</h5>

<p>This is a good point to show how objects that we added manually in Scalismo-ui can be retrieved programmatically. A typical example is,
that we manually clicked a landmark, such as our <code class="highlighter-rouge">noseLM</code>, on one of the visualized objects and would like to work with them in our
programs.
To achieve this we can use the <code class="highlighter-rouge">filter</code> method of the ui object. It works as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.ui.api.LandmarkView</span>
<span class="k">import</span> <span class="nn">scalismo.geometry.Landmark</span>

<span class="k">val</span> <span class="n">matchingLandmarkViews</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">LandmarkView</span><span class="o">]</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">filter</span><span class="o">[</span><span class="kt">LandmarkView</span><span class="o">](</span><span class="n">paolaGroup</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span> <span class="k">:</span> <span class="kt">LandmarkView</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"noseLM"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">matchingLandmarks</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Landmark</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">matchingLandmarkViews</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">lmView</span> <span class="k">=&gt;</span> <span class="n">lmView</span><span class="o">.</span><span class="n">landmark</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">filter</code> method is very general. The type parameter (the parameter inside []) indicates the type of <code class="highlighter-rouge">view</code> object we want to
search for. Here we look only for landmarks, and consequently specify the type <code class="highlighter-rouge">LandmarkView</code>. As a first we  pass the group,
in which we want to search for an object. The second argument is a predicate, which is executed for all objects in the group, of the right type.
Here we specify, that <code class="highlighter-rouge">filter</code> should match all objects whose name equals “noseLM”. Calling the <code class="highlighter-rouge">filter</code> method results in a sequence
of view objects, which match the predicate. To get the matching scalismo object, we call the method <code class="highlighter-rouge">landmark</code> on the view object.
We can do this for all landmark view objects in the sequence using the familiar <code class="highlighter-rouge">map</code> function.</p>

<p>Finally, we can get the id and position of the matched landmark as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">landmarkId</span> <span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">matchingLandmarks</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">id</span>
<span class="k">val</span> <span class="n">landmarkPosition</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">matchingLandmarks</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">point</span>
</code></pre></div></div>

<p><em>Remark: In exactly the same way we can retrieve all other types of objects,
which we can visualize in in Scalismo-ui, such as images, meshes, pointClouds, etc.</em></p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/js/main.js"></script></body></html>