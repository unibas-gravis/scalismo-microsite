<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Gravis Group, University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/img/poster.png" /><meta name="image" property="og:image" content="/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/tutorials/tutorial15.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="unibas-gravis" data-github-repo="scalismo-microsite"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="model-fitting-using-mcmc---fitting-a-shape-model">Model fitting using MCMC - Fitting a shape model</h1>

<p>In this tutorial we show how the MCMC framework, which was introduced in the previous
tutorial, can be used for shape model fitting.</p>

<p>We will illustrate it by computing a posterior of a shape model,
given a set of corresponding landmark pairs. This is the same setup that we have
discussed in the tutorial about Gaussian process regression. The difference is,
that here we will also allow for rotation and translation of the model. In this setting,
it is not possible anymore to compute the posterior analytically. Rather, our only hope are approximation methods, such as
using Markov-chain monte carlo methods.</p>

<p>In this tutorial we show not only a working example, but also how to make it
computationally efficient. Making the individual parts as efficient as possible is
important in sampling approaches, as we need to produce many samples to get accurate
estimates.</p>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and
initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.common.PointId</span>
<span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">LandmarkIO</span><span class="o">,</span> <span class="nc">MeshIO</span><span class="o">,</span> <span class="nc">StatisticalModelIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.mesh.TriangleMesh</span>
<span class="k">import</span> <span class="nn">scalismo.registration.</span><span class="o">{</span><span class="nc">RigidTransformation</span><span class="o">,</span> <span class="nc">RigidTransformationSpace</span><span class="o">,</span> <span class="nc">RotationTransform</span><span class="o">,</span> <span class="nc">TranslationTransform</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.algorithms.MetropolisHastings</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.evaluators.ProductEvaluator</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.proposals.MixtureProposal</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.loggers.AcceptRejectLogger</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.</span><span class="o">{</span><span class="nc">DistributionEvaluator</span><span class="o">,</span> <span class="nc">ProposalGenerator</span><span class="o">,</span> <span class="nc">TransitionProbability</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel.</span><span class="o">{</span><span class="nc">MultivariateNormalDistribution</span><span class="o">,</span> <span class="nc">StatisticalMeshModel</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api.ScalismoUI</span>
<span class="k">import</span> <span class="nn">scalismo.utils.Memoize</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="loading-and-visualizing-the-data">Loading and visualizing the data</h3>

<p>In a first step, we load and visualize all the data that we need.
First, we load the statistical model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/bfm.h5"</span><span class="o">)).</span><span class="n">get</span>

  <span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"model"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">modelView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
  <span class="n">modelView</span><span class="o">.</span><span class="n">meshView</span><span class="o">.</span><span class="n">opacity</span> <span class="k">=</span> <span class="mf">0.5</span>
</code></pre></div></div>

<p>In this example, we will fit the model such that a set of model landmarks, coincide
with a set of landmark points defined on a target face. We load and visualize the corresponding landmark data:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="n">modelLms</span> <span class="k">=</span> <span class="nc">LandmarkIO</span><span class="o">.</span><span class="n">readLandmarksJson</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/modelLM_mcmc.json"</span><span class="o">)).</span><span class="n">get</span>
  <span class="k">val</span> <span class="n">modelLmViews</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">modelLms</span><span class="o">,</span> <span class="s">"modelLandmarks"</span><span class="o">)</span>
  <span class="n">modelLmViews</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">lmView</span> <span class="k">=&gt;</span> <span class="n">lmView</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">BLUE</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">targetGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"target"</span><span class="o">)</span>
  
  <span class="k">val</span> <span class="n">targetLms</span> <span class="k">=</span> <span class="nc">LandmarkIO</span><span class="o">.</span><span class="n">readLandmarksJson</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/targetLM_mcmc.json"</span><span class="o">)).</span><span class="n">get</span>
  <span class="k">val</span> <span class="n">targetLmViews</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">targetGroup</span><span class="o">,</span> <span class="n">targetLms</span><span class="o">,</span> <span class="s">"targetLandmarks"</span><span class="o">)</span>
  <span class="n">modelLmViews</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">lmView</span> <span class="k">=&gt;</span> <span class="n">lmView</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">RED</span><span class="o">)</span>
</code></pre></div></div>

<p>In the following, we will refer to the points on the model using their point id, while the target
position is represented as physical points. The reason why we use the point id for the model is that the model instances,
and therefore the points, which are represented by the point id, are changing as we fit the model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">modelLmIds</span> <span class="k">=</span>  <span class="n">modelLms</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">pointId</span><span class="o">(</span><span class="n">l</span><span class="o">.</span><span class="n">point</span><span class="o">).</span><span class="n">get</span><span class="o">)</span>
<span class="k">val</span> <span class="n">targetPoints</span> <span class="k">=</span> <span class="n">targetLms</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">point</span><span class="o">)</span>
</code></pre></div></div>

<p>We assume that the target points we observe are subject to
noise, which we model as a normal distribution with <script type="math/tex">3 mm</script> standard deviation (hence <script type="math/tex">9 mm</script> variance):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">landmarkNoiseVariance</span> <span class="k">=</span> <span class="mf">9.0</span> 
<span class="k">val</span> <span class="n">uncertainty</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span>
  <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span>
  <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="n">landmarkNoiseVariance</span>
<span class="o">)</span>
</code></pre></div></div>

<p>We summarize the correspondences as a triple, consisting of model id, target position
and uncertainty.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">correspondences</span> <span class="k">=</span> <span class="n">modelLmIds</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">targetPoints</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">modelIdWithTargetPoint</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">modelId</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">)</span> <span class="k">=</span>  <span class="n">modelIdWithTargetPoint</span>
  <span class="o">(</span><span class="n">modelId</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">,</span> <span class="n">uncertainty</span><span class="o">)</span>
<span class="o">})</span>    
</code></pre></div></div>

<h3 id="the-parameter-class">The parameter class</h3>

<p>In this example, we want to model the posterior <script type="math/tex">p(\theta | D)</script>, where
the parameters <script type="math/tex">\theta =( t, r, \alpha)</script> consist of the translation parameters
<script type="math/tex">t=(t_x, t_y, t_z)</script>, the rotation parameters <script type="math/tex">r = (\phi, \psi, \omega)</script>,
represented as Euler angles as well a shape model coefficients <script type="math/tex">\alpha = (\alpha_1, \ldots, \alpha_n)</script>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Parameters</span><span class="o">(</span><span class="n">translationParameters</span><span class="k">:</span> <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span>
                     <span class="n">rotationParameters</span><span class="k">:</span> <span class="o">(</span><span class="kt">Double</span><span class="o">,</span> <span class="kt">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">),</span>
                     <span class="n">modelCoefficients</span><span class="k">:</span> <span class="kt">DenseVector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span>
</code></pre></div></div>

<p>As in the previous tutorial, we wrap this into a class representing the sample, which can keep track by whom
it was generated. Furthermore, we will add convenience method,
which builds a <code class="highlighter-rouge">RigidTransformation</code> from the parameters. As a rigid transformation
is not completely determined by the translation and rotation parameters, we need to
store also the center of rotation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Sample</span><span class="o">(</span><span class="n">generatedBy</span> <span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">parameters</span> <span class="k">:</span> <span class="kt">Parameters</span><span class="o">,</span> <span class="n">rotationCenter</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">poseTransformation</span> <span class="k">:</span> <span class="kt">RigidTransformation</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

      <span class="k">val</span> <span class="n">translation</span> <span class="k">=</span> <span class="nc">TranslationTransform</span><span class="o">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">rotation</span> <span class="k">=</span> <span class="nc">RotationTransform</span><span class="o">(</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_3</span><span class="o">,</span>
        <span class="n">rotationCenter</span>
      <span class="o">)</span>
      <span class="nc">RigidTransformation</span><span class="o">(</span><span class="n">translation</span><span class="o">,</span> <span class="n">rotation</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div></div>

<h3 id="evaluators-modelling-the-target-density">Evaluators: Modelling the target density</h3>

<p>As in the previous tutorial, we represent the unnormalized posterior distribution
as the product of prior and likelihood:
<script type="math/tex">p(\theta | D) \propto p(\theta) p(D | \theta)</script>,
where <script type="math/tex">D</script> denotes the data (i.e. the corresponding landmark points) and <script type="math/tex">\theta</script>
are our parameters.</p>

<p>As a prior over the shape parameters is given by the shape model. For the
translation and rotation, we assume a zero-mean normal distribution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">PriorEvaluator</span><span class="o">(</span><span class="n">model</span><span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">translationPrior</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">rotationPrior</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">model</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">translationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span><span class="o">.</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">translationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span><span class="o">.</span><span class="n">y</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">translationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span><span class="o">.</span><span class="n">z</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">rotationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">rotationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">+</span>
      <span class="n">rotationPrior</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_3</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>To compute the likelihood <script type="math/tex">p(D | \theta)</script> we first compute
the current model instance as determined by the shape and pose parameters.
From this model instance, the points at the given points id are extracted and
the distance to their target position is computed. This distance is what was
modelled by the uncertainty of the observations. We can therefore directly use
the modelled uncertainty to compute the likelihood of our model given the data:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">SimpleCorrespondenceEvaluator</span><span class="o">(</span><span class="n">model</span><span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">,</span>
                                   <span class="n">correspondences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">MultivariateNormalDistribution</span><span class="o">)])</span>
  <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>
   
  <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">currModelInstance</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">).</span><span class="n">transform</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">poseTransformation</span><span class="o">)</span>
  
    <span class="k">val</span> <span class="n">likelihoods</span> <span class="k">=</span> <span class="n">correspondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">correspondence</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">,</span> <span class="n">uncertainty</span><span class="o">)</span> <span class="k">=</span> <span class="n">correspondence</span>
      <span class="k">val</span> <span class="n">modelInstancePoint</span> <span class="k">=</span> <span class="n">currModelInstance</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">observedDeformation</span> <span class="k">=</span> <span class="n">targetPoint</span> <span class="o">-</span> <span class="n">modelInstancePoint</span>
  
      <span class="n">uncertainty</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">observedDeformation</span><span class="o">.</span><span class="n">toBreezeVector</span><span class="o">)</span>
    <span class="o">})</span>
  
  
    <span class="k">val</span> <span class="n">loglikelihood</span> <span class="k">=</span> <span class="n">likelihoods</span><span class="o">.</span><span class="n">sum</span>
    <span class="n">loglikelihood</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Conceptually, this is all that needed to be done to specify the target distribution.
In practice, we are interested to make these evaluators as efficient as possible,
as they are usually called thousands of times.</p>

<h5 id="performance-improvements">Performance improvements</h5>

<p>In the above implementation, we compute a full model instance (the new position of all the mesh points
represented by the shape model), although we are only interested in the position of the landmark points.
This is rather inefficient. A more efficient version would first marginalize the model to the
points of interest. Since marginalization changes the point ids, we need to map the
ids given as<code class="highlighter-rouge">correspondences</code> to their new ids. This is achieved by the following helper function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">marginalizeModelForCorrespondences</span><span class="o">(</span><span class="n">model</span><span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">,</span>
                                         <span class="n">correspondences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">MultivariateNormalDistribution</span><span class="o">)])</span>
    <span class="k">:</span> <span class="o">(</span><span class="kt">StatisticalMeshModel</span><span class="o">,</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">MultivariateNormalDistribution</span><span class="o">)])</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">val</span> <span class="o">(</span><span class="n">modelIds</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">correspondences</span><span class="o">.</span><span class="n">unzip3</span>
    <span class="k">val</span> <span class="n">marginalizedModel</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">marginal</span><span class="o">(</span><span class="n">modelIds</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">newCorrespondences</span> <span class="k">=</span> <span class="n">correspondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">idWithTargetPoint</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">,</span> <span class="n">uncertainty</span><span class="o">)</span> <span class="k">=</span> <span class="n">idWithTargetPoint</span>
      <span class="k">val</span> <span class="n">modelPoint</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">newId</span> <span class="k">=</span> <span class="n">marginalizedModel</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">findClosestPoint</span><span class="o">(</span><span class="n">modelPoint</span><span class="o">).</span><span class="n">id</span>
      <span class="o">(</span><span class="n">newId</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">,</span> <span class="n">uncertainty</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="o">(</span><span class="n">marginalizedModel</span><span class="o">,</span> <span class="n">newCorrespondences</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The more efficient version of the evaluator uses now the marginalized model to evaluate the likelihood:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">case</span> <span class="k">class</span> <span class="nc">CorrespondenceEvaluator</span><span class="o">(</span><span class="n">model</span><span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">,</span>
                                     <span class="n">correspondences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">MultivariateNormalDistribution</span><span class="o">)])</span>
    <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="o">(</span><span class="n">marginalizedModel</span><span class="o">,</span> <span class="n">newCorrespondences</span><span class="o">)</span> <span class="k">=</span> <span class="n">marginalizeModelForCorrespondences</span><span class="o">(</span><span class="n">model</span><span class="o">,</span> <span class="n">correspondences</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>

      <span class="k">val</span> <span class="n">currModelInstance</span> <span class="k">=</span> <span class="n">marginalizedModel</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">).</span><span class="n">transform</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">poseTransformation</span><span class="o">)</span>

      <span class="k">val</span> <span class="n">likelihoods</span> <span class="k">=</span> <span class="n">newCorrespondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">correspondence</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">targetPoint</span><span class="o">,</span> <span class="n">uncertainty</span><span class="o">)</span> <span class="k">=</span> <span class="n">correspondence</span>
        <span class="k">val</span> <span class="n">modelInstancePoint</span> <span class="k">=</span> <span class="n">currModelInstance</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">observedDeformation</span> <span class="k">=</span> <span class="n">targetPoint</span> <span class="o">-</span> <span class="n">modelInstancePoint</span>

        <span class="n">uncertainty</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">observedDeformation</span><span class="o">.</span><span class="n">toBreezeVector</span><span class="o">)</span>
      <span class="o">})</span>


      <span class="k">val</span> <span class="n">loglikelihood</span> <span class="k">=</span> <span class="n">likelihoods</span><span class="o">.</span><span class="n">sum</span>
      <span class="n">loglikelihood</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In order for the Metropolis-Hastings algorithm to decide if a new sample is accepted,
the likelihood needs to be computed several times for each set of parameters. To further
increase the efficiency, we should therefore cache the computations, such that when
an evaluator is used the second time with the same parameters, the <code class="highlighter-rouge">logValue</code> is
not recomputed, but simply taken from cache. Using the following utility class,
we can obtain for any evaluator a new evaluator, which performs such caching:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">case</span> <span class="k">class</span> <span class="nc">CachedEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">memoizedLogValue</span> <span class="k">=</span> <span class="nc">Memoize</span><span class="o">(</span><span class="n">evaluator</span><span class="o">.</span><span class="n">logValue</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">memoizedLogValue</span><span class="o">(</span><span class="n">sample</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div></div>

<h4 id="the-posterior-evaluator">The posterior evaluator</h4>

<p>Given these evaluators, we can now build the computationally efficient version of
our target density <script type="math/tex">p(\theta | D)</script></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">likelihoodEvaluator</span> <span class="k">=</span> <span class="nc">CachedEvaluator</span><span class="o">(</span><span class="nc">CorrespondenceEvaluator</span><span class="o">(</span><span class="n">model</span><span class="o">,</span> <span class="n">correspondences</span><span class="o">))</span>
<span class="k">val</span> <span class="n">priorEvaluator</span> <span class="k">=</span> <span class="nc">CachedEvaluator</span><span class="o">(</span><span class="nc">PriorEvaluator</span><span class="o">(</span><span class="n">model</span><span class="o">))</span>

<span class="k">val</span> <span class="n">posteriorEvaluator</span> <span class="k">=</span> <span class="nc">ProductEvaluator</span><span class="o">(</span><span class="n">priorEvaluator</span><span class="o">,</span> <span class="n">likelihoodEvaluator</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="the-proposal-generator">The proposal generator</h3>

<p>As in the previous tutorials, we will use simple random walk proposals.
We will define separate proposals for shape, translation and rotation.
On one hand, this lets us set the step length (i.e. stddev of the distribution from which we
sample the next step) individually for each group, and thus to incorporate our knowledge
that changes in rotation will be much smaller than the shape changes. On the other hand,
splitting the parameter updates in blocks will increase our chance for the random updates
to be accepted. The reason for this is that when many parameters are updated at one,
chances are high that some of the proposed changes make the new state more unlikely,
and hence increase the chance of the new state being rejected.</p>

<p>The definition of the proposals are straight-forward.</p>

<p>We start with the shape update proposal:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">class</span> <span class="nc">ShapeUpdateProposal</span><span class="o">(</span><span class="n">paramVectorSize</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">stddev</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>  <span class="k">with</span> <span class="nc">TransitionProbability</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">perturbationDistr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span>
      <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="n">paramVectorSize</span><span class="o">),</span>
      <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="n">paramVectorSize</span><span class="o">)</span> <span class="o">*</span> <span class="n">stddev</span> <span class="o">*</span> <span class="n">stddev</span>
    <span class="o">)</span>


    <span class="k">override</span> <span class="k">def</span> <span class="n">propose</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sample</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">perturbation</span> <span class="k">=</span> <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">sample</span><span class="o">()</span>
      <span class="k">val</span> <span class="n">newParameters</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">modelCoefficients</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span> <span class="o">+</span> <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">sample</span><span class="o">)</span>
      <span class="n">sample</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">generatedBy</span> <span class="k">=</span> <span class="n">s</span><span class="s">"ShapeUpdateProposal ($stddev)"</span><span class="o">,</span> <span class="n">parameters</span> <span class="k">=</span> <span class="n">newParameters</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logTransitionProbability</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">residual</span> <span class="k">=</span> <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span>
      <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">residual</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The update of the roation parameters is very similar. Note that we only update the
rotation parameters, but keep the center of rotation unchanged.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">case</span> <span class="k">class</span> <span class="nc">RotationUpdateProposal</span><span class="o">(</span><span class="n">stddev</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span>
    <span class="nc">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>  <span class="k">with</span> <span class="nc">TransitionProbability</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">perturbationDistr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span>
      <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span>
      <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="n">stddev</span> <span class="o">*</span> <span class="n">stddev</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">propose</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">perturbation</span> <span class="k">=</span> <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">sample</span>
      <span class="k">val</span> <span class="n">newRotationParameters</span> <span class="k">=</span> <span class="o">(</span>
        <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">perturbation</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
        <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">perturbation</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
        <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_3</span> <span class="o">+</span> <span class="n">perturbation</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
      <span class="o">)</span>
      <span class="k">val</span> <span class="n">newParameters</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">rotationParameters</span> <span class="k">=</span> <span class="n">newRotationParameters</span><span class="o">)</span>
      <span class="n">sample</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">generatedBy</span> <span class="k">=</span> <span class="n">s</span><span class="s">"RotationUpdateProposal ($stddev)"</span><span class="o">,</span> <span class="n">parameters</span> <span class="k">=</span> <span class="n">newParameters</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">logTransitionProbability</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">residual</span> <span class="k">=</span> <span class="nc">DenseVector</span><span class="o">(</span>
        <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_1</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span>
        <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_2</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span>
        <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_3</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">rotationParameters</span><span class="o">.</span><span class="n">_3</span>
      <span class="o">)</span>
      <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">residual</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Finally, we define the update proposal for the translation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">class</span> <span class="nc">TranslationUpdateProposal</span><span class="o">(</span><span class="n">stddev</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span>
     <span class="nc">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>  <span class="k">with</span> <span class="nc">TransitionProbability</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>
 
     <span class="k">val</span> <span class="n">perturbationDistr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span> <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span>
       <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="n">stddev</span> <span class="o">*</span> <span class="n">stddev</span><span class="o">)</span>
 
     <span class="k">def</span> <span class="n">propose</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">=</span> <span class="o">{</span>
       <span class="k">val</span> <span class="n">newTranslationParameters</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span> <span class="o">+</span> <span class="nc">EuclideanVector</span><span class="o">.</span><span class="n">fromBreezeVector</span><span class="o">(</span><span class="n">perturbationDistr</span><span class="o">.</span><span class="n">sample</span><span class="o">())</span>
       <span class="k">val</span> <span class="n">newParameters</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">translationParameters</span> <span class="k">=</span> <span class="n">newTranslationParameters</span><span class="o">)</span>
       <span class="n">sample</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">generatedBy</span> <span class="k">=</span> <span class="n">s</span><span class="s">"TranlationUpdateProposal ($stddev)"</span><span class="o">,</span> <span class="n">parameters</span> <span class="k">=</span> <span class="n">newParameters</span><span class="o">)</span>
     <span class="o">}</span>
 
     <span class="k">override</span> <span class="k">def</span> <span class="n">logTransitionProbability</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
       <span class="k">val</span> <span class="n">residual</span> <span class="k">=</span> <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">translationParameters</span>
       <span class="n">perturbationDistr</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">residual</span><span class="o">.</span><span class="n">toBreezeVector</span><span class="o">)</span>
     <span class="o">}</span>
   <span class="o">}</span>

</code></pre></div></div>

<p>The final proposal is a mixture of the three proposals we defined above.
We choose to update the shape more often than the translation and rotation parameters,
as we expect most changes to be shape changes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">shapeUpdateProposal</span> <span class="k">=</span> <span class="nc">ShapeUpdateProposal</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">rank</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">rotationUpdateProposal</span> <span class="k">=</span> <span class="nc">RotationUpdateProposal</span><span class="o">(</span><span class="mf">0.01</span><span class="o">)</span>
<span class="k">val</span> <span class="n">translationUpdateProposal</span> <span class="k">=</span> <span class="nc">TranslationUpdateProposal</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">generator</span> <span class="k">=</span> <span class="nc">MixtureProposal</span><span class="o">.</span><span class="n">fromProposalsWithTransition</span><span class="o">(</span>
                                    <span class="o">(</span><span class="mf">0.6</span><span class="o">,</span> <span class="n">shapeUpdateProposal</span><span class="o">),</span>
                                    <span class="o">(</span><span class="mf">0.2</span><span class="o">,</span> <span class="n">rotationUpdateProposal</span><span class="o">),</span>
                                    <span class="o">(</span><span class="mf">0.2</span><span class="o">,</span> <span class="n">translationUpdateProposal</span><span class="o">)</span>
                                <span class="o">)</span>   
</code></pre></div></div>

<h4 id="building-the-markov-chain">Building the Markov Chain</h4>

<p>For running the Markov Chain, we proceed exactly as in the previous tutorial. We start by defining the logger,
to compute the accept/reject ratios of the individual generators</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Logger</span> <span class="k">extends</span> <span class="nc">AcceptRejectLogger</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">numAccepted</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]()</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">numRejected</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]()</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">accept</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                        <span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                        <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">],</span>
                        <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>
                       <span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">numAcceptedSoFar</span> <span class="k">=</span> <span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">numAccepted</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="n">numAcceptedSoFar</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">reject</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                          <span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                          <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">],</span>
                          <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>
                         <span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">numRejectedSoFar</span> <span class="k">=</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">numRejected</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="n">numRejectedSoFar</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>


    <span class="k">def</span> <span class="n">acceptanceRatios</span><span class="o">()</span> <span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">generatorNames</span> <span class="k">=</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">toSet</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">numAccepted</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">toSet</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">acceptanceRatios</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">generatorName</span> <span class="k">&lt;-</span> <span class="n">generatorNames</span> <span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">total</span> <span class="k">=</span> <span class="o">(</span><span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
                     <span class="o">+</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)).</span><span class="n">toDouble</span>
        <span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">/</span> <span class="n">total</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="n">acceptanceRatios</span><span class="o">.</span><span class="n">toMap</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We then create the initial sample, where we choose here the center of mass of the model mean as the
rotation center.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">computeCenterOfMass</span><span class="o">(</span><span class="n">mesh</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">normFactor</span> <span class="k">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">numberOfPoints</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))((</span><span class="n">sum</span><span class="o">,</span> <span class="n">point</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">point</span><span class="o">.</span><span class="n">toVector</span> <span class="o">*</span> <span class="n">normFactor</span><span class="o">)</span>
<span class="o">}</span>


<span class="k">val</span> <span class="n">initialParameters</span> <span class="k">=</span> <span class="nc">Parameters</span><span class="o">(</span>
    <span class="nc">EuclideanVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">),</span>
    <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="n">model</span><span class="o">.</span><span class="n">rank</span><span class="o">)</span>
    <span class="o">)</span>

<span class="k">val</span> <span class="n">initialSample</span> <span class="k">=</span> <span class="nc">Sample</span><span class="o">(</span><span class="s">"initial"</span><span class="o">,</span> <span class="n">initialParameters</span><span class="o">,</span> <span class="n">computeCenterOfMass</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">))</span>

</code></pre></div></div>

<p><em>Remark: Setting the rotation center correctly is very important for the rotation proposal to work as expected.
Fortunately, most of the time this error is easy to diagnose, as the acceptance ratio of the rotation proposal will be unexpectedly low.</em></p>

<p>Next we set up the chain and obtain an iterator.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">chain</span> <span class="k">=</span> <span class="nc">MetropolisHastings</span><span class="o">(</span><span class="n">generator</span><span class="o">,</span> <span class="n">posteriorEvaluator</span><span class="o">)</span>
<span class="k">val</span> <span class="n">logger</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Logger</span><span class="o">()</span>    
<span class="k">val</span> <span class="n">mhIterator</span> <span class="k">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">iterator</span><span class="o">(</span><span class="n">initialSample</span><span class="o">,</span> <span class="n">logger</span><span class="o">)</span>
</code></pre></div></div>

<p>In this example we are interested to visualize some samples from the posterior as we run the chain. This can be done
by augmenting the iterator with visualization code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">samplingIterator</span> <span class="k">=</span> <span class="k">for</span><span class="o">((</span><span class="n">sample</span><span class="o">,</span> <span class="n">iteration</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">mhIterator</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
   <span class="n">println</span><span class="o">(</span><span class="s">"iteration "</span> <span class="o">+</span> <span class="n">iteration</span><span class="o">)</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">500</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">modelView</span><span class="o">.</span><span class="n">shapeModelTransformationView</span><span class="o">.</span><span class="n">shapeTransformationView</span><span class="o">.</span><span class="n">coefficients</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span>
     <span class="n">modelView</span><span class="o">.</span><span class="n">shapeModelTransformationView</span><span class="o">.</span><span class="n">poseTransformationView</span><span class="o">.</span><span class="n">transformation</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">poseTransformation</span>
   <span class="o">}</span>
   <span class="n">sample</span>
 <span class="o">}</span>   
</code></pre></div></div>

<p>Finally, we draw the samples using the chain by consuming the iterator. We drop the first 1000 iterations, as the
chain needs some burn-in time to converge to a equilibrium solution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">samples</span> <span class="k">=</span> <span class="n">samplingIterator</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">10000</span><span class="o">).</span><span class="n">toIndexedSeq</span>
</code></pre></div></div>

<p>Before working with the results, we check the acceptance ratios to verify that all the proposals work as expected:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">println</span><span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="n">acceptanceRatios</span><span class="o">())</span>
<span class="c1">// Map(RotationUpdateProposal (0.01) -&gt; 0.6971894832275612, TranlationUpdateProposal (1.0) -&gt; 0.5043859649122807, ShapeUpdateProposal (0.1) -&gt; 0.7907262398280362)
</span></code></pre></div></div>

<h3 id="analyzing-the-results">Analyzing the results</h3>

<p>Once we have the samples, we can now use them to analyze our fit.
For example, we can select the best fit from these samples and visualize it</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">bestSample</span> <span class="k">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="n">posteriorEvaluator</span><span class="o">.</span><span class="n">logValue</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bestFit</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span><span class="n">bestSample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">).</span><span class="n">transform</span><span class="o">(</span><span class="n">bestSample</span><span class="o">.</span><span class="n">poseTransformation</span><span class="o">)</span>
<span class="k">val</span> <span class="n">resultGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"result"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">resultGroup</span><span class="o">,</span> <span class="n">bestFit</span><span class="o">,</span> <span class="s">"best fit"</span><span class="o">)</span>
</code></pre></div></div>

<p>The samples allow us to infer much more about the distribution. For example, we can estimate the expected position of
any point in the model and the variance from the samples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  
 <span class="k">def</span> <span class="n">computeMean</span><span class="o">(</span><span class="n">model</span> <span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">PointId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">mean</span> <span class="k">=</span> <span class="nc">EuclideanVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">sample</span> <span class="k">&lt;-</span> <span class="n">samples</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">modelInstance</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">pointForInstance</span> <span class="k">=</span> <span class="n">modelInstance</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">poseTransformation</span><span class="o">).</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
      <span class="n">mean</span> <span class="o">+=</span> <span class="n">pointForInstance</span><span class="o">.</span><span class="n">toVector</span>
    <span class="o">}</span>
    <span class="o">(</span><span class="n">mean</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">toPoint</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">computeCovarianceFromSamples</span><span class="o">(</span><span class="n">model</span> <span class="k">:</span> <span class="kt">StatisticalMeshModel</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">PointId</span><span class="o">,</span> <span class="n">mean</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span><span class="k">:</span> <span class="kt">SquareMatrix</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">cov</span> <span class="k">=</span> <span class="nc">SquareMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">sample</span> <span class="k">&lt;-</span> <span class="n">samples</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">modelInstance</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">modelCoefficients</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">pointForInstance</span> <span class="k">=</span> <span class="n">modelInstance</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">poseTransformation</span><span class="o">).</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="n">pointForInstance</span> <span class="o">-</span> <span class="n">mean</span>
      <span class="n">cov</span> <span class="o">+=</span> <span class="n">v</span><span class="o">.</span><span class="n">outer</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">cov</span> <span class="o">*</span> <span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>For efficiency reasons, we do the computations here only for the landmark points, using again the marginalized model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="o">(</span><span class="n">marginalizedModel</span><span class="o">,</span> <span class="n">newCorrespondences</span><span class="o">)</span> <span class="k">=</span> <span class="n">marginalizeModelForCorrespondences</span><span class="o">(</span><span class="n">model</span><span class="o">,</span> <span class="n">correspondences</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">newCorrespondences</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">meanPointPosition</span> <span class="k">=</span> <span class="n">computeMean</span><span class="o">(</span><span class="n">marginalizedModel</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"expected position for point at id $id  = $meanPointPosition"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">cov</span> <span class="k">=</span> <span class="n">computeCovarianceFromSamples</span><span class="o">(</span><span class="n">marginalizedModel</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">meanPointPosition</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"posterior variance computed  for point at id (shape and pose) $id  = ${cov(0,0)}, ${cov(1,1)}, ${cov(2,2)}"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// expected position for point at id PointId(0)  = Point3D(148.10137201095068,-7.151235826279037,291.3929897650882)
// posterior variance computed  for point at id (shape and pose) PointId(0)  = 4.254464918957609, 3.939366851939425, 3.32790002246177
// expected position for point at id PointId(1)  = Point3D(142.24949688108646,-4.4064122402505745,266.34241057439533)
// posterior variance computed  for point at id (shape and pose) PointId(1)  = 2.918968756161676, 2.159129807301085, 2.915190937982501
// expected position for point at id PointId(2)  = Point3D(141.3051915247215,-4.2897512164448095,226.94538458273826)
// posterior variance computed  for point at id (shape and pose) PointId(2)  = 2.203212589533782, 1.9443312683620244, 3.558990457373749
// expected position for point at id PointId(3)  = Point3D(143.33662067133574,-4.885817375124605,201.61254954128444)
// posterior variance computed  for point at id (shape and pose) PointId(3)  = 4.211176241740335, 3.5805967352101438, 3.8214742761066214
// expected position for point at id PointId(4)  = Point3D(102.9147937651206,32.77448813851955,248.52670379739345)
// posterior variance computed  for point at id (shape and pose) PointId(4)  = 3.670091389108584, 4.998066354925429, 3.3640625099189827
// expected position for point at id PointId(5)  = Point3D(137.63389362946234,101.3277589516202,248.64874726494665)
// posterior variance computed  for point at id (shape and pose) PointId(5)  = 8.479207875196545, 6.924214739937887, 5.29092402298062
</span></code></pre></div></div>

<p>It is interesting to compare this posterior variance, with the variance we would have obtained by using a Gaussian process regression,
where we would have to assume the pose to be fixed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">posteriorFixedPose</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">correspondences</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>
</code></pre></div></div>

<p>Not surprisingly, computing the variance of this models reveals, that the points vary less in this model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">newCorrespondences</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">cov</span> <span class="k">=</span> <span class="n">posteriorFixedPose</span><span class="o">.</span><span class="n">cov</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"posterior variance computed by analytic posterior (shape only) for point with id $id = ${cov(0,0)}, ${cov(1,1)}, ${cov(2,2)}"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// posterior variance computed by analytic posterior (shape only) for point with id PointId(0) = 1.7493438462816924, 2.3773798978463545, 2.4529203603071132
// posterior variance computed by analytic posterior (shape only) for point with id PointId(1) = 1.7425234299448356, 2.347569081897583, 2.484181513654568
// posterior variance computed by analytic posterior (shape only) for point with id PointId(2) = 1.728312680395977, 2.311983615096077, 2.4760881301654973
// posterior variance computed by analytic posterior (shape only) for point with id PointId(3) = 1.7362509228394625, 2.3504558671936087, 2.4497130086130414
// posterior variance computed by analytic posterior (shape only) for point with id PointId(4) = 1.74656771644886, 2.315887303162952, 2.494671632799402
// posterior variance computed by analytic posterior (shape only) for point with id PointId(5) = 1.7511296018408746, 2.2802845887546255, 2.505733093422708
</span></code></pre></div></div>

<p>The reason for the reduced flexibility is that the model cannot adjust the pose, and hence has less freedom to explain the observed data.</p>

<h3 id="beyond-landmark-fitting">Beyond landmark fitting</h3>

<p>We have shown above how Scalismo can be used to perform Bayesian model fitting on the example of fitting 3D landmarks. This example
can easily be extended to other fitting tasks, such as fitting the model to points with unkown correspondences, fitting shapes in surfaces
of fitting a model to an image using an Active Shape Model as a likelihood function. In principle, all that is required is to
change the likelihood function and rerun the fit.
In practice, however, as a change in the likelihood function can dramatically change the posterior density, it is often required
to tune the proposals, such that good convergence can be achieved. Indeed, finding good proposal distributions is the key to
applying this method successfully. The more prior knowledge about the target distribution we can incorporate into the proposals,
the faster will the chain converge to the equilibrium distribution.</p>

<p>For more complicated use-cases of this method in image analysis , we refer the interested reader is referred to the paper by S. Schnborn et al.
and references therein:</p>

<ul>
  <li>Schnborn, Sandro, et al. Markov chain monte carlo for automated face image analysis. International Journal of Computer Vision 123.2 (2017): 160-183.</li>
</ul>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/js/main.js"></script></body></html>