<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Gravis Group, University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/img/poster.png" /><meta name="image" property="og:image" content="/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/tutorials/tutorial15.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="unibas-gravis" data-github-repo="scalismo-microsite"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="model-fitting-with-iterative-closest-points">Model fitting with Iterative Closest Points</h1>

<p>The goal in this tutorial is to non-rigidly fit a shape model to a target surface using Iterative Closest Points (ICP)
in order to establish correspondences among two surfaces.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371">(Video)</a></li>
  <li>Model-fitting and the registration problem <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250372">(Article)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel.MultivariateNormalDistribution</span>
<span class="k">import</span> <span class="nn">scalismo.numerics.UniformMeshSampler3D</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">MeshIO</span><span class="o">,</span> <span class="nc">StatisticalModelIO</span><span class="o">,</span> <span class="nc">LandmarkIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="problem-setup">Problem setup</h3>

<p>Let’s load and visualize a target mesh; I.e. a mesh, which we want to fit with our model, as well as
a statistical shape model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">targetMesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/target.ply"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/bfm.h5"</span><span class="o">)).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">targetGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"targetGroup"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">targetMeshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">targetGroup</span><span class="o">,</span> <span class="n">targetMesh</span><span class="o">,</span> <span class="s">"targetMesh"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"modelGroup"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">modelView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
</code></pre></div></div>

<p>As you can see in the 3D scene, the instance of the model taht we are currently displaying (the mean),
does not resemble the target face. The goal in shape model fitting is to find an
instance of our shape model, which resembles at best the given target face.
As we will see, a good fit directly leads to a way of establishing correspondences between the points of our model and the points
of the target shape.</p>

<h3 id="iterative-closest-points-icp-and-gp-regression">Iterative Closest Points (ICP) and GP regression</h3>

<p>In a previous tutorial, we introduced rigid ICP to find the best rigid transformation between two meshes.
We recall that the main steps of the algorithms are as follows:</p>

<ol>
  <li>Find <strong>candidate</strong> correspondences between the mesh to be aligned and the target one,
by attributing the closest point on the target mesh as a candidate.</li>
  <li>Solve for the best rigid transform between the moving mesh and the target mesh using Procrustes analysis.</li>
  <li>Transform the moving mesh using the retrieved transform</li>
  <li>Loop to step 1 if the result is not aligned with the target (or if we didn’t reach the limit number of iterations)</li>
</ol>

<p>The non-rigid ICP algorithm, which we can use for model fitting, will perform exactly the same steps.
However, instead of finding a rigid transformation in step 2, it finds a non-rigid one, using
Gaussian process regression.</p>

<p>We start by first selecting the points for which we want to find the correspondences. We choose uniformly distributed
points on the surface, which we can obtain as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sampler</span> <span class="k">=</span> <span class="nc">UniformMeshSampler3D</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">,</span> <span class="n">numberOfPoints</span> <span class="k">=</span> <span class="mi">5000</span><span class="o">)</span>
<span class="k">val</span> <span class="n">points</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pointWithProbability</span> <span class="k">=&gt;</span> <span class="n">pointWithProbability</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="c1">// we only want the points
</span></code></pre></div></div>

<p>Instead of working directly with the points, it is easier to work with the point ids of the sampled points:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ptIds</span> <span class="k">=</span> <span class="n">points</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">point</span> <span class="k">=&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">findClosestPoint</span><span class="o">(</span><span class="n">point</span><span class="o">).</span><span class="n">id</span><span class="o">)</span>
</code></pre></div></div>

<p>As in the previous tutorial, we write the method <code class="highlighter-rouge">attributeCorrespondences</code>, which finds for each
point of interest the closest point on the target.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">movingMesh</span><span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">ptIds</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">PointId</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">ptIds</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">id</span> <span class="k">:</span> <span class="kt">PointId</span> <span class="o">=&gt;</span> 
    <span class="k">val</span> <span class="n">pt</span> <span class="k">=</span> <span class="n">movingMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">closestPointOnMesh2</span> <span class="k">=</span> <span class="n">targetMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">findClosestPoint</span><span class="o">(</span><span class="n">pt</span><span class="o">).</span><span class="n">point</span>
    <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">closestPointOnMesh2</span><span class="o">)</span>
  <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>We can now use the correspondences we found to compute a Gaussian process regression.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">val</span> <span class="n">correspondences</span> <span class="k">=</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">)</span>

<span class="k">val</span> <span class="n">littleNoise</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span><span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span> <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">))</span>

<span class="k">def</span> <span class="n">fitModel</span><span class="o">(</span><span class="n">correspondences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">PointId</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])])</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="k">val</span> <span class="n">regressionData</span> <span class="k">=</span> <span class="n">correspondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">correspondence</span> <span class="k">=&gt;</span> 
    <span class="o">(</span><span class="n">correspondence</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">littleNoise</span><span class="o">)</span>
  <span class="o">)</span>
  <span class="k">val</span> <span class="n">posterior</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">regressionData</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>
  <span class="n">posterior</span><span class="o">.</span><span class="n">mean</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">fit</span> <span class="k">=</span> <span class="n">fitModel</span><span class="o">(</span><span class="n">correspondences</span><span class="o">)</span>
<span class="k">val</span> <span class="n">resultGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"results"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fitResultView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">resultGroup</span><span class="o">,</span> <span class="n">fit</span><span class="o">,</span> <span class="s">"fit"</span><span class="o">)</span>
</code></pre></div></div>

<p>While this one fitting iteration does not bring the points where we would like them to have, we are already
a step closer. As in the Rigid ICP case, we now iterate the procedure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">nonrigidICP</span><span class="o">(</span><span class="n">movingMesh</span><span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">ptIds</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">PointId</span><span class="o">],</span> <span class="n">numberOfIterations</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">numberOfIterations</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">movingMesh</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">correspondences</span> <span class="k">=</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">movingMesh</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">)</span>     
    <span class="k">val</span> <span class="n">transformed</span> <span class="k">=</span> <span class="n">fitModel</span><span class="o">(</span><span class="n">correspondences</span><span class="o">)</span>
        
    <span class="n">nonrigidICP</span><span class="o">(</span><span class="n">transformed</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Repeating the fitting steps iteratively for 20 times results in a good fit of our model</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">finalFit</span> <span class="k">=</span> <span class="n">nonrigidICP</span><span class="o">(</span> <span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>

<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">resultGroup</span><span class="o">,</span> <span class="n">finalFit</span><span class="o">,</span> <span class="s">"final fit"</span><span class="o">)</span>
</code></pre></div></div>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/js/main.js"></script></body></html>