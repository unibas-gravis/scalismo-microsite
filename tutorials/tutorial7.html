<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Gravis Group, University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/img/poster.png" /><meta name="image" property="og:image" content="/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="unibas-gravis" data-github-repo="scalismo-microsite"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="shape-modelling-with-gaussian-processes-and-kernels">Shape modelling with Gaussian processes and kernels</h1>

<p>In this tutorial we learn how to define our own Gaussian processes using analytically
defined kernels. Further, we experiment with different kernels that are useful in
shape modelling.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Covariance functions <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250350">(Video)</a></li>
  <li>Constructing kernels for shape modelling <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250351">(Article)</a></li>
  <li>Enlarging the flexibility of statistical shape models <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250357">(Article)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">StatisticalModelIO</span><span class="o">,</span> <span class="nc">MeshIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>
<span class="k">import</span> <span class="nn">scalismo.numerics.UniformMeshSampler3D</span>
<span class="k">import</span> <span class="nn">scalismo.kernels._</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<p>In the following we will always visualize the effect of different Gaussian process models,
by applying the deformations to a reference mesh. We therefore start by loading the mesh and visualizing
it in a separate group.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">referenceMesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/lowResPaola.ply"</span><span class="o">)).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"gp-model"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">referenceView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">referenceMesh</span><span class="o">,</span> <span class="s">"reference"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="modelling-deformations-using-gaussian-processes">Modelling deformations using Gaussian processes:</h2>

<p>A Gaussian Process is defined by two components: the <strong>mean function</strong> and the <strong>covariance function</strong>.</p>

<h5 id="the-mean">The mean:</h5>

<p>As we are modelling deformation fields, the mean of the Gaussian process will, of course, itself be a deformation field.
In terms of shape models, we can think of the mean function as the deformation field that deforms our reference mesh into the mean shape.</p>

<p>If the reference shape that we choose corresponds approximately to an average shape, and we do not have any further knowledge
about our shape space, it is entirely reasonable to use a zero mean; I.e. a deformation field which applies to
every point a zero deformation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">zeroMean</span> <span class="k">=</span> <span class="nc">Field</span><span class="o">(</span><span class="nc">RealSpace</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="o">(</span><span class="n">pt</span><span class="k">:</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">EuclideanVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">))</span>
</code></pre></div></div>

<h5 id="the-covariance-function">The covariance function:</h5>

<p>The covariance function, which is also referred to as a <em>kernel</em>,
defines the properties that characterize likely deformations in our model.
Formally, it is a symmetric, positive semi-definite function,
<script type="math/tex">k: X \times X \to R^{ d \times d}</script>, which defines the covariance between the
values at any pair of points <script type="math/tex">x, x'</script> of the domain. Since we are modelling deformation
fields (I.e. vector-valued functions), the covariance function is matrix-valued.</p>

<p>To define a kernel in Scalismo, we need to implement the following methods of the abstract class <code class="highlighter-rouge">MatrixValuedPDKernel</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]()</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">outputDim</span><span class="k">:</span> <span class="kt">Int</span><span class="o">;</span>
    <span class="k">def</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">Domain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">];</span>
    <span class="k">def</span> <span class="n">k</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span><span class="k">:</span> <span class="kt">DenseMatrix</span><span class="o">[</span><span class="kt">Double</span><span class="o">];</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The field <code class="highlighter-rouge">outputDim</code> determines the dimensionality of the values we model. In our case, we model 3D vectors, and hence <code class="highlighter-rouge">outputDim</code>should be 3.
The <code class="highlighter-rouge">domain</code> indicates the set of points on which our kernel is defined. Most often, we set this to the entire Euclidean space <code class="highlighter-rouge">RealSpace3D</code>.
Finally <code class="highlighter-rouge">k</code> denotes the covariance function.</p>

<p>The most often used kernel is the Gaussian kernel. Recall that the scalar-valued Gaussian kernel, is defined by the following formula:
<script type="math/tex">k_g(x,x') = \exp^{-\frac{\left\lVert x-x'\right\rVert^2}{\sigma^2} }.</script>
A corresponding matrix-valued kernel can be obtained by multiplying the value with an identity matrix (which implies, that we treat each space dimension as independent). In Scalismo, this is defined as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">MatrixValuedGaussianKernel3D</span><span class="o">(</span><span class="n">sigma2</span> <span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]()</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">outputDim</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">Domain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="nc">RealSpace</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">];</span>
    
    <span class="k">override</span> <span class="k">def</span> <span class="n">k</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span><span class="k">:</span> <span class="kt">DenseMatrix</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
       <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="n">outputDim</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Math</span><span class="o">.</span><span class="n">exp</span><span class="o">(-</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">).</span><span class="n">norm2</span> <span class="o">/</span> <span class="n">sigma2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span> 
</code></pre></div></div>

<p>This constructions allows us to define any kernel. For the most commonly used ones, such as the Gaussian kernel, there is, however,
an easier way in Scalismo. First, the scalar-valued Gaussian kernel is already implemented in Scalismo:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">scalarValuedGaussianKernel</span> <span class="k">:</span> <span class="kt">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span><span class="k">=</span> <span class="nc">GaussianKernel</span><span class="o">(</span><span class="n">sigma</span> <span class="k">=</span> <span class="mf">100.0</span><span class="o">)</span>
</code></pre></div></div>

<p>Further, the class <code class="highlighter-rouge">DiagonalKernel</code>allows us to turn any scalar-valued kernel into a matrix-valued kernel,
by specifying for each dimension of the output-space a kernel and assuming them to be independent. To obtain the same kernel as defined above, we can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">matrixValuedGaussianKernel</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">scalarValuedGaussianKernel</span><span class="o">,</span> <span class="n">scalarValuedGaussianKernel</span><span class="o">,</span> <span class="n">scalarValuedGaussianKernel</span><span class="o">)</span>
</code></pre></div></div>

<p>In this case, since we are using the same kernel in every space dimension, we can write this even more succinct as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">scalarValuedGaussianKernel</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<h5 id="building-the-gp-">Building the GP :</h5>

<p>Now that we have our mean and covariance functions, we can build a Gaussian process as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">(</span><span class="n">zeroMean</span><span class="o">,</span> <span class="n">matrixValuedGaussianKernel</span><span class="o">)</span>
</code></pre></div></div>

<p>We can now sample deformations from our Gaussian process <strong>at any desired set of points</strong>. Below we choose the points to be those of the reference mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sampleGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"samples"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sample</span> <span class="k">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">sample</span><span class="o">,</span> <span class="s">"gaussianKernelGP_sample"</span><span class="o">)</span>
</code></pre></div></div>

<p>The result is an instance from the Gaussian Process evaluated at the points
we indicated;  in this case on the points of the reference mesh.</p>

<p>We can visualize its effect by interpolating the deformation field, which we then use to deform the reference mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">interpolatedSample</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="nc">NearestNeighborInterpolator</span><span class="o">())</span>
<span class="k">val</span> <span class="n">deformedMesh</span> <span class="k">=</span> <span class="n">referenceMesh</span><span class="o">.</span><span class="n">transform</span><span class="o">((</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">interpolatedSample</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">deformedMesh</span><span class="o">,</span> <span class="s">"deformed mesh"</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="low-rank-approximation">Low-rank approximation</h4>

<p>Whenever we create a sample using the <code class="highlighter-rouge">sampleAtPoints</code> method of the Gaussian process, internally a matrix of dimensionality <script type="math/tex">nd \times nd</script>,where <script type="math/tex">n</script> denotes the number of points and <script type="math/tex">d</script> the dimensionality of the output space, is created. Hence if we want to sample
from many points we quickly run out of memory.</p>

<p>We can get around this problem by computing a low-rank approximation of the Gaussian process.
To obtain such a representation in Scalismo, we can use the method
````approximateGPCholesky``` of the <em>LowRankGaussianProcess</em> object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">lowRankGP</span> <span class="k">=</span> <span class="nc">LowRankGaussianProcess</span><span class="o">.</span><span class="n">approximateGPCholesky</span><span class="o">(</span>
    <span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span>
    <span class="n">gp</span><span class="o">,</span> 
    <span class="n">relativeTolerance</span> <span class="k">=</span> <span class="mf">0.01</span><span class="o">,</span>
    <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">()</span>
    <span class="o">)</span>
</code></pre></div></div>

<p>This call computes a finite-rank approximation of the Gaussian Process using a
Pivoted Cholesky approximation. The procedure automatically chooses the rank (I.e. the
number of basis functions of the Gaussian process), such that the given relative error
is achieved. (The error is measures in terms of the variance of the Gaussian
process, approximated on the points of the reference Mesh).
Using this low rank Gaussian process, we can now directly sample continuous deformation fields:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span>  <span class="n">defField</span> <span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span><span class="k">=</span> <span class="n">lowRankGP</span><span class="o">.</span><span class="n">sample</span>
</code></pre></div></div>

<p>These in turn, can be used to warp a reference mesh, as discussed above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">referenceMesh</span><span class="o">.</span><span class="n">transform</span><span class="o">((</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">defField</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>
</code></pre></div></div>

<p>More conveniently, we can visualize the sampled meshes by building again a <code class="highlighter-rouge">StatisticalMeshModel</code>,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ssm</span> <span class="k">=</span> <span class="nc">StatisticalMeshModel</span><span class="o">(</span><span class="n">referenceMesh</span><span class="o">,</span> <span class="n">lowRankGP</span><span class="o">)</span>
</code></pre></div></div>

<p>which we can directly visualize</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ssmView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">ssm</span><span class="o">,</span> <span class="s">"group"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="building-more-interesting-kernels">Building more interesting kernels</h3>

<p>In the following we show a few more examples of kernels, which are interesting for shape modelling.</p>

<h4 id="kernels-from-statistical-shape-models">Kernels from Statistical Shape Models</h4>

<p>As discussed previously, a Statistical Shape Model (SSM) in Scalismo is a discrete Gaussian process.
We have seen how to interpolate it to obtain a continuously defined Gaussian Process. As any
Gaussian process is  completely defined by its mean and covariance function, it follows that this is
also true for the GP in our statistical shape model.</p>

<p>This allows us to use this <em>sample covariance kernel</em> in combination with other kernels.
For example, we often want to slightly enlarge the flexibility of our statistical models.
In the following, we show how this can be achieved.</p>

<p>In a first step, we get the Gaussian process from the model an interpolate it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">pcaModel</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/lowresModel.h5"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">gpSSM</span> <span class="k">=</span> <span class="n">pcaModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="nc">NearestNeighborInterpolator</span><span class="o">())</span>
</code></pre></div></div>

<p>We can then access its covariance function, which is a kernel:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">covSSM</span> <span class="k">:</span> <span class="kt">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">gpSSM</span><span class="o">.</span><span class="n">cov</span>
</code></pre></div></div>

<p>In the next step, we model the additional variance using a Gaussian kernel and add it to the
<em>sample covariance kernel</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">augmentedCov</span> <span class="k">=</span> <span class="n">covSSM</span> <span class="o">+</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="nc">GaussianKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="mf">100.0</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>Finally, we build the Gaussian process with the new kernel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">augmentedGP</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">(</span><span class="n">gpSSM</span><span class="o">.</span><span class="n">mean</span><span class="o">,</span> <span class="n">augmentedCov</span><span class="o">)</span>
</code></pre></div></div>

<p>From here on, we follow the steps outlined above to obtain the <em>augmented</em> SSM.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">lowRankAugmentedGP</span> <span class="k">=</span> <span class="nc">LowRankGaussianProcess</span><span class="o">.</span><span class="n">approximateGPCholesky</span><span class="o">(</span>
    <span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span>
    <span class="n">augmentedGP</span><span class="o">,</span>  
    <span class="n">relativeTolerance</span> <span class="k">=</span> <span class="mf">0.01</span><span class="o">,</span>
    <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">(),</span> 
    <span class="o">)</span>
<span class="k">val</span> <span class="n">augmentedSSM</span> <span class="k">=</span> <span class="nc">StatisticalMeshModel</span><span class="o">(</span><span class="n">pcaModel</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">,</span> <span class="n">lowRankAugmentedGP</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="changepoint-kernel">Changepoint kernel:</h4>

<p>Another very useful kernel is the <em>changepoint kernel</em>.
A changepoint kernel is a combination of different kernels, where each kernel is active only in
a certain region of the space.</p>

<p>Here we show how we can define a kernel, which has different behavior in two different regions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">ChangePointKernel</span><span class="o">(</span><span class="n">kernel1</span> <span class="k">:</span> <span class="kt">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">kernel2</span> <span class="k">:</span> <span class="kt">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="nc">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]()</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">domain</span> <span class="k">=</span> <span class="nc">RealSpace</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">outputDim</span> <span class="k">=</span> <span class="mi">3</span>
    
  <span class="k">def</span> <span class="n">s</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=</span>  <span class="mf">1.0</span> <span class="o">/</span> <span class="o">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="o">(-</span><span class="n">p</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
  <span class="k">def</span> <span class="n">k</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">sx</span> <span class="k">=</span> <span class="n">s</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">sy</span> <span class="k">=</span> <span class="n">s</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
      <span class="n">kernel1</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">kernel2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sx</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sy</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Let’s visualize its effect with two different Gaussian Kernels</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">gk1</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="nc">GaussianKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="mf">100.0</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">gk2</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="nc">GaussianKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="mf">10.0</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">changePointKernel</span> <span class="k">=</span> <span class="nc">ChangePointKernel</span><span class="o">(</span><span class="n">gk1</span><span class="o">,</span> <span class="n">gk2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">gpCP</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">(</span><span class="n">zeroMean</span><span class="o">,</span> <span class="n">changePointKernel</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sampleCP</span> <span class="k">=</span>  <span class="n">gpCP</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">sampleCP</span><span class="o">,</span> <span class="s">"ChangePointKernelGP_sample"</span><span class="o">)</span>
</code></pre></div></div>

<p>As you can see each kernel is now active only on one half of the face.</p>

<h4 id="symmetrizing-a-kernel">Symmetrizing a kernel</h4>

<p>Quite often, the shapes that we aim to model exhibit a symmetry. This is particularly valid in the case of faces.
Therefore when modelling over such shapes, one would want deformation fields that yield symmetric shapes.</p>

<p>Once we obtained a kernel yielding the type of deformations we desire, it is possible to symmetrize the resulting deformation fields by applying the formula below:</p>

<p><img src=" data:image/png;base64,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" /></p>

<p>where <em>x<sub>m</sub></em> is the symmetric point to <em>x</em> around the YZ plane.</p>

<p>The resulting kernel will preserve the same smoothness properties of the deformation fields while adding the symmetry around the YZ plane.</p>

<p>Let’s turn it into code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">xMirroredKernel</span><span class="o">(</span><span class="n">kernel</span> <span class="k">:</span> <span class="kt">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">domain</span> <span class="k">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">domain</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">k</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=</span> <span class="n">kernel</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">,</span><span class="n">x</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">x</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span> <span class="n">y</span><span class="o">)</span>
  
<span class="o">}</span>

<span class="k">def</span> <span class="n">symmetrizeKernel</span><span class="o">(</span><span class="n">kernel</span> <span class="k">:</span> <span class="kt">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">:</span> <span class="kt">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">xmirrored</span> <span class="k">=</span> <span class="n">xMirroredKernel</span><span class="o">(</span><span class="n">kernel</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">k1</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">kernel</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> 
   <span class="k">val</span> <span class="n">k2</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">xmirrored</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1f</span><span class="o">,</span> <span class="n">xmirrored</span><span class="o">,</span> <span class="n">xmirrored</span><span class="o">)</span>  
   <span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">symmetrizedGaussian</span> <span class="k">=</span> <span class="n">symmetrizeKernel</span><span class="o">(</span><span class="nc">GaussianKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="mi">100</span><span class="o">))</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">gpSym</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">(</span><span class="n">zeroMean</span><span class="o">,</span> <span class="n">symmetrizedGaussian</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sampleGpSym</span> <span class="k">=</span>  <span class="n">gpSym</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">sampleGpSym</span><span class="o">,</span> <span class="s">"ChangePointKernelGP_sample"</span><span class="o">)</span>
</code></pre></div></div>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/js/main.js"></script></body></html>