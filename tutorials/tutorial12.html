<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Gravis Group, University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo-microsite/img/poster.png" /><meta name="image" property="og:image" content="/scalismo-microsite/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo-microsite/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo-microsite/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo-microsite/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo-microsite/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo-microsite/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo-microsite/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo-microsite/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo-microsite/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo-microsite/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo-microsite/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo-microsite/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo-microsite/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo-microsite/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo-microsite/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo-microsite/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo-microsite/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo-microsite/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo-microsite/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo-microsite/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo-microsite/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo-microsite/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo-microsite/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo-microsite/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo-microsite/css/style.css" /><link rel="stylesheet" href="/scalismo-microsite/css/palette.css" /><link rel="stylesheet" href="/scalismo-microsite/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo-microsite/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo-microsite/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo-microsite/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/unibas-gravis/scalismo"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="unibas-gravis" data-github-repo="scalismo-microsite"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="parametric-non-rigid-registration">Parametric, non-rigid registration:</h1>

<p>We have seen how non-rigid ICP can be used to establish correspondences.
In this tutorial we discuss a different approach to model-fitting and non-rigid registration.
We are formulating the registration problem as an optimization problem, which we optimize
using gradient-based optimization.</p>

<p>This registration is more general than ICP, in the sense that it can not only
be used for surface-to-surface registration, but also for image-to-image-registration.
In this tutorial we show the complete work-flow involved in a typical registration task,
from building the Gaussian process model to performing the actual optimization.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371">(Video)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.registration._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">MeshIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.numerics._</span>
<span class="k">import</span> <span class="nn">scalismo.kernels._</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="loading-and-visualizing-a-mesh">Loading and visualizing a mesh</h2>

<p>We start by loading and visualizing the reference mesh, which we will later use as the
domain for our Gaussian Process model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">referenceMesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/quickstart/facemesh.stl"</span><span class="o">)).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"model"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">refMeshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">referenceMesh</span><span class="o">,</span> <span class="s">"referenceMesh"</span><span class="o">)</span>
<span class="n">refMeshView</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">RED</span>
</code></pre></div></div>

<h2 id="building-a-gaussian-process-shape-model">Building a Gaussian process shape model</h2>

<p>We assume that our reference surface represents an approximately average face.
This justifies the use of a zero-mean Gaussian process. As a covariance function we use a Gaussian kernel and choose to treat the x,y,z component
of the vector field to be uncorrelated (indicated by the use of the <code class="highlighter-rouge">DiagonalKernel</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">mean</span> <span class="k">=</span> <span class="nc">VectorField</span><span class="o">(</span><span class="nc">RealSpace</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">EuclideanVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span>
<span class="k">val</span> <span class="n">kernel</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="nc">GaussianKernel</span><span class="o">(</span><span class="n">sigma</span> <span class="k">=</span> <span class="mi">70</span><span class="o">)</span> <span class="o">*</span> <span class="mf">50.0</span><span class="o">,</span> <span class="n">outputDim</span> <span class="k">=</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">(</span><span class="n">mean</span><span class="o">,</span> <span class="n">kernel</span><span class="o">)</span>
</code></pre></div></div>

<p>We then perform a low-rank approximation, to get a parametric representation of the
Gaussian process:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">lowRankGP</span> <span class="k">=</span> <span class="nc">LowRankGaussianProcess</span><span class="o">.</span><span class="n">approximateGPCholesky</span><span class="o">(</span>
    <span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span>
    <span class="n">gp</span><span class="o">,</span> 
    <span class="n">relativeTolerance</span> <span class="k">=</span> <span class="mf">0.05</span><span class="o">,</span>
    <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">()</span>
    <span class="o">)</span>
</code></pre></div></div>

<p>To visualize the effect of this Gaussian process, we add it to the
model group as a transformation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">gpView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">addTransformation</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">lowRankGP</span><span class="o">,</span> <span class="s">"gp"</span><span class="o">)</span>
</code></pre></div></div>

<p>This has the effect, that the transformations represented by this GP,
are applied to all the geometric objects, which are present in the group.
In this case, it is the mean of the Gaussian process, which is applied to
the reference mesh we loaded previously. By changing the parameters in the
ui, we can visualize different transformations, as we did previously
for statistical shape models.</p>

<p><em>Note: Adding the reference mesh to the scene, followed by a Gaussian process transformation
is indeed what happend internally, we visualized Statistical Shape Models in the
previous tutorials</em></p>

<p>Having visualized the Gaussian process, we can now draw random samples,
to assess whether out choice of parameters of the Gaussian process leads to
reasonable deformations. If not, we adjust the parameters until we are happy
with the deformations that are modelled.</p>

<h2 id="registration">Registration</h2>

<p>In the next step we perform the registration to a target mesh.
We start by loading the target mesh and displaying it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">targetGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"target"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">targetMesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/quickstart/face-2.stl"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">targetMeshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">targetGroup</span><span class="o">,</span> <span class="n">targetMesh</span><span class="o">,</span> <span class="s">"targetMesh"</span><span class="o">)</span>
</code></pre></div></div>

<p><em>To visualize a registration, it is best to change the perspective in the graphical user interface to “orthogonal slices”. You can find this functionality in the “View -&gt; Perspective” menu.</em></p>

<p>To define a registration, we need to define four things:</p>
<ol>
  <li>a <code class="highlighter-rouge">transformation space</code> that models the possible transformations of the reference surface (or the ambient space)</li>
  <li>a <code class="highlighter-rouge">metric</code> to measure the distance between the model (the deformed reference mesh) an the target surface.</li>
  <li>a <code class="highlighter-rouge">regularizer</code>, which penalizes unlikely transformations.</li>
  <li>an <code class="highlighter-rouge">optimizer</code>.</li>
</ol>

<p>For non-rigid registration we usually model the possible transformations using a Gaussian process. We use the Gaussian process that
we have defined above to define the transformation space.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">transformationSpace</span> <span class="k">=</span> <span class="nc">GaussianProcessTransformationSpace</span><span class="o">(</span><span class="n">lowRankGP</span><span class="o">)</span>
</code></pre></div></div>

<p>As a metric, we use a simple mean squares metric. Currently, all metrics that are available in scalismo are implemented as
image to image metrics. These can, however, easily be used for surface registration by representing the surface as  a distance image.
In addition to the images, the metric also needs to know the possible transformations (as modelled by the transformation space) and
a sampler. The sampler determines the points where the metric is evaluated. In our case we choose uniformely sampled points on the
reference mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">fixedImage</span> <span class="k">=</span> <span class="n">referenceMesh</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">toDistanceImage</span>
<span class="k">val</span> <span class="n">movingImage</span> <span class="k">=</span> <span class="n">targetMesh</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">toDistanceImage</span>
<span class="k">val</span> <span class="n">sampler</span> <span class="k">=</span> <span class="nc">FixedPointsUniformMeshSampler3D</span><span class="o">(</span><span class="n">referenceMesh</span><span class="o">,</span> <span class="n">numberOfPoints</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">)</span>
<span class="k">val</span> <span class="n">metric</span> <span class="k">=</span> <span class="nc">MeanSquaresMetric</span><span class="o">(</span><span class="n">fixedImage</span><span class="o">,</span> <span class="n">movingImage</span><span class="o">,</span> <span class="n">transformationSpace</span><span class="o">,</span> <span class="n">sampler</span><span class="o">)</span>
</code></pre></div></div>

<p>As an optimizer, we choose an LBFGS Optimizer</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">optimizer</span> <span class="k">=</span> <span class="nc">LBFGSOptimizer</span><span class="o">(</span><span class="n">maxNumberOfIterations</span> <span class="k">=</span> <span class="mi">100</span><span class="o">)</span>
</code></pre></div></div>

<p>and for regularization we choose to penalize the L2 norm using the <code class="highlighter-rouge">L2Regularizer</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">regularizer</span> <span class="k">=</span> <span class="n">L2Regularizer</span><span class="o">(</span><span class="n">transformationSpace</span><span class="o">)</span>
</code></pre></div></div>

<p>We are now ready to define Scalismo’s registration object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">registration</span> <span class="k">=</span> <span class="nc">Registration</span><span class="o">(</span><span class="n">metric</span><span class="o">,</span> <span class="n">regularizer</span><span class="o">,</span> <span class="n">regularizationWeight</span> <span class="k">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="n">optimizer</span><span class="o">)</span>
</code></pre></div></div>

<p>Registration is an iterative process. Consequently, we work with the registration using an iterator. We obtain an iterator by
calling the <code class="highlighter-rouge">iterator</code> method, where we also provide a starting position for the iteration (which is in this case the zero vector):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">initialCoefficients</span> <span class="k">=</span> <span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="n">lowRankGP</span><span class="o">.</span><span class="n">rank</span><span class="o">)</span>
<span class="k">val</span> <span class="n">registrationIterator</span> <span class="k">=</span> <span class="n">registration</span><span class="o">.</span><span class="n">iterator</span><span class="o">(</span><span class="n">initialCoefficients</span><span class="o">)</span>
</code></pre></div></div>

<p>Before running the registration, we change the iterator such that it prints in each iteration to current objective value,
and updates the visualization. This lets us visually inspect the progress of the registration procedure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">visualizingRegistrationIterator</span> <span class="k">=</span> <span class="k">for</span> <span class="o">((</span><span class="n">it</span><span class="o">,</span> <span class="n">itnum</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">registrationIterator</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"object value in iteration $itnum is ${it.value}"</span><span class="o">)</span>
  <span class="n">gpView</span><span class="o">.</span><span class="n">coefficients</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">parameters</span>
  <span class="n">it</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that the above code does not yet run the registration. It simply returns a new iterator, which augments
the original iteration with visualization. The actual registration is executed once we “consume” the iterator.
This can, for example be achieved by converting it to a sequence. The resulting sequence holds all the intermediate
states of the registration. We are usually only interested in the last one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">registrationResult</span> <span class="k">=</span> <span class="n">visualizingRegistrationIterator</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">last</span>
</code></pre></div></div>

<p>You should see in the graphical user interface, how the face mesh slowly adapts to the shape of the target mesh.</p>

<p>The final mesh representation can be obtained by obtaining the transform corresponding to the parameters and to
warp the reference mesh with this tranform:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">registrationTransformation</span> <span class="k">=</span> <span class="n">transformationSpace</span><span class="o">.</span><span class="n">transformForParameters</span><span class="o">(</span><span class="n">registrationResult</span><span class="o">.</span><span class="n">parameters</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fittedMesh</span> <span class="k">=</span> <span class="n">referenceMesh</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">registrationTransformation</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="working-with-the-registration-result">Working with the registration result</h3>

<p>The fittedMesh that we obtained above is a surface that approximates the target surface.  It corresponds to the best representation of the target in the model. For most tasks, this approximation is sufficient.
However, sometimes, we need an exact representation of the target mesh. This can be achieved by defining a projection function, which projects each point onto its closest point on the target.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">targetMeshOperations</span> <span class="k">=</span> <span class="n">targetMesh</span><span class="o">.</span><span class="n">operations</span>
<span class="k">val</span> <span class="n">projection</span> <span class="k">=</span> <span class="o">(</span><span class="n">pt</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="n">targetMeshOperations</span><span class="o">.</span><span class="n">closestPointOnSurface</span><span class="o">(</span><span class="n">pt</span><span class="o">).</span><span class="n">point</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Composing the result of the registration with this projection, will give us a mapping that identifies for each point of the reference mesh the corresponding point of the target mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">finalTransformation</span> <span class="k">=</span> <span class="n">registrationTransformation</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">projection</span><span class="o">)</span>
</code></pre></div></div>

<p>To check this last point, we warp the reference mesh with the finalTransform and visualize it. Note that the projected target now coincides with the target mesh..</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">projectedMesh</span> <span class="k">=</span> <span class="n">referenceMesh</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">finalTransformation</span><span class="o">)</span>
<span class="k">val</span> <span class="n">resultGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"result"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">projectionView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">resultGroup</span><span class="o">,</span> <span class="n">projectedMesh</span><span class="o">,</span> <span class="s">"projection"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="improving-registrations-for-more-complex-shapes">Improving registrations for more complex shapes.</h3>

<p>This registration procedure outlined above works reasonably well for simple cases. In complex cases, in particular if you have large
shape variations, you may find it difficult to find a suitable regularization weight. When you choose the regularization weight
large, the procedure will result in a nice and smooth mesh, but fails to closely fit the surface. If you choose it small, it may
result in folds and bad correspondences. In such cases it has proven extremely useful to simply iterate the registration procedure,
with decreasing regularization weights. In the following we illustrate this procedure. We start by defining a case class, which
collects all relevant parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">RegistrationParameters</span><span class="o">(</span><span class="n">regularizationWeight</span> <span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">numberOfSampledPoints</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>We put all the registration code into a function, which takes (among others) the registration parameters as an argument.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">doRegistration</span><span class="o">(</span>
            <span class="n">lowRankGP</span> <span class="k">:</span> <span class="kt">LowRankGaussianProcess</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]],</span>
            <span class="n">referenceMesh</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span>
            <span class="n">targetmesh</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span>
            <span class="n">registrationParameters</span> <span class="k">:</span> <span class="kt">RegistrationParameters</span><span class="o">,</span>
            <span class="n">initialCoefficients</span> <span class="k">:</span> <span class="kt">DenseVector</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
        <span class="o">)</span> <span class="k">:</span> <span class="kt">DenseVector</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">{</span>
        <span class="k">val</span> <span class="n">transformationSpace</span> <span class="k">=</span> <span class="nc">GaussianProcessTransformationSpace</span><span class="o">(</span><span class="n">lowRankGP</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">fixedImage</span> <span class="k">=</span> <span class="n">referenceMesh</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">toDistanceImage</span>
        <span class="k">val</span> <span class="n">movingImage</span> <span class="k">=</span> <span class="n">targetMesh</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">toDistanceImage</span>
        <span class="k">val</span> <span class="n">sampler</span> <span class="k">=</span> <span class="nc">FixedPointsUniformMeshSampler3D</span><span class="o">(</span>
            <span class="n">referenceMesh</span><span class="o">,</span>
            <span class="n">registrationParameters</span><span class="o">.</span><span class="n">numberOfSampledPoints</span>
            <span class="o">)</span>
        <span class="k">val</span> <span class="n">metric</span> <span class="k">=</span> <span class="nc">MeanSquaresMetric</span><span class="o">(</span>
            <span class="n">fixedImage</span><span class="o">,</span>
            <span class="n">movingImage</span><span class="o">,</span>
            <span class="n">transformationSpace</span><span class="o">,</span>
            <span class="n">sampler</span>
            <span class="o">)</span>
        <span class="k">val</span> <span class="n">optimizer</span> <span class="k">=</span> <span class="nc">LBFGSOptimizer</span><span class="o">(</span><span class="n">registrationParameters</span><span class="o">.</span><span class="n">numberOfIterations</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">regularizer</span> <span class="k">=</span> <span class="n">L2Regularizer</span><span class="o">(</span><span class="n">transformationSpace</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">registration</span> <span class="k">=</span> <span class="nc">Registration</span><span class="o">(</span>
            <span class="n">metric</span><span class="o">,</span>
            <span class="n">regularizer</span><span class="o">,</span>
            <span class="n">registrationParameters</span><span class="o">.</span><span class="n">regularizationWeight</span><span class="o">,</span>
            <span class="n">optimizer</span>
            <span class="o">)</span>
        <span class="k">val</span> <span class="n">registrationIterator</span> <span class="k">=</span> <span class="n">registration</span><span class="o">.</span><span class="n">iterator</span><span class="o">(</span><span class="n">initialCoefficients</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">visualizingRegistrationIterator</span> <span class="k">=</span> <span class="k">for</span> <span class="o">((</span><span class="n">it</span><span class="o">,</span> <span class="n">itnum</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">registrationIterator</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
              <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"object value in iteration $itnum is ${it.value}"</span><span class="o">)</span>
              <span class="n">gpView</span><span class="o">.</span><span class="n">coefficients</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">parameters</span>
              <span class="n">it</span>
        <span class="o">}</span>
        <span class="k">val</span> <span class="n">registrationResult</span> <span class="k">=</span> <span class="n">visualizingRegistrationIterator</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">last</span>
        <span class="n">registrationResult</span><span class="o">.</span><span class="n">parameters</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Finally, we define the parameters and run the registration. Note that when we decrease the
regularization weight, we typically need to sample less points from the surface.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">registrationParameters</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
        <span class="nc">RegistrationParameters</span><span class="o">(</span><span class="n">regularizationWeight</span> <span class="k">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="k">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">numberOfSampledPoints</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">),</span>
        <span class="nc">RegistrationParameters</span><span class="o">(</span><span class="n">regularizationWeight</span> <span class="k">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="k">=</span> <span class="mi">30</span><span class="o">,</span> <span class="n">numberOfSampledPoints</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">),</span>
        <span class="nc">RegistrationParameters</span><span class="o">(</span><span class="n">regularizationWeight</span> <span class="k">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="k">=</span> <span class="mi">40</span><span class="o">,</span> <span class="n">numberOfSampledPoints</span> <span class="k">=</span> <span class="mi">2000</span><span class="o">),</span>
        <span class="nc">RegistrationParameters</span><span class="o">(</span><span class="n">regularizationWeight</span> <span class="k">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="k">=</span> <span class="mi">50</span><span class="o">,</span> <span class="n">numberOfSampledPoints</span> <span class="k">=</span> <span class="mi">4000</span><span class="o">)</span>
    <span class="o">)</span>

    <span class="k">val</span> <span class="n">finalCoefficients</span> <span class="k">=</span> <span class="n">registrationParameters</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">initialCoefficients</span><span class="o">)((</span><span class="n">modelCoefficients</span><span class="o">,</span> <span class="n">regParameters</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">doRegistration</span><span class="o">(</span><span class="n">lowRankGP</span><span class="o">,</span> <span class="n">referenceMesh</span><span class="o">,</span> <span class="n">targetMesh</span><span class="o">,</span> <span class="n">regParameters</span><span class="o">,</span> <span class="n">modelCoefficients</span><span class="o">))</span>
</code></pre></div></div>

<p>From this point we use the procedure described above to work with the registration result.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo-microsite/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/scalismo-microsite/js/main.js"></script></body></html>