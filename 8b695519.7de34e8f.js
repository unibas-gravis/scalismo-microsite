(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{116:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return h}));var a=n(3),i=n(7),o=(n(0),n(154)),r={slug:"pdms-scalismo-090",title:"Point Distribution Models in Scalismo 0.90",author:"Marcel L\xfcthi",author_title:"Lecturer, Department of Mathematics and Computer Science, University of Basel",author_url:"https://github.com/marcelluethi/",author_image_url:"https://avatars2.githubusercontent.com/u/1332115?s=400&u=85f196182f47120058b7ae6edd0a41151b77ceb7&v=4",tags:["scalismo","website"]},s={permalink:"/blog/pdms-scalismo-090",editUrl:"https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/blog/blog/2020-12-19-pdms-in-scalismo-090.md",source:"@site/blog/2020-12-19-pdms-in-scalismo-090.md",description:"Introduction",date:"2020-12-19T00:00:00.000Z",tags:[{label:"scalismo",permalink:"/blog/tags/scalismo"},{label:"website",permalink:"/blog/tags/website"}],title:"Point Distribution Models in Scalismo 0.90",readingTime:5.89,truncated:!1,prevItem:{title:"Images in Scalismo 0.90",permalink:"/blog/pdms-images-scalismo-090"},nextItem:{title:"Welcome",permalink:"/blog/welcome"}},l=[{value:"Introduction",id:"introduction",children:[]},{value:"From StatisticalMeshModel to PointDistributionModel",id:"from-statisticalmeshmodel-to-pointdistributionmodel",children:[]},{value:"Creating and working with Point Distribution Models",id:"creating-and-working-with-point-distribution-models",children:[]},{value:"Changing the domain",id:"changing-the-domain",children:[]},{value:"Summary",id:"summary",children:[]}],c={rightToc:l};function h(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h3",{id:"introduction"},"Introduction"),Object(o.b)("p",null,"The recently released version of Scalismo - version 0.90 - comes with a number of important changes in its\ncore classes. In this blog post we will look at the class ",Object(o.b)("inlineCode",{parentName:"p"},"PointDistributionModel"),", which replaces and\ngeneralizes ",Object(o.b)("inlineCode",{parentName:"p"},"StatisticalMeshModel"),". "),Object(o.b)("p",null,"We start by discussing the differences to the previous implementation. We then show how to create Point Distribution Models.\nIn the last part we will discuss how we can change the domain over which the Point Distribution Model is defined. This allows us to change\nthe resolution of the model, restrict the model to a subset of the original domain, or even to change the type of domain over which the model is defined.   "),Object(o.b)("h3",{id:"from-statisticalmeshmodel-to-pointdistributionmodel"},"From StatisticalMeshModel to PointDistributionModel"),Object(o.b)("p",null,"Recall that shape variations are modelled using Gaussian processes in Scalismo. More precisely,\nwe use a low-rank approximation of a Gaussian process, which models a probability distribution over deformation fields,"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val lowrankGP : LowRankGaussianProcess[_3D, EuclideanVector[_3D]] = ???\n")),Object(o.b)("p",null,"The type signature indicates that the Gaussian process is defined in 3D space and it represents a\ncollection of random variables over 3D vectors in Euclidean space."),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"StatisticalMeshModel")," is the restriction of this continuously defined Gaussian Process to\na discrete and finite set of points. This set of points is defined to be the vertices of a triangle mesh,\nwhich is called the reference mesh.\nThus, a ",Object(o.b)("inlineCode",{parentName:"p"},"StatisticalMeshModel")," is just an aggregate of a mesh and a corresponding Gaussian process,\nrestricted to the points of the reference mesh. This is reflected in the definition in Scalismo: "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"case class StatisticalMeshModel (referenceMesh: TriangleMesh[_3D],\n                                 gp: DiscreteLowRankGaussianProcess[_3D, TriangleMesh, EuclideanVector[_3D]]) \n")),Object(o.b)("p",null,"When we draw a sample from this model, we actually draw a sample from the Gaussian process and apply\nthe sampled deformation field to the points of the reference mesh. The resulting sample is the deformed version of the reference mesh."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val ssm : StatisticalMeshModel = ???\nval sample : TriangleMesh[_3D] = ssm.sample\n")),Object(o.b)("p",null,"From this description it becomes obvious how we can generalize this to other types of datasets.\nAs we only use the points of the mesh, we can relax the restriction that the reference has to be a triangle mesh.\nInstead, we assume that the dataset is defined on a finite set of points. In Scalismo, a dataset which is defined on\na finite set of points is modelled as a subtype of the class ",Object(o.b)("inlineCode",{parentName:"p"},"DiscreteDomain"),". This is the basis of the definition of\na ",Object(o.b)("inlineCode",{parentName:"p"},"PointDistributionModel"),":"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"case class PointDistributionModel[D, DDomain[D] <: DiscreteDomain[D]](\n    reference : DDomain[D], \n    gp: DiscreteLowRankGaussianProcess[D, DDomain, EuclideanVector[D]]\n ) (implicit warper: DomainWarp[D, DDomain])\n")),Object(o.b)("p",null,"Here we replaced ",Object(o.b)("inlineCode",{parentName:"p"},"TriangleMesh")," by the generic type ",Object(o.b)("inlineCode",{parentName:"p"},"DDomain"),", which can be any subtype\nof a ",Object(o.b)("inlineCode",{parentName:"p"},"DiscreteDomain"),". The implicit argument ",Object(o.b)("inlineCode",{parentName:"p"},"warper")," restricts the domains further to domains\nthat can be deformed. In Scalismo these are currently the classes ",Object(o.b)("inlineCode",{parentName:"p"},"TriangleMesh"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"TetrahedralMesh"),", ",Object(o.b)("inlineCode",{parentName:"p"},"LineMesh")," and ",Object(o.b)("inlineCode",{parentName:"p"},"UnstructuredPointsDomain"),".",Object(o.b)("sup",null,Object(o.b)("a",{parentName:"p",href:"#myfootnote1"},"1"))," "),Object(o.b)("p",null,"In the actual Scalismo implementation, the definition of the class ",Object(o.b)("inlineCode",{parentName:"p"},"PointDistributionModel")," is even a bit simpler.\nThe reference is assumed to coincide with the domain over which the (discrete) Gaussian process is defined. Therefore,\nwe do not even need to explicitly represent it as part of the class ",Object(o.b)("inlineCode",{parentName:"p"},"PointDistributionModel"),"."),Object(o.b)("h3",{id:"creating-and-working-with-point-distribution-models"},"Creating and working with Point Distribution Models"),Object(o.b)("p",null,"Now that we know what a Point Distribution Model is, we will show how we work with them in Scalismo.\nOur first example illustrates how to learn a Point Distribution Model of tetrahedral meshes from given example meshes.\nThis is simple: We create a data collection, where we provide a sequence of tetrahedral meshes and use the method ",Object(o.b)("inlineCode",{parentName:"p"},"createUsingPCA"),"\nto create the model:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val referenceMesh: TetrahedralMesh[_3D] = ???\nval trainingMeshes: Seq[TetrahedralMesh[_3D]] = ???\nval dataCollection = DataCollection.fromTetrahedralMeshSequence(referenceMesh, trainingMeshes)\nval pdmTetraMesh = PointDistributionModel.createUsingPCA(dataCollection)\n")),Object(o.b)("p",null,"As expected, samples from this model are valid tetrahedral meshes."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val sample: scalismo.mesh.TetrahedralMesh[_3D] = pdmTetraMesh.sample()\n")),Object(o.b)("p",null,"Creating models of other types of data sets works exactly in the same way. We simply change the corresponding type\nof the reference and the data collection. "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val referenceMesh: TriangleMesh[_3D] = ???\nval trainingMeshes: Seq[TriangleMesh[_3D]] = ???\nval dataCollection = DataCollection.fromTriangleMeshSequence(referenceMesh, trainingMeshes)\nval pdmTriangleMesh = PointDistributionModel.createUsingPCA(dataCollection)\n")),Object(o.b)("p",null,"A second way to create a PDMs is to specify a low rank Gaussian process as well as a reference mesh on which\nthe Gp will be discretized:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val lowRankGP : LowRankGaussianProcess[_3D, EuclideanVector[_3D]] = ???\nval reference : TriangleMesh[_3D] = ???\nval pdmTriangleMesh  : PointDistributionModel[_3D, TriangleMesh] = PointDistributionModel(reference, lowRankGP)\n")),Object(o.b)("p",null,"Again, samples from the model will have the correct type:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val sample : TriangleMesh[_3D] = pdmTriangleMesh.sample\n")),Object(o.b)("h3",{id:"changing-the-domain"},"Changing the domain"),Object(o.b)("p",null,"The new implementation opens an interesting new possibility: We can\nchange the domain over which the point distribution model is defined.\nTo achieve this, we call the methods ",Object(o.b)("inlineCode",{parentName:"p"},"newReference")," and provide as an argument the new reference mesh\nand an interpolator. Internally, the interpolator is used to obtain a continuously defined ",Object(o.b)("inlineCode",{parentName:"p"},"LowRankGaussianProcess"),"\nfrom the ",Object(o.b)("inlineCode",{parentName:"p"},"DiscreteLowRankGaussianProcess"),". From above discussion we already know how to create a PDM from a ",Object(o.b)("inlineCode",{parentName:"p"},"reference")," and\na ",Object(o.b)("inlineCode",{parentName:"p"},"LowRankGaussianProcess"),". This is exactly what is done behind the scenes when we call ",Object(o.b)("inlineCode",{parentName:"p"},"newReference"),".  "),Object(o.b)("p",null,"In the following example we show how we can use this method to obtain a\nPDM of a triangle mesh from a model defined over tetrahedral meshes. As the new reference\nwe use the outer surface of the tetrahedral mesh over which the original PDM is defined"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val triangleRefMesh: TriangleMesh[_3D] = pdmTetraMesh.reference.getOuterSurface\nval pdmOuterSurface : PointDistributionModel[_3D, TriangleMesh] = pdm.newReference(triangleRefMesh, BarycentricInterpolator3D())\n")),Object(o.b)("p",null,"Another common use case for this method is to restrict the model to a subset of the vertices on\nwhich the PDM is defined. This can either be used for restricting the model to a part of the domain, or to change\nthe resolution of the domain. This latter use case is illustrated in the following code:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-scala"},"val decimatedMesh = pdmTriangleMesh.reference.operations.decimate(targetNumberOfVertices = 100) \nval pdmTriangleDecimated = pdmTriangle.newReference(decimatedMesh, TriangleMeshInterpolato3Dr())\n")),Object(o.b)("p",null,"Having an easily accessible method to change the points on which the PDM is defined, makes it possible to choose\nthe appropriate mesh resolution for each task. We might for example want to start with a high resolution model, which result in\nvisually pleasing samples when rendered, but reduce the mesh resolution when fitting the model, in order to save computation time."),Object(o.b)("h3",{id:"summary"},"Summary"),Object(o.b)("p",null,"We have seen that the new PDM class generalizes the concept of ",Object(o.b)("inlineCode",{parentName:"p"},"StatisticalMeshModel")," from previous versions of Scalismo.\nThe newly introduced class ",Object(o.b)("inlineCode",{parentName:"p"},"PointDistributionModel")," can be defined over any subtype of ",Object(o.b)("inlineCode",{parentName:"p"},"DiscreteDomain"),", which supports a warping operation.\nBesides triangle and tetrahedral meshes, this includes line meshes and unstructured point domains.\nAnother notable feature of Point Distribution Model is that it provides a method to change the\ndomain over which the PDM is defined. This makes it possible to restrict a Gaussian process model to a part of the domain,\nchange the type of the domain or to change its resolution. "),Object(o.b)("h4",{id:"footnotes"},"Footnotes"),Object(o.b)("a",{name:"footnote1"},"1"),": An example for a discrete domain, which cannot be used as a basis for a PDM is a",Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"DiscreteImage"),". The reason is that an image is defined on a regular grid, but once we warp the grid\nit is not regular anymore and hence not an image."))}h.isMDXComponent=!0},154:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),h=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=h(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},p=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=h(n),p=a,b=d["".concat(r,".").concat(p)]||d[p]||m[p]||o;return n?i.a.createElement(b,s(s({ref:t},c),{},{components:n})):i.a.createElement(b,s({ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);