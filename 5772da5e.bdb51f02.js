(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{154:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return g}));var r=a(0),n=a.n(r);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=n.a.createContext({}),p=function(e){var t=n.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=p(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},h=n.a.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,g=u["".concat(o,".").concat(h)]||u[h]||m[h]||i;return a?n.a.createElement(g,s(s({ref:t},c),{},{components:a})):n.a.createElement(g,s({ref:t},c))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.a.createElement.apply(null,o)}return n.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"},97:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return p}));var r=a(3),n=a(7),i=(a(0),a(154)),o={id:"tutorial12",title:"Parametric, non-rigid registration"},s={unversionedId:"tutorials/tutorial12",id:"version-0.18/tutorials/tutorial12",isDocsHomePage:!1,title:"Parametric, non-rigid registration",description:"We have seen how non-rigid ICP can be used to establish correspondences.",source:"@site/versioned_docs/version-0.18/tutorials/tutorial12.md",slug:"/tutorials/tutorial12",permalink:"/docs/0.18/tutorials/tutorial12",editUrl:"https://github.com/unibas-gravis/scalismo-microsite/edit/master/website/versioned_docs/version-0.18/tutorials/tutorial12.md",version:"0.18",sidebar:"version-0.18/docs",previous:{title:"Model fitting with Iterative Closest Points",permalink:"/docs/0.18/tutorials/tutorial11"},next:{title:"Active Shape Model fitting",permalink:"/docs/0.18/tutorials/tutorial13"}},l=[{value:"Loading and visualizing a mesh",id:"loading-and-visualizing-a-mesh",children:[]},{value:"Building a Gaussian process shape model",id:"building-a-gaussian-process-shape-model",children:[]},{value:"Registration",id:"registration",children:[{value:"Working with the registration result",id:"working-with-the-registration-result",children:[]},{value:"Improving registrations for more complex shapes.",id:"improving-registrations-for-more-complex-shapes",children:[]}]}],c={rightToc:l};function p(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"We have seen how non-rigid ICP can be used to establish correspondences.\nIn this tutorial we discuss a different approach to model-fitting and non-rigid registration.\nWe are formulating the registration problem as an optimization problem, which we optimize\nusing gradient-based optimization."),Object(i.b)("p",null,"This registration is more general than ICP, in the sense that it can not only\nbe used for surface-to-surface registration, but also for image-to-image-registration.\nIn this tutorial we show the complete work-flow involved in a typical registration task,\nfrom building the Gaussian process model to performing the actual optimization."),Object(i.b)("h5",{id:"related-resources"},"Related resources"),Object(i.b)("p",null,"The following resources from our ",Object(i.b)("a",{parentName:"p",href:"https://www.futurelearn.com/courses/statistical-shape-modelling"},"online course")," may provide\nsome helpful context for this tutorial:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Model-fitting and correspondence ",Object(i.b)("a",{parentName:"li",href:"https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371"},"(Video)"))),Object(i.b)("h5",{id:"preparation"},"Preparation"),Object(i.b)("p",null,"As in the previous tutorials, we start by importing some commonly used objects and initializing the system."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"import scalismo.geometry._\nimport scalismo.common._\nimport scalismo.ui.api._\nimport scalismo.mesh._\nimport scalismo.registration._\nimport scalismo.io.{MeshIO}\nimport scalismo.numerics._\nimport scalismo.kernels._\nimport scalismo.statisticalmodel._\nimport breeze.linalg.{DenseVector}\n\nscalismo.initialize()\nimplicit val rng = scalismo.utils.Random(42)\n\nval ui = ScalismoUI()\n")),Object(i.b)("h2",{id:"loading-and-visualizing-a-mesh"},"Loading and visualizing a mesh"),Object(i.b)("p",null,"We start by loading and visualizing the reference mesh, which we will later use as the\ndomain for our Gaussian Process model."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'val referenceMesh = MeshIO.readMesh(new java.io.File("datasets/quickstart/facemesh.ply")).get\n\nval modelGroup = ui.createGroup("model")\nval refMeshView = ui.show(modelGroup, referenceMesh, "referenceMesh")\nrefMeshView.color = java.awt.Color.RED\n')),Object(i.b)("h2",{id:"building-a-gaussian-process-shape-model"},"Building a Gaussian process shape model"),Object(i.b)("p",null,"We assume that our reference surface represents an approximately average face.\nThis justifies the use of a zero-mean Gaussian process. As a covariance function we use a Gaussian kernel and choose to treat the x,y,z component\nof the vector field to be uncorrelated (indicated by the use of the ",Object(i.b)("inlineCode",{parentName:"p"},"DiagonalKernel"),")."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val mean = VectorField(RealSpace[_3D], (_ : Point[_3D]) => EuclideanVector.zeros[_3D])\nval kernel = DiagonalKernel[_3D](GaussianKernel(sigma = 70) * 50.0, outputDim = 3)\nval gp = GaussianProcess(mean, kernel)\n")),Object(i.b)("p",null,"We then perform a low-rank approximation, to get a parametric representation of the\nGaussian process:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(\n    referenceMesh.pointSet,\n    gp,\n    relativeTolerance = 0.05,\n    interpolator = NearestNeighborInterpolator()\n    )\n")),Object(i.b)("p",null,"To visualize the effect of this Gaussian process, we add it to the\nmodel group as a transformation."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'val gpView = ui.addTransformation(modelGroup, lowRankGP, "gp")\n')),Object(i.b)("p",null,"This has the effect, that the transformations represented by this GP,\nare applied to all the geometric objects, which are present in the group.\nIn this case, it is the mean of the Gaussian process, which is applied to\nthe reference mesh we loaded previously. By changing the parameters in the\nui, we can visualize different transformations, as we did previously\nfor statistical shape models."),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Note: Adding the reference mesh to the scene, followed by a Gaussian process transformation\nis indeed what happend internally, we visualized Statistical Shape Models in the\nprevious tutorials")),Object(i.b)("p",null,"Having visualized the Gaussian process, we can now draw random samples,\nto assess whether out choice of parameters of the Gaussian process leads to\nreasonable deformations. If not, we adjust the parameters until we are happy\nwith the deformations that are modelled."),Object(i.b)("h2",{id:"registration"},"Registration"),Object(i.b)("p",null,"In the next step we perform the registration to a target mesh.\nWe start by loading the target mesh and displaying it."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'val targetGroup = ui.createGroup("target")\nval targetMesh = MeshIO.readMesh(new java.io.File("datasets/quickstart/face-2.ply")).get\nval targetMeshView = ui.show(targetGroup, targetMesh, "targetMesh")\n')),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},'To visualize a registration, it is best to change the perspective in the graphical user interface to "orthogonal slices". You can find this functionality in the "View -> Perspective" menu.')),Object(i.b)("p",null,"To define a registration, we need to define four things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"a ",Object(i.b)("inlineCode",{parentName:"li"},"transformation space")," that models the possible transformations of the reference surface (or the ambient space)"),Object(i.b)("li",{parentName:"ol"},"a ",Object(i.b)("inlineCode",{parentName:"li"},"metric")," to measure the distance between the model (the deformed reference mesh) an the target surface."),Object(i.b)("li",{parentName:"ol"},"a ",Object(i.b)("inlineCode",{parentName:"li"},"regularizer"),", which penalizes unlikely transformations."),Object(i.b)("li",{parentName:"ol"},"an ",Object(i.b)("inlineCode",{parentName:"li"},"optimizer"),".")),Object(i.b)("p",null,"For non-rigid registration we usually model the possible transformations using a Gaussian process. We use the Gaussian process that\nwe have defined above to define the transformation space."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)\n")),Object(i.b)("p",null,"As a metric, we use a simple mean squares metric. Currently, all metrics that are available in scalismo are implemented as\nimage to image metrics. These can, however, easily be used for surface registration by representing the surface as  a distance image.\nIn addition to the images, the metric also needs to know the possible transformations (as modelled by the transformation space) and\na sampler. The sampler determines the points where the metric is evaluated. In our case we choose uniformely sampled points on the\nreference mesh."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val fixedImage = referenceMesh.operations.toDistanceImage\nval movingImage = targetMesh.operations.toDistanceImage\nval sampler = FixedPointsUniformMeshSampler3D(referenceMesh, numberOfPoints = 1000)\nval metric = MeanSquaresMetric(fixedImage, movingImage, transformationSpace, sampler)\n")),Object(i.b)("p",null,"As an optimizer, we choose an LBFGS Optimizer"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val optimizer = LBFGSOptimizer(maxNumberOfIterations = 100)\n")),Object(i.b)("p",null,"and for regularization we choose to penalize the L2 norm using the ",Object(i.b)("inlineCode",{parentName:"p"},"L2Regularizer"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val regularizer = L2Regularizer(transformationSpace)\n")),Object(i.b)("p",null,"We are now ready to define Scalismo's registration object."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val registration = Registration(metric, regularizer, regularizationWeight = 1e-5, optimizer)\n")),Object(i.b)("p",null,"Registration is an iterative process. Consequently, we work with the registration using an iterator. We obtain an iterator by\ncalling the ",Object(i.b)("inlineCode",{parentName:"p"},"iterator")," method, where we also provide a starting position for the iteration (which is in this case the zero vector):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val initialCoefficients = DenseVector.zeros[Double](lowRankGP.rank)\nval registrationIterator = registration.iterator(initialCoefficients)\n")),Object(i.b)("p",null,"Before running the registration, we change the iterator such that it prints in each iteration to current objective value,\nand updates the visualization. This lets us visually inspect the progress of the registration procedure."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'val visualizingRegistrationIterator = for ((it, itnum) <- registrationIterator.zipWithIndex) yield {\n  println(s"object value in iteration $itnum is ${it.value}")\n  gpView.coefficients = it.parameters\n  it\n}\n')),Object(i.b)("p",null,'Note that the above code does not yet run the registration. It simply returns a new iterator, which augments\nthe original iteration with visualization. The actual registration is executed once we "consume" the iterator.\nThis can, for example be achieved by converting it to a sequence. The resulting sequence holds all the intermediate\nstates of the registration. We are usually only interested in the last one:'),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val registrationResult = visualizingRegistrationIterator.toSeq.last\n")),Object(i.b)("p",null,"You should see in the graphical user interface, how the face mesh slowly adapts to the shape of the target mesh."),Object(i.b)("p",null,"The final mesh representation can be obtained by obtaining the transform corresponding to the parameters and to\nwarp the reference mesh with this tranform:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val registrationTransformation = transformationSpace.transformForParameters(registrationResult.parameters)\nval fittedMesh = referenceMesh.transform(registrationTransformation)\n")),Object(i.b)("h3",{id:"working-with-the-registration-result"},"Working with the registration result"),Object(i.b)("p",null,"The fittedMesh that we obtained above is a surface that approximates the target surface.  It corresponds to the best representation of the target in the model. For most tasks, this approximation is sufficient.\nHowever, sometimes, we need an exact representation of the target mesh. This can be achieved by defining a projection function, which projects each point onto its closest point on the target."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val targetMeshOperations = targetMesh.operations\nval projection = (pt : Point[_3D]) => {\n  targetMeshOperations.closestPointOnSurface(pt).point\n}\n")),Object(i.b)("p",null,"Composing the result of the registration with this projection, will give us a mapping that identifies for each point of the reference mesh the corresponding point of the target mesh."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val finalTransformation = registrationTransformation.andThen(projection)\n")),Object(i.b)("p",null,"To check this last point, we warp the reference mesh with the finalTransform and visualize it. Note that the projected target now coincides with the target mesh.."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'val projectedMesh = referenceMesh.transform(finalTransformation)\nval resultGroup = ui.createGroup("result")\nval projectionView = ui.show(resultGroup, projectedMesh, "projection")\n')),Object(i.b)("h3",{id:"improving-registrations-for-more-complex-shapes"},"Improving registrations for more complex shapes."),Object(i.b)("p",null,"This registration procedure outlined above works reasonably well for simple cases. In complex cases, in particular if you have large\nshape variations, you may find it difficult to find a suitable regularization weight. When you choose the regularization weight\nlarge, the procedure will result in a nice and smooth mesh, but fails to closely fit the surface. If you choose it small, it may\nresult in folds and bad correspondences. In such cases it has proven extremely useful to simply iterate the registration procedure,\nwith decreasing regularization weights. In the following we illustrate this procedure. We start by defining a case class, which\ncollects all relevant parameters:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"case class RegistrationParameters(regularizationWeight : Double, numberOfIterations : Int, numberOfSampledPoints : Int)\n")),Object(i.b)("p",null,"We put all the registration code into a function, which takes (among others) the registration parameters as an argument."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},'def doRegistration(\n            lowRankGP : LowRankGaussianProcess[_3D, EuclideanVector[_3D]],\n            referenceMesh : TriangleMesh[_3D],\n            targetmesh : TriangleMesh[_3D],\n            registrationParameters : RegistrationParameters,\n            initialCoefficients : DenseVector[Double]\n        ) : DenseVector[Double] =\n    {\n        val transformationSpace = GaussianProcessTransformationSpace(lowRankGP)\n        val fixedImage = referenceMesh.operations.toDistanceImage\n        val movingImage = targetMesh.operations.toDistanceImage\n        val sampler = FixedPointsUniformMeshSampler3D(\n            referenceMesh,\n            registrationParameters.numberOfSampledPoints\n            )\n        val metric = MeanSquaresMetric(\n            fixedImage,\n            movingImage,\n            transformationSpace,\n            sampler\n            )\n        val optimizer = LBFGSOptimizer(registrationParameters.numberOfIterations)\n        val regularizer = L2Regularizer(transformationSpace)\n        val registration = Registration(\n            metric,\n            regularizer,\n            registrationParameters.regularizationWeight,\n            optimizer\n            )\n        val registrationIterator = registration.iterator(initialCoefficients)\n        val visualizingRegistrationIterator = for ((it, itnum) <- registrationIterator.zipWithIndex) yield {\n              println(s"object value in iteration $itnum is ${it.value}")\n              gpView.coefficients = it.parameters\n              it\n        }\n        val registrationResult = visualizingRegistrationIterator.toSeq.last\n        registrationResult.parameters\n    }\n')),Object(i.b)("p",null,"Finally, we define the parameters and run the registration. Note that for large regularization weights, we sample fewer points on the surface to save some computation time.\nThis is justified as, a strongly regularized model will not be able to adapt to fine details and hence it is not necessary to have a very accurate sampling of the surface."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-scala"},"val registrationParameters = Seq(\n        RegistrationParameters(regularizationWeight = 1e-1, numberOfIterations = 20, numberOfSampledPoints = 1000),\n        RegistrationParameters(regularizationWeight = 1e-2, numberOfIterations = 30, numberOfSampledPoints = 1000),\n        RegistrationParameters(regularizationWeight = 1e-4, numberOfIterations = 40, numberOfSampledPoints = 2000),\n        RegistrationParameters(regularizationWeight = 1e-6, numberOfIterations = 50, numberOfSampledPoints = 4000)\n    )\n\n    val finalCoefficients = registrationParameters.foldLeft(initialCoefficients)((modelCoefficients, regParameters) =>\n            doRegistration(lowRankGP, referenceMesh, targetMesh, regParameters, modelCoefficients))\n")),Object(i.b)("p",null,"From this point we use the procedure described above to work with the registration result."))}p.isMDXComponent=!0}}]);